{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nebula introduction","text":"<p>The project is separated into four main parts: \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u4e3b\u3068\u306a\u308b 4 \u3064\u306e\u30d1\u30fc\u30c8\u306b\u5206\u304b\u308c\u3066\u3044\u308b\uff1a Lidar \u30c9\u30e9\u30a4\u30d0\u3001ROS \u30e9\u30c3\u30d1\u30fc\u3001HWI \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3060\u3002</p> <ul> <li>Common: <code>nebula_common</code>. This packages contains the structures, data types, calibration and configuration definitions used among all the packages.</li> <li>Drivers: <code>nebula_decoders</code>. The Drivers take care of all the data parsing and conversion. Lidar \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u5168\u3066\u306e\u30bb\u30f3\u30b5\u901a\u4fe1\u3068\u30c7\u30fc\u30bf\u30d1\u30fc\u30b7\u30f3\u30b0\u3092\u7ba1\u7406\u3057\u3066\u3044\u308b\u3002</li> <li>ROS Nodes Wrappers: <code>nebula_ros</code>, The ROSWrappers are a lightweight layer responsible for the data conversion between the LidarDriver point cloud and the corresponding ROS counterparts. The ROSWrapper also provides methods for configuration and the obtention of the status information of the Lidar. ROS \u30e9\u30c3\u30d1\u30fc\u306f\u3001Lidar \u30c9\u30e9\u30a4\u30d0\u70b9\u7fa4\u3068\u5bfe\u5fdc\u3059\u308b ROS \u306e\u30ab\u30a6\u30f3\u30bf\u30fc\u30d1\u30fc\u30c4\u306e\u30c7\u30fc\u30bf\u5909\u63db\u3092\u638c\u308b\u8efd\u91cf\u306e\u30ec\u30a4\u30e4\u3067\u3042\u308b\u3002 ROS \u30e9\u30c3\u30d1\u30fc\u306f\u3001\u69cb\u6210\u65b9\u6cd5\u3001Lidar \u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u60c5\u5831\u53d6\u5f97\u306e\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u308b\u3002</li> <li>HWInterface: <code>nebula_hw_interfaces</code>. The HWInterface offers an abstraction layer between the parser and the sensor communication. HW \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001\u30d1\u30fc\u30b5\u3068\u30bb\u30f3\u30b5\u9593\u306e\u62bd\u8c61\u5316\u30ec\u30a4\u30e4\u3092\u63d0\u4f9b\u3057\u3066\u3044\u308b\u3002</li> </ul>"},{"location":"#nebula-common","title":"Nebula Common","text":"<p>The Nebula common package contains structure definition such as configuration, calibration, point types. It also contains other common status strings and conversions used among all the packages.</p>"},{"location":"#point-types","title":"Point Types","text":"<p>Nebula supports three point cloud output types. However, it can easily be extended to support other custom point cloud types.</p> <p>These definitions can be found in the <code>nebula_common/include/point_types.hpp</code>.</p>"},{"location":"#pointxyzir","title":"PointXYZIR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyzicaetr","title":"PointXYZICAETR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>channel</code> <code>uint8</code> Contains the laser channel id. <code>azimuth</code> <code>float</code> <code>rad</code> Contains the azimuth of the current point. <code>elevation</code> <code>float</code> <code>rad</code> Contains the elevation of the current point. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyzicatr","title":"PointXYZICATR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>channel</code> <code>uint8</code> Contains the laser channel id. <code>azimuth</code> <code>float</code> <code>degrees</code> Contains the azimuth of the current point. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyziradt","title":"PointXYZIRADT","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration. <code>azimuth</code> <code>float</code> <code>degrees</code> Contains the azimuth of the current point. <code>distance</code> <code>float</code> <code>m</code> Contains the distance from the sensor origin to this echo on the XY plane. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time."},{"location":"add_sensor/","title":"How to add your sensor","text":"<ol> <li>Add your sensor to the <code>SensorModel</code> enumeration class located in the <code>nebula_common.hpp</code> header inside the <code>nebula_common</code> package.</li> <li>Add your sensor model string to the <code>SensorModelFromString</code> method in the <code>nebula_common.hpp</code> header inside the <code>nebula_common</code> package.</li> <li>Write the sensor decoder for your sensor. This class is in charge of converting raw packets to point clouds. This class should implement the abstract class defined in <code>nebula_driver_base.hpp</code> inside the <code>nebula_decoders</code> package. Add methods as the sensor requires.</li> <li>Write the sensor hardware interface. This class is in charge of obtaining raw packets from the sensor using the <code>transport_drivers</code> library, accumulating them to form a scan, and making them available for consumption through callbacks. This class should implement the <code>nebula_hw_interface_base.hpp</code> inside the <code>nebula_hw_interfaces</code> package. Add methods as the sensor requires.</li> <li>Write the ROS wrappers. The ROS wrappers use the sensor libraries to obtain raw data, decode it and convert it to PointCloud2 ROS messages. The Decoder wrapper receives the configuration and calibration data from files and sends them as structures to the decoder and the hw_interface.</li> </ol>"},{"location":"design/","title":"Nebula requirements","text":"<p>The driver follows the following functional requirements: \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u6b21\u306e\u6a5f\u80fd\u7684\u306a\u8981\u6c42\u306b\u5fdc\u3048\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#hardware-interface-independent","title":"Hardware interface independent","text":"<p>The data acquisition and communication with the sensor must not be bound to a specific hardware interface. \u30bb\u30f3\u30b5\u3067\u306e\u30c7\u30fc\u30bf\u53d6\u5f97\u3068\u901a\u4fe1\u306f\u3001\u7279\u5b9a\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u306b\u7e1b\u3089\u308c\u3066\u306f\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#why","title":"Why?","text":"<p>Writing a general-purpose driver independent of the interface will support different types of hardware interfaces. \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u4f9d\u5b58\u3057\u306a\u3044\u6c4e\u7528\u30c9\u30e9\u30a4\u30d0\u3092\u66f8\u304f\u3053\u3068\u3067\u3001\u7570\u306a\u3063\u305f\u30bf\u30a4\u30d7\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#sensor-control","title":"Sensor Control","text":"<p>The driver should obtain, set, and confirm the desired sensor configuration at launch, i.e., scan frequency, synchronization methods, etc. \u30c9\u30e9\u30a4\u30d0\u306f\u8d77\u52d5\u6642\u306b\u3001\u671b\u307e\u3057\u3044\u30bb\u30f3\u30b5\u8a2d\u5b9a\uff08\u30b9\u30ad\u30e3\u30f3\u5468\u6ce2\u6570\u3001\u540c\u671f\u65b9\u6cd5\u7b49\uff09\u3092\u53d6\u5f97\u3001\u8a2d\u5b9a\u3001\u78ba\u8a8d\u3067\u304d\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002</p>"},{"location":"design/#why_1","title":"Why?","text":"<p>The sensor control will ensure that the sensor works in the expected mode as it was initially intended. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u30bb\u30f3\u30b5\u304c\u5f53\u521d\u3088\u308a\u610f\u56f3\u3057\u3066\u3044\u305f\u30e2\u30fc\u30c9\u3067\u52d5\u3044\u3066\u3044\u308b\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u308b\u3002</p>"},{"location":"design/#configurable-output-cloud","title":"Configurable output cloud","text":"<p>The ROS wrapper should be able to define the desired output format of the point cloud. i.e., customize the fields to be contained in the final output cloud. ROS \u30e9\u30c3\u30d1\u30fc\u306f\u70b9\u7fa4\u306e\u671b\u307e\u3057\u3044\u51fa\u529b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u5b9a\u7fa9\u3067\u304d\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\uff08\u6700\u7d42\u7684\u306a\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u306b\u542b\u307e\u308c\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3067\u304d\u308b\uff09 In addition, it should be able to generate the corresponding 2D range image for the output point cloud.</p> <p>\u3055\u3089\u306b\u3001\u51fa\u529b\u3055\u308c\u305f\u70b9\u7fa4\u3092\u5bfe\u5fdc\u3059\u308b\u4e8c\u6b21\u5143\u30ec\u30f3\u30b8\u753b\u50cf\u306b\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002 If the sensor allows it, have an option to add a minimum and maximum range distance as an option. For instance, if the user launches the driver with a range limit set to 0, the driver will not perform any filtering. \u30bb\u30f3\u30b5\u304c\u8a31\u53ef\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066\u6700\u5c0f\u5024\u3068\u6700\u5927\u5024\u306e\u30ec\u30f3\u30b8\u8ddd\u96e2\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001\u30e6\u30fc\u30b6\u30fc\u304c\u7bc4\u56f2\u5236\u9650\u3092 0 \u306b\u8a2d\u5b9a\u3057\u3066\u30c9\u30e9\u30a4\u30d0\u30fc\u3092\u8d77\u52d5\u3057\u305f\u5834\u5408\u3001\u30c9\u30e9\u30a4\u30d0\u306f\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3092\u884c\u308f\u306a\u3044\u3002 The driver should have an option to define if the output cloud is of a fixed size or dynamic size. If a fixed size is selected, the output cloud must include NaN values for those lasers without any return. If a dynamic size is selected, the lasers with no valid returns are to be removed. \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u3092\u56fa\u5b9a\u3055\u308c\u305f\u30b5\u30a4\u30ba\u304b\u3001\u3082\u3057\u304f\u306f\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u30b5\u30a4\u30ba\u306b\u3059\u308b\u304b\u3092\u5b9a\u7fa9\u3059\u308b\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u5fc5\u8981\u3067\u3042\u308b\u3002\u56fa\u5b9a\u3055\u308c\u305f\u30b5\u30a4\u30ba\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u3001\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u306f\u3001\u30ea\u30bf\u30fc\u30f3\u306e\u306a\u3044\u30ec\u30fc\u30b6\u306e NaN \u5024\u3092\u542b\u307e\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u30b5\u30a4\u30ba\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u3001\u30ea\u30bf\u30fc\u30f3\u306e\u306a\u3044\u30ec\u30fc\u30b6\u306f\u524a\u9664\u3055\u308c\u308b\u3002 Default behavior: Dynamic, remove invalid laser returns (NaN). \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u52d5\u4f5c\uff1a\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u3001\u7121\u52b9\u306a\u30ec\u30fc\u30b6\u30ea\u30bf\u30fc\u30f3\u3092\u524a\u9664\u3002\uff08NaN)</p>"},{"location":"design/#why_2","title":"Why?","text":"<p>The configurable output will allow the generation of the point cloud according to the expected use case application. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u4e88\u5b9a\u3057\u305f\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308a\u5fc5\u8981\u306a\u51fa\u529b\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#sensor-metadata","title":"Sensor Metadata","text":"<p>The driver should include the following metadata for each generated point cloud: \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u751f\u6210\u3055\u308c\u305f\u70b9\u7fa4\u305d\u308c\u305e\u308c\u306b\u3001\u6b21\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u304c\u542b\u307e\u308c\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\uff1a</p>"},{"location":"design/#calibration-data","title":"Calibration data \u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf","text":"<p>Contains the sensor calibration parameters used to generate the point cloud from the raw data. \u751f\u30c7\u30fc\u30bf\u304b\u3089\u70b9\u7fa4\u3092\u751f\u6210\u3059\u308b\u306e\u306b\u4f7f\u7528\u3057\u305f\u30bb\u30f3\u30b5\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30d1\u30e9\u30e1\u30fc\u30bf</p>"},{"location":"design/#sensor-settings","title":"Sensor settings \u30bb\u30f3\u30b5\u8a2d\u5b9a","text":"<p>The configuration mode in which the sensor is being executed: \u30bb\u30f3\u30b5\u304c\u5b9f\u884c\u3055\u308c\u305f\u8a2d\u5b9a\u30e2\u30fc\u30c9</p>"},{"location":"design/#synchronization-mode-ptp-ppsnmea-ptp-ppsnmea","title":"Synchronization mode (PTP, PPS/NMEA)\u3000\u540c\u671f\u30e2\u30fc\u30c9(PTP, PPS/NMEA)","text":"<p>Sensor Type \u30bb\u30f3\u30b5\u30bf\u30a4\u30d7 Sensor Model \u30bb\u30f3\u30b5\u30e2\u30c7\u30eb Scan frequency \u30b9\u30ad\u30e3\u30f3\u5468\u6ce2\u6570</p>"},{"location":"design/#why_3","title":"Why?","text":"<p>The processed point cloud or the raw data does not always contain the state on which the sensor was run. Moreover, having this information at hand will help identify, classify and understand the situation of the recorded data. \u51e6\u7406\u3057\u305f\u70b9\u7fa4\u3001\u3064\u307e\u308a\u751f\u30c7\u30fc\u30bf\u306f\u3001\u5e38\u306b\u30bb\u30f3\u30b5\u304c\u4f5c\u52d5\u3057\u305f\u72b6\u614b\u3092\u542b\u3093\u3067\u3044\u308b\u3068\u306f\u9650\u3089\u306a\u3044\u3002\u624b\u5143\u306b\u60c5\u5831\u304c\u3042\u308b\u3053\u3068\u306f\u3001\u8a18\u9332\u30c7\u30fc\u30bf\u306e\u72b6\u6cc1\u3092\u7d20\u65e9\u304f\u628a\u63e1\u3057\u3001\u5206\u985e\u3057\u3001\u7406\u89e3\u3059\u308b\u3053\u3068\u306e\u52a9\u3051\u306b\u306a\u308b\u3002</p>"},{"location":"design/#multi-echo-compatible","title":"Multi echo compatible","text":"<p>The sensor should consider the possibility of the future inclusion of more than two echos. \u30bb\u30f3\u30b5\u306f\uff12\u3064\u4ee5\u4e0a\u306e\u30a8\u30b3\u30fc\u304c\u5c06\u6765\u7684\u306b\u542b\u307e\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3053\u3068\u3092\u8003\u616e\u3059\u3079\u304d\u3067\u3042\u308b\u3002</p>"},{"location":"design/#why_4","title":"Why?","text":"<p>Multi-echo support will help to future-proof the driver according to new features included or used in new sensors. In addition, multiple echo support has been proven to improve sensor resilience against weather conditions such as rain, fog, and snow. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u65b0\u3057\u3044\u30bb\u30f3\u30b5\u306b\u642d\u8f09\u3055\u308c\u305f\u3001\u3082\u3057\u304f\u306f\u3001\u958b\u767a\u3055\u308c\u305f\u65b0\u6a5f\u80fd\u306b\u3088\u3063\u3066\u3001\u30c9\u30e9\u30a4\u30d0\u306e\u5c06\u6765\u6027\u3092\u9ad8\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u8907\u6570\u306e\u30a8\u30b3\u30fc\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u3067\u3001\u96e8\u3084\u9727\u3001\u96ea\u306a\u3069\u306e\u5929\u5019\u6761\u4ef6\u306b\u5bfe\u3057\u3066\u3001\u30bb\u30f3\u30b5\u306e\u56de\u5fa9\u529b\u304c\u6539\u5584\u3055\u308c\u308b\u3053\u3068\u304c\u8a3c\u660e\u3055\u308c\u3066\u3044\u308b\u3002</p>"},{"location":"design/#ros-independent","title":"ROS independent","text":"<p>The objects used inside the driver must be ROS independent. \u30c9\u30e9\u30a4\u30d0\u5185\u306b\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b API \u7b49\u306e\u5bfe\u8c61\u7269\u306f\u3001ROS \u306b\u4f9d\u5b58\u3057\u3066\u306f\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#why_5","title":"Why?","text":"<p>The third-party dependency reduction allows any software to be quickly updated without waiting for external dependencies to be updated. \u3053\u308c\u306b\u3088\u308a\u3001\u3069\u3093\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3067\u3082\u3001\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u306e\u305f\u3081\u306e\u5916\u90e8\u4f9d\u5b58\u3092\u5f85\u3064\u5fc5\u8981\u304c\u306a\u304f\u3001\u7d20\u65e9\u304f\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#offline-ready","title":"Offline ready","text":"<p>The data parser API inside the driver should not be designed to expect the data to be received in a real-time stream. \u30c9\u30e9\u30a4\u30d0\u5185\u306e\u30c7\u30fc\u30bf\u30d1\u30fc\u30b5 API \u306f\u3001\u30c7\u30fc\u30bf\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u30b9\u30c8\u30ea\u30fc\u30e0\u3067\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u8a2d\u8a08\u3055\u308c\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u3002</p>"},{"location":"design/#why_6","title":"Why?","text":"<p>Offline processing will help process the data faster than in real-time. \u3053\u308c\u306b\u3088\u308a\u3001\u30c7\u30fc\u30bf\u304c\u30bb\u30f3\u30b5\u306e\u4ee3\u308f\u308a\u306b\u30ed\u30b0\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u767a\u4fe1\u3055\u308c\u305f\u6642\u306b\u30c7\u30fc\u30bf\u51e6\u7406\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3088\u308a\u901f\u304f\u51e6\u7406\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"hesai_decoder_design/","title":"Generic Hesai Decoder","text":"<p>Since sensors from the same vendor often follow similar conventions when it comes to packet structure and data processing steps, a generic decoder can be used for most of the decoding work. This document outlines the requirements and design of the generic Hesai decoder.</p>"},{"location":"hesai_decoder_design/#requirements","title":"Requirements","text":"<p>There shall only be one decoder class which makes use of static (template) polymorphism to handle different sensor types. This way, runtime overhead for this generalization is <code>0</code>.</p>"},{"location":"hesai_decoder_design/#packet-formats","title":"Packet formats","text":"<p>For all handled Hesai sensors, the packet structure follows this rough format: 1. (optional) header: static sensor info and feature flags 2. body: point data 3. tail and other appendices: timestamp, operation mode info</p>"},{"location":"hesai_decoder_design/#decoding-steps","title":"Decoding steps","text":"<p>For all handled Hesai sensors, decoding a packet follows these steps: <pre><code>def unpack(packet):\n    parse_and_validate(packet)\n    # return group: one (single-return) or more (multi-return) \n    # blocks that belong to the same azimuth\n    for return_group in packet:\n        if is_start_of_new_scan(return_group):\n            # swap output buffers etc.\n        decode(return_group)\n\ndef decode(return_group):\n    for unit in return_group:\n        filter by:\n          distance thresholds\n          distance to other returns\n        correct azimuth/elevation *\n        compute x/y/z using sin/cos lookup tables *\n        compute time_offset to scan *\n        determine return_type *\n        append to pointcloud\n</code></pre></p> <p>The steps marked with * are model-specific:</p> <ul> <li>angle correction</li> <li>timing correction</li> <li>return type assignment</li> </ul>"},{"location":"hesai_decoder_design/#angle-correction","title":"Angle correction","text":"<p>There are two approaches between all the supported sensors: * Calibration file based * Correction file based (currently only used by AT128)</p> <p>For both approaches, sin/cos lookup tables can be computed. However, the resolution and calculation of these tables is different.</p>"},{"location":"hesai_decoder_design/#calibration-based","title":"Calibration based","text":"<p>For each laser channel, a fixed elevation angle and azimuth angle offset are defined in the calibration file. Thus, sin/cos for elevation are only a function of the laser channel (not dependent on azimuth) while those for azimuth are a function of azimuth AND elevation.</p> <p>Lookup tables for elevation can thus be sized with <code>n_channels</code>, yielding a maximum size of  <code>128 * sizeof(float) = 512B</code> each.</p> <p>For azimuth, the size is <code>n_channels * n_azimuths = n_channels * 360 * azimuth_resolution &lt;= 128 * 36000</code>. This yields a table size of <code>128 * 36000 * sizeof(float) \u2248 18.4MB</code>.</p>"},{"location":"hesai_decoder_design/#correction-based","title":"Correction based","text":"<p>While azimuth and elevation correction also have a per-channel component, an additional component depending on azimuth AND channel is present. The angular resolution of AT128 is <code>1 / (100 * 256) deg</code> and the per-channel correction as well as the additional component are defined as integers with the same or <code>1 / 100 deg</code> resolution respectively. This means that a lookup table of length <code>360 * 100 * 256</code> will contain sin/cos for all corrected values, since the resolution of corrections is smaller/equal to the base angular resolution.</p> <p>The lookup tables (of which there only need to be two: sin, cos; both usable for azimuth/elevation) each have a size of <code>360 * 100 * 256 * sizeof(float) \u2248 36.9MB</code>.</p>"},{"location":"hesai_decoder_design/#timing-correction","title":"Timing correction","text":"<p>Each sensor features an absolute timestamp per packet and formulae to compute the relative time between a unit or block and the packet.</p> <p>The desired output features a start timestamp per scan, and a relative timestamp to the scan for each point.</p> <p>Thus, the scan timestamp must be computed as the timestamp of the earliest point in the scan, and all packet-relative point times need to be converted to scan-relative ones. The earliest point in a scan is guaranteed to be in the first return group (\u2248 first 1-3 blocks) of the scan. Note that a scan can start mid-packet, if the scan phase does not align with packet bounds.</p> <p>The block offset follows a formula linear in the block index for all sensor models which additionally depends on the number of returns of the currently active <code>return_mode</code>. The parametrization is different for each sensor.</p> <p>The channel offset is given as a formula, table or set of tables for all sensors. A few sensors' formula is influenced by factors such as high resolution mode (128E3X, 128E4X), alternate firing sequences (QT128) and near/farfield firing (128E3X).</p>"},{"location":"hesai_decoder_design/#return-types","title":"Return types","text":"<p>While there is a wide range of different supported return modes (e.g. single (first), single (strongest), dual (first, last), etc.) their handling is largely the same. Differences only arise in multi-return (dual or triple) in the output order of the returns, and in the handling of some returns being duplicates (e.g. in dual(first, strongest), the first return coincides with the strongest one).</p> <p>Here is an exhaustive list of differences: * For Dual (First, Last) <code>0x3B</code>, 128E3X, 128E4X and XT32 reverse the output order (Last, First) * For Dual (Last, Strongest) <code>0x39</code>, all sensors except XT32M place the second strongest return in the even block if last == strongest * For Dual (First, Strongest) <code>0x3c</code>, the same as for <code>0x39</code> holds.</p> <p>For all other return modes, duplicate points are output if the two returns coincide.</p>"},{"location":"hesai_decoder_design/#implementation","title":"Implementation","text":""},{"location":"hesai_decoder_design/#hesaipacket","title":"<code>HesaiPacket</code>","text":"<p>Packets are defined as packed structs to enable parsing via <code>memcpy</code>. The sensor-specific layout for sensor XYZ is defined in <code>PacketXYZ</code> and usually employs an own <code>TailXYZ</code> struct. The header formats are largely shared between sensors. The packet body (i.e. point data) is mainly parameterized by bytes per point, points per block, and blocks per body. Thus, parameterized templated structs are used. A few skews such as fine azimuth blocks and blocks with a start-of-block (SOB) header exist and are implemented as their own structs.</p> <p></p>"},{"location":"hesai_decoder_design/#hesaisensor","title":"<code>HesaiSensor</code>","text":"<p>Each sensor model has its own class <code>PandarXYZ : HesaiSensor&lt;...&gt;</code> that defines packet type and timing, and return mode handling logic. Angle correction is the same for 90% of sensors and thus outsourced into <code>AngleCorrector</code> and subclasses. These are template arguments for <code>HesaiSensor</code>. Return mode handling has a default implementation that is supplemented by additional logic only in 3 sensors.</p>"},{"location":"hesai_decoder_design/#anglecorrector","title":"<code>AngleCorrector</code>","text":"<p>The angle corrector has three main tasks: * compute corrected azimuth/elevation for given azimuth and channel * implement <code>hasScanCompleted()</code> logic that decides where one scan ends and the next starts * compute and provide lookup tables for sin/cos/etc.</p> <p>The two angle correction types are calibration-based and correction-based. In both approaches, a file from the sensor is used to extract the angle correction for each azimuth/channel. For all approaches, cos/sin lookup tables in the appropriate size are generated (see requirements section above).</p>"},{"location":"hesai_decoder_design/#hesaidecodersensort","title":"<code>HesaiDecoder&lt;SensorT&gt;</code>","text":"<p>The decoder is in charge of the control flow and shared decoding steps of all sensors. It is a template class taking a sensor type <code>SensorT</code> from which packet type, angle correction etc. are deducted at compile time. Thus, this unified decoder is an almost zero-cost abstraction.</p> <p>Its tasks are: * parsing an incoming packet * managing decode/output point buffers * converting all points in the packet using the sensor-specific functions of <code>SensorT</code> where necessary</p> <p><code>HesaiDecoder&lt;SensorT&gt;</code> is a subclass of the existing <code>HesaiScanDecoder</code> to allow all template instantiations to be assigned to variables of the supertype.</p>"},{"location":"hesai_decoder_design/#supporting-a-new-sensor","title":"Supporting a new sensor","text":"<p>To support a new sensor model, first familiarize with the already implemented decoders. Then, consult the new sensor's datasheet and identify the following parameters:</p> Parameter Chapter Possible values Notes Header format 3.1 <code>Header12B</code>, <code>Header8B</code>, ... <code>Header12B</code> is the standard and comprises the UDP pre-header and header (6+6B) mentioned in the data sheets Blocks per packet 3.1 <code>2</code>, <code>6</code>, <code>10</code>, ... Number of channels 3.1 <code>32</code>, <code>40</code>, <code>64</code>, ... Unit format 3.1 <code>Unit3B</code>, <code>Unit4B</code>, ... Angle correction App. 3 <code>CALIBRATION</code>, <code>CORRECTION</code>, ... The datasheet usually specifies whether a calibration/correction file is used Timing correction App. 2 There is usually a block and channel component. These come in the form of formulas/lookup tables. For most sensors, these depend on return mode and for some, features like high resolution mode, alternate firing etc. might change the timing Return type handling 3.1 Return modes are handled identically for most sensors but some re-order the returns or replace returns if there are duplicates Bytes per second 1.4 Lowest supported frequency 1.4 <code>5 Hz</code>, <code>10 Hz</code>, ... Chapter Full title 1.4 Introduction &gt; Specifications 3.1 Data Structure &gt; Point Cloud Data Packet App. 2 Absolute Time of Point Cloud Data App. 3 Angle Correction <p>With this information, create a <code>PacketMySensor</code> struct and <code>SensorMySensor</code> class. Reuse already-defined structs as much as possible (c.f. <code>Packet128E3X</code> and <code>Packet128E4X</code>).</p> <p>Implement timing correction in <code>SensorMySensor</code> and define the class constants <code>float MIN_RANGE</code>, <code>float MAX_RANGE</code> and <code>size_t MAX_SCAN_BUFFER_POINTS</code>. The former two are used for filtering out too-close and too-far away points while the latter is used to allocate pointcloud buffers.  Set <code>MAX_SCAN_BUFFER_POINTS = bytes_per_second / lowest_supported_frequency</code> from the parameters found above.</p> <p>If there are any non-standard features your sensor has, implement them as generically as possible to allow for future sensors to re-use your code.</p>"},{"location":"nebula_common/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>struct HesaiStatus Status definition for Hesai. </li> <li>struct Status Status definition. </li> <li>struct VelodyneStatus Status definition for Velodyne. </li> <li>namespace drivers <ul> <li>struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) </li> <li>struct ChannelCorrection </li> <li>struct HesaiCalibrationConfiguration struct for Hesai calibration configuration </li> <li>struct HesaiCorrection struct for Hesai correction configuration (for AT) </li> <li>struct HesaiSensorConfiguration struct for Hesai sensor configuration </li> <li>struct PointField not used? </li> <li>struct PointXYZICATR </li> <li>struct PointXYZIR </li> <li>struct PointXYZIRADT </li> <li>struct PointXYZIRCAEDT </li> <li>struct RobosenseCalibrationConfiguration struct for Robosense calibration configuration </li> <li>struct RobosenseSensorConfiguration struct for Robosense sensor configuration </li> <li>struct SensorConfigurationBase Base struct for Sensor configuration. </li> <li>class VelodyneCalibration Calibration information for the entire device. </li> <li>struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration </li> <li>struct VelodyneLaserCorrection </li> <li>struct VelodyneSensorConfiguration struct for Velodyne sensor configuration </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_common/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_common <ul> <li>dir include <ul> <li>dir nebula_common <ul> <li>file nebula_common.hpp </li> <li>dir hesai <ul> <li>file hesai_common.hpp </li> <li>file hesai_status.hpp </li> </ul> </li> <li>dir robosense <ul> <li>file robosense_common.hpp </li> </ul> </li> <li>dir velodyne <ul> <li>file velodyne_calibration_decoder.hpp </li> <li>file velodyne_common.hpp </li> <li>file velodyne_status.hpp </li> </ul> </li> <li>file nebula_status.hpp </li> <li>file point_types.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_common/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_common/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers"},{"location":"nebula_common/namespacenebula/#classes","title":"Classes","text":"Type Name struct HesaiStatus Status definition for Hesai. struct Status Status definition. struct VelodyneStatus Status definition for Velodyne. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/","title":"Struct nebula::HesaiStatus","text":"<p>ClassList &gt; nebula &gt; HesaiStatus</p> <p>Status definition for Hesai.</p> <ul> <li><code>#include &lt;hesai_status.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::Status</p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types","title":"Public Types","text":"Type Name enum HesaiType"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types-inherited-from-nebulastatus","title":"Public Types inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum Type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::HesaiStatus::HesaiType _hesai_type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes-inherited-from-nebulastatus","title":"Public Attributes inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions","title":"Public Functions","text":"Type Name HesaiStatus ()  HesaiStatus (Type v)  HesaiStatus (HesaiType v)  HesaiStatus (int type)  Status ()  Status (Type v)  Status (int type)  int type () const"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions-inherited-from-nebulastatus","title":"Public Functions inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#enum-hesaitype","title":"enum HesaiType","text":"<pre><code>enum nebula::HesaiStatus::HesaiType {\n    INVALID_RPM_ERROR = Type_end_of_Status + 1,\n    INVALID_FOV_ERROR,\n    INVALID_RETURN_MODE_ERROR,\n    Type_end_of_Status = INVALID_RPM_ERROR\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#variable-_hesai_type","title":"variable _hesai_type","text":"<pre><code>enum nebula::HesaiStatus::HesaiType nebula::HesaiStatus::_hesai_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-14","title":"function HesaiStatus [1/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-24","title":"function HesaiStatus [2/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\n    Type v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-34","title":"function HesaiStatus [3/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\n    HesaiType v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-44","title":"function HesaiStatus [4/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\n    int type\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::HesaiStatus::Status () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::HesaiStatus::Status (\n    Type v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::HesaiStatus::Status (\n    int type\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-type","title":"function type","text":"<pre><code>inline int nebula::HesaiStatus::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::HesaiStatus::operator!= (\n    const HesaiStatus &amp; L,\n    const HesaiStatus &amp; R\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::HesaiStatus::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiStatus const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::HesaiStatus::operator== (\n    const HesaiStatus &amp; L,\n    const HesaiStatus &amp; R\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_status.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1Status/","title":"Struct nebula::Status","text":"<p>ClassList &gt; nebula &gt; Status</p> <p>Status definition.</p> <ul> <li><code>#include &lt;nebula_status.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::HesaiStatus,  nebula::VelodyneStatus</p>"},{"location":"nebula_common/structnebula_1_1Status/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"nebula_common/structnebula_1_1Status/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1Status/#public-functions","title":"Public Functions","text":"Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1Status/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#enum-type","title":"enum Type","text":"<pre><code>enum nebula::Status::Type {\n    OK = 0,\n    UDP_CONNECTION_ERROR,\n    SENSOR_CONFIG_ERROR,\n    INVALID_SENSOR_MODEL,\n    INVALID_ECHO_MODE,\n    NOT_IMPLEMENTED,\n    NOT_INITIALIZED,\n    INVALID_CALIBRATION_FILE,\n    CANNOT_SAVE_FILE,\n    HTTP_CONNECTION_ERROR,\n    WAITING_FOR_SENSOR_RESPONSE,\n    ERROR_1,\n    Type_end_of_Status = ERROR_1\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#variable-_type","title":"variable _type","text":"<pre><code>enum nebula::Status::Type nebula::Status::_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::Status::Status () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::Status::Status (\n    Type v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::Status::Status (\n    int type\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-type","title":"function type","text":"<pre><code>inline Type nebula::Status::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::Status::operator!= (\n    const Status &amp; L,\n    const Status &amp; R\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::Status::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::Status const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1Status/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::Status::operator== (\n    const Status &amp; L,\n    const Status &amp; R\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_status.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/","title":"Struct nebula::VelodyneStatus","text":"<p>ClassList &gt; nebula &gt; VelodyneStatus</p> <p>Status definition for Velodyne.</p> <ul> <li><code>#include &lt;velodyne_status.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::Status</p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types","title":"Public Types","text":"Type Name enum VelodyneType"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types-inherited-from-nebulastatus","title":"Public Types inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum Type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::VelodyneStatus::VelodyneType _velo_type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes-inherited-from-nebulastatus","title":"Public Attributes inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions","title":"Public Functions","text":"Type Name Status ()  Status (Type v)  Status (int type)  VelodyneStatus ()  VelodyneStatus (Type v)  VelodyneStatus (VelodyneType v)  VelodyneStatus (int type)  int type () const"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions-inherited-from-nebulastatus","title":"Public Functions inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#enum-velodynetype","title":"enum VelodyneType","text":"<pre><code>enum nebula::VelodyneStatus::VelodyneType {\n    INVALID_RPM_ERROR = Type_end_of_Status + 1,\n    INVALID_FOV_ERROR,\n    INVALID_RETURN_MODE_ERROR,\n    Type_end_of_Status = INVALID_RPM_ERROR\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#variable-_velo_type","title":"variable _velo_type","text":"<pre><code>enum nebula::VelodyneStatus::VelodyneType nebula::VelodyneStatus::_velo_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status (\n    Type v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status (\n    int type\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-14","title":"function VelodyneStatus [1/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-24","title":"function VelodyneStatus [2/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\n    Type v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-34","title":"function VelodyneStatus [3/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\n    VelodyneType v\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-44","title":"function VelodyneStatus [4/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\n    int type\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-type","title":"function type","text":"<pre><code>inline int nebula::VelodyneStatus::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::VelodyneStatus::operator!= (\n    const VelodyneStatus &amp; L,\n    const VelodyneStatus &amp; R\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::VelodyneStatus::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::VelodyneStatus const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::VelodyneStatus::operator== (\n    const VelodyneStatus &amp; L,\n    const VelodyneStatus &amp; R\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_status.hpp</code></p>"},{"location":"nebula_common/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) struct ChannelCorrection struct HesaiCalibrationConfiguration struct for Hesai calibration configuration struct HesaiCorrection struct for Hesai correction configuration (for AT) struct HesaiSensorConfiguration struct for Hesai sensor configuration struct PointField not used? struct PointXYZICATR struct PointXYZIR struct PointXYZIRADT struct PointXYZIRCAEDT struct RobosenseCalibrationConfiguration struct for Robosense calibration configuration struct RobosenseSensorConfiguration struct for Robosense sensor configuration struct SensorConfigurationBase Base struct for Sensor configuration. class VelodyneCalibration Calibration information for the entire device. struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration struct VelodyneLaserCorrection struct VelodyneSensorConfiguration struct for Velodyne sensor configuration"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-types","title":"Public Types","text":"Type Name enum CoordinateMode Coordinate mode for Velodyne's setting (need to check) typedef PointXYZIRCAEDT NebulaPoint typedef pcl::PointCloud&lt; NebulaPoint &gt; NebulaPointCloud typedef pcl::PointCloud&lt; NebulaPoint &gt;::Ptr NebulaPointCloudPtr typedef std::shared_ptr&lt; NebulaPoint &gt; NebulaPointPtr enum PtpProfile enum PtpTransportType enum uint8_t ReturnMode Return mode of each LiDAR. enum uint8_t ReturnType Return type of each scan. enum SensorModel Type of sensor. enum datatype not used?"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint8_t BPEARL_V4_FLAG   = = 0x04 struct nebula::drivers::PointXYZIR EIGEN_ALIGN16"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-functions","title":"Public Functions","text":"Type Name size_t GetChannelSize (const SensorModel &amp; model)  int IntFromReturnModeHesai (const ReturnMode return_mode, const SensorModel &amp; sensor_model) Convert ReturnMode enum to return mode number. PtpProfile PtpProfileFromString (const std::string &amp; ptp_profile) Converts String to PTP Profile. PtpTransportType PtpTransportTypeFromString (const std::string &amp; transport_type) Converts String to PTP TransportType. ReturnMode ReturnModeFromIntHesai (const int return_mode, const SensorModel &amp; sensor_model) Convert return mode number to ReturnMode enum. ReturnMode ReturnModeFromString (const std::string &amp; return_mode) Convert return mode name to ReturnMode enum. ReturnMode ReturnModeFromStringHesai (const std::string &amp; return_mode, const SensorModel &amp; sensor_model) Convert return mode name to ReturnMode enum (Hesai-specific ReturnModeFromString) ReturnMode ReturnModeFromStringRobosense (const std::string &amp; return_mode) Convert return mode name to ReturnMode enum (Robosense-specific ReturnModeFromString) ReturnMode ReturnModeFromStringVelodyne (const std::string &amp; return_mode) Convert return mode name to ReturnMode enum (Velodyne-specific ReturnModeFromString) uint8_t ReturnModeToInt (const ReturnMode &amp; mode) Convert ReturnMode enum to integer. ReturnType ReturnModeToReturnType (const ReturnMode &amp; mode) Convert ReturnMode enum to ReturnType enum for Pandar AT, XTM (temporary, not used) SensorModel SensorModelFromString (const std::string &amp; sensor_model) Convert sensor name to SensorModel enum (Upper and lower case letters must match) std::string SensorModelToString (const SensorModel &amp; sensor_model)  pcl::PointCloud&lt; PointXYZIR &gt;::Ptr convertPointXYZIRADTToPointXYZIR (const pcl::PointCloud&lt; PointXYZIRADT &gt;::ConstPtr &amp; input_pointcloud)  pcl::PointCloud&lt; PointXYZIR &gt;::Ptr convertPointXYZIRCAEDTToPointXYZIR (const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud)  pcl::PointCloud&lt; PointXYZIRADT &gt;::Ptr convertPointXYZIRCAEDTToPointXYZIRADT (const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud, double stamp)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, HesaiSensorConfiguration const &amp; arg) Convert HesaiSensorConfiguration to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::ReturnType const &amp; arg) Convert ReturnType enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::ReturnMode const &amp; arg) Convert ReturnMode enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::SensorModel const &amp; arg) Convert SensorModel enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::SensorConfigurationBase const &amp; arg) Convert SensorConfigurationBase to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::PtpProfile const &amp; arg) Convert PtpProfile enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::PtpTransportType const &amp; arg) Convert PtpTransportType enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, RobosenseSensorConfiguration const &amp; arg) Convert RobosenseSensorConfiguration to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, VelodyneSensorConfiguration const &amp; arg) Convert VelodyneSensorConfiguration to string (Overloading the &lt;&lt; operator)"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-static-functions","title":"Public Static Functions","text":"Type Name float deg2rad (double degrees) Converts degrees to radians. float rad2deg (double radians) Converts radians to degrees."},{"location":"nebula_common/namespacenebula_1_1drivers/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-coordinatemode","title":"enum CoordinateMode","text":"<pre><code>enum nebula::drivers::CoordinateMode {\n    UNKNOWN = 0,\n    CARTESIAN,\n    SPHERICAL,\n    CYLINDRICAL\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapoint","title":"typedef NebulaPoint","text":"<pre><code>using nebula::drivers::NebulaPoint = typedef PointXYZIRCAEDT;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointcloud","title":"typedef NebulaPointCloud","text":"<pre><code>using nebula::drivers::NebulaPointCloud = typedef pcl::PointCloud&lt;NebulaPoint&gt;;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointcloudptr","title":"typedef NebulaPointCloudPtr","text":"<pre><code>using nebula::drivers::NebulaPointCloudPtr = typedef pcl::PointCloud&lt;NebulaPoint&gt;::Ptr;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointptr","title":"typedef NebulaPointPtr","text":"<pre><code>using nebula::drivers::NebulaPointPtr = typedef std::shared_ptr&lt;NebulaPoint&gt;;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-ptpprofile","title":"enum PtpProfile","text":"<pre><code>enum nebula::drivers::PtpProfile {\n    IEEE_1588v2 = 0,\n    IEEE_802_1AS,\n    IEEE_802_1AS_AUTO,\n    PROFILE_UNKNOWN\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-ptptransporttype","title":"enum PtpTransportType","text":"<pre><code>enum nebula::drivers::PtpTransportType {\n    UDP_IP = 0,\n    L2,\n    UNKNOWN_TRANSPORT\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-returnmode","title":"enum ReturnMode","text":"<pre><code>enum nebula::drivers::ReturnMode {\n    UNKNOWN = 0,\n    SINGLE_STRONGEST,\n    SINGLE_LAST,\n    DUAL_FIRST,\n    DUAL_LAST,\n    DUAL_ONLY,\n    SINGLE_FIRST,\n    DUAL_STRONGEST_FIRST,\n    DUAL_STRONGEST_LAST,\n    DUAL_WEAK_FIRST,\n    DUAL_WEAK_LAST,\n    TRIPLE,\n    LAST,\n    STRONGEST,\n    DUAL_LAST_STRONGEST,\n    FIRST,\n    DUAL_LAST_FIRST,\n    DUAL_FIRST_STRONGEST,\n    DUAL\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-returntype","title":"enum ReturnType","text":"<pre><code>enum nebula::drivers::ReturnType {\n    UNKNOWN = 0,\n    LAST,\n    FIRST,\n    STRONGEST,\n    FIRST_WEAK,\n    LAST_WEAK,\n    IDENTICAL,\n    SECOND,\n    SECONDSTRONGEST,\n    FIRST_STRONGEST,\n    LAST_STRONGEST\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-sensormodel","title":"enum SensorModel","text":"<pre><code>enum nebula::drivers::SensorModel {\n    UNKNOWN = 0,\n    HESAI_PANDAR64,\n    HESAI_PANDAR40P,\n    HESAI_PANDAR40M,\n    HESAI_PANDARQT64,\n    HESAI_PANDARQT128,\n    HESAI_PANDARXT32,\n    HESAI_PANDARXT32M,\n    HESAI_PANDARAT128,\n    HESAI_PANDAR128_E3X,\n    HESAI_PANDAR128_E4X,\n    VELODYNE_VLS128,\n    VELODYNE_HDL64,\n    VELODYNE_VLP32,\n    VELODYNE_VLP32MR,\n    VELODYNE_HDL32,\n    VELODYNE_VLP16,\n    ROBOSENSE_HELIOS,\n    ROBOSENSE_BPEARL,\n    ROBOSENSE_BPEARL_V3,\n    ROBOSENSE_BPEARL_V4\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-datatype","title":"enum datatype","text":"<pre><code>enum nebula::drivers::datatype {\n    INT8 = 1,\n    UINT8 = 2,\n    INT16 = 3,\n    UINT16 = 4,\n    INT32 = 5,\n    UINT32 = 6,\n    FLOAT32 = 7,\n    FLOAT64 = 8\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#variable-bpearl_v4_flag","title":"variable BPEARL_V4_FLAG","text":"<pre><code>constexpr uint8_t nebula::drivers::BPEARL_V4_FLAG;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#variable-eigen_align16","title":"variable EIGEN_ALIGN16","text":"<pre><code>struct nebula::drivers::PointXYZIRADT nebula::drivers::EIGEN_ALIGN16;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#function-getchannelsize","title":"function GetChannelSize","text":"<pre><code>size_t nebula::drivers::GetChannelSize (\n    const SensorModel &amp; model\n) \n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-intfromreturnmodehesai","title":"function IntFromReturnModeHesai","text":"<p>Convert ReturnMode enum to return mode number. <pre><code>inline int nebula::drivers::IntFromReturnModeHesai (\n    const ReturnMode return_mode,\n    const SensorModel &amp; sensor_model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> target ReturnMode </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding return mode number for the hardware </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-ptpprofilefromstring","title":"function PtpProfileFromString","text":"<p>Converts String to PTP Profile. <pre><code>inline PtpProfile nebula::drivers::PtpProfileFromString (\n    const std::string &amp; ptp_profile\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ptp_profile</code> Profile as String </li> </ul> <p>Returns:</p> <p>Corresponding PtpProfile </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-ptptransporttypefromstring","title":"function PtpTransportTypeFromString","text":"<p>Converts String to PTP TransportType. <pre><code>inline PtpTransportType nebula::drivers::PtpTransportTypeFromString (\n    const std::string &amp; transport_type\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>transport_type</code> Transport as String </li> </ul> <p>Returns:</p> <p>Corresponding PtpTransportType </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefrominthesai","title":"function ReturnModeFromIntHesai","text":"<p>Convert return mode number to ReturnMode enum. <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromIntHesai (\n    const int return_mode,\n    const SensorModel &amp; sensor_model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode number from the hardware response </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstring","title":"function ReturnModeFromString","text":"<p>Convert return mode name to ReturnMode enum. <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromString (\n    const std::string &amp; return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstringhesai","title":"function ReturnModeFromStringHesai","text":"<p>Convert return mode name to ReturnMode enum (Hesai-specific ReturnModeFromString) <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromStringHesai (\n    const std::string &amp; return_mode,\n    const SensorModel &amp; sensor_model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstringrobosense","title":"function ReturnModeFromStringRobosense","text":"<p>Convert return mode name to ReturnMode enum (Robosense-specific ReturnModeFromString) <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromStringRobosense (\n    const std::string &amp; return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstringvelodyne","title":"function ReturnModeFromStringVelodyne","text":"<p>Convert return mode name to ReturnMode enum (Velodyne-specific ReturnModeFromString) <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromStringVelodyne (\n    const std::string &amp; return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodetoint","title":"function ReturnModeToInt","text":"<p>Convert ReturnMode enum to integer. <pre><code>inline uint8_t nebula::drivers::ReturnModeToInt (\n    const ReturnMode &amp; mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> </li> </ul> <p>Returns:</p> <p>Corresponding number </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodetoreturntype","title":"function ReturnModeToReturnType","text":"<p>Convert ReturnMode enum to ReturnType enum for Pandar AT, XTM (temporary, not used) <pre><code>inline ReturnType nebula::drivers::ReturnModeToReturnType (\n    const ReturnMode &amp; mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> </li> </ul> <p>Returns:</p> <p>Corresponding mode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-sensormodelfromstring","title":"function SensorModelFromString","text":"<p>Convert sensor name to SensorModel enum (Upper and lower case letters must match) <pre><code>inline SensorModel nebula::drivers::SensorModelFromString (\n    const std::string &amp; sensor_model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_model</code> Sensor name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding SensorModel </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-sensormodeltostring","title":"function SensorModelToString","text":"<pre><code>inline std::string nebula::drivers::SensorModelToString (\n    const SensorModel &amp; sensor_model\n) \n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyziradttopointxyzir","title":"function convertPointXYZIRADTToPointXYZIR","text":"<pre><code>pcl::PointCloud&lt; PointXYZIR &gt;::Ptr nebula::drivers::convertPointXYZIRADTToPointXYZIR (\n    const pcl::PointCloud&lt; PointXYZIRADT &gt;::ConstPtr &amp; input_pointcloud\n) \n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyzircaedttopointxyzir","title":"function convertPointXYZIRCAEDTToPointXYZIR","text":"<pre><code>pcl::PointCloud&lt; PointXYZIR &gt;::Ptr nebula::drivers::convertPointXYZIRCAEDTToPointXYZIR (\n    const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud\n) \n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyzircaedttopointxyziradt","title":"function convertPointXYZIRCAEDTToPointXYZIRADT","text":"<pre><code>pcl::PointCloud&lt; PointXYZIRADT &gt;::Ptr nebula::drivers::convertPointXYZIRCAEDTToPointXYZIRADT (\n    const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud,\n    double stamp\n) \n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator","title":"function operator&lt;&lt;","text":"<p>Convert HesaiSensorConfiguration to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    HesaiSensorConfiguration const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_1","title":"function operator&lt;&lt;","text":"<p>Convert ReturnType enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::ReturnType const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_2","title":"function operator&lt;&lt;","text":"<p>Convert ReturnMode enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::ReturnMode const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_3","title":"function operator&lt;&lt;","text":"<p>Convert SensorModel enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::SensorModel const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_4","title":"function operator&lt;&lt;","text":"<p>Convert SensorConfigurationBase to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::SensorConfigurationBase const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_5","title":"function operator&lt;&lt;","text":"<p>Convert PtpProfile enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::PtpProfile const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_6","title":"function operator&lt;&lt;","text":"<p>Convert PtpTransportType enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::drivers::PtpTransportType const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_7","title":"function operator&lt;&lt;","text":"<p>Convert RobosenseSensorConfiguration to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    RobosenseSensorConfiguration const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_8","title":"function operator&lt;&lt;","text":"<p>Convert VelodyneSensorConfiguration to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\n    std::ostream &amp; os,\n    VelodyneSensorConfiguration const &amp; arg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#function-deg2rad","title":"function deg2rad","text":"<p>Converts degrees to radians. <pre><code>static inline float nebula::drivers::deg2rad (\n    double degrees\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>radians</code> </li> </ul> <p>Returns:</p> <p>degrees </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-rad2deg","title":"function rad2deg","text":"<p>Converts radians to degrees. <pre><code>static inline float nebula::drivers::rad2deg (\n    double radians\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>radians</code> </li> </ul> <p>Returns:</p> <p>degrees </p> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/","title":"Struct nebula::drivers::CalibrationConfigurationBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; CalibrationConfigurationBase</p> <p>Base struct for Calibration configuration (Requires extensions in child struct) </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiCalibrationConfiguration,  nebula::drivers::RobosenseCalibrationConfiguration,  nebula::drivers::VelodyneCalibrationConfiguration</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#public-attributes","title":"Public Attributes","text":"Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#variable-calibration_file","title":"variable calibration_file","text":"<pre><code>std::string nebula::drivers::CalibrationConfigurationBase::calibration_file;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/","title":"Struct nebula::drivers::ChannelCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; ChannelCorrection</p> <ul> <li><code>#include &lt;robosense_common.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#public-attributes","title":"Public Attributes","text":"Type Name float azimuth   = {NAN} uint16_t channel   = {} float elevation   = {NAN}"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#public-functions","title":"Public Functions","text":"Type Name bool has_value () const"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::ChannelCorrection::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#variable-channel","title":"variable channel","text":"<pre><code>uint16_t nebula::drivers::ChannelCorrection::channel;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#variable-elevation","title":"variable elevation","text":"<pre><code>float nebula::drivers::ChannelCorrection::elevation;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1ChannelCorrection/#function-has_value","title":"function has_value","text":"<pre><code>inline bool nebula::drivers::ChannelCorrection::has_value () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/robosense/robosense_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/","title":"Struct nebula::drivers::HesaiCalibrationConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiCalibrationConfiguration</p> <p>struct for Hesai calibration configuration </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::CalibrationConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; size_t, float &gt; azimuth_offset_map std::map&lt; size_t, float &gt; elev_angle_map"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes-inherited-from-nebuladriverscalibrationconfigurationbase","title":"Public Attributes inherited from nebula::drivers::CalibrationConfigurationBase","text":"<p>See nebula::drivers::CalibrationConfigurationBase</p> Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromFile (const std::string &amp; calibration_file)  nebula::Status LoadFromString (const std::string &amp; calibration_content) Loading calibration data. nebula::Status SaveFile (const std::string &amp; calibration_file) Saving calibration data (not used) nebula::Status SaveFileFromString (const std::string &amp; calibration_file, const std::string &amp; calibration_string) Saving calibration data from string."},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#variable-azimuth_offset_map","title":"variable azimuth_offset_map","text":"<pre><code>std::map&lt;size_t, float&gt; nebula::drivers::HesaiCalibrationConfiguration::azimuth_offset_map;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#variable-elev_angle_map","title":"variable elev_angle_map","text":"<pre><code>std::map&lt;size_t, float&gt; nebula::drivers::HesaiCalibrationConfiguration::elev_angle_map;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::LoadFromFile (\n    const std::string &amp; calibration_file\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-loadfromstring","title":"function LoadFromString","text":"<p>Loading calibration data. <pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::LoadFromString (\n    const std::string &amp; calibration_content\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_content</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-savefile","title":"function SaveFile","text":"<p>Saving calibration data (not used) <pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::SaveFile (\n    const std::string &amp; calibration_file\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_file</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-savefilefromstring","title":"function SaveFileFromString","text":"<p>Saving calibration data from string. <pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::SaveFileFromString (\n    const std::string &amp; calibration_file,\n    const std::string &amp; calibration_string\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_file</code> path </li> <li><code>calibration_string</code> calibration string </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/","title":"Struct nebula::drivers::HesaiCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiCorrection</p> <p>struct for Hesai correction configuration (for AT) </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t SHA256 int32_t azimuth int8_t azimuthOffset uint8_t channelNumber uint16_t delimiter int32_t elevation int8_t elevationOffset uint32_t endFrame uint8_t frameConfig uint8_t frameNumber uint8_t mirrorNumber uint8_t resolution uint32_t startFrame uint8_t versionMajor uint8_t versionMinor"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int STEP3   = = 200 * 256"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromBinary (const std::vector&lt; uint8_t &gt; &amp; buf) Load correction data from file. nebula::Status LoadFromFile (const std::string &amp; correction_file) Load correction data from file. nebula::Status SaveFileFromBinary (const std::string &amp; correction_file, const std::vector&lt; uint8_t &gt; &amp; buf) Save correction data from binary buffer. int8_t getAzimuthAdjustV3 (uint8_t ch, uint32_t azi) constGet azimuth adjustment for channel and precision azimuth. int8_t getElevationAdjustV3 (uint8_t ch, uint32_t azi) constGet elevation adjustment for channel and precision azimuth."},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-sha256","title":"variable SHA256","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::SHA256[32];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-azimuth","title":"variable azimuth","text":"<pre><code>int32_t nebula::drivers::HesaiCorrection::azimuth[128];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-azimuthoffset","title":"variable azimuthOffset","text":"<pre><code>int8_t nebula::drivers::HesaiCorrection::azimuthOffset[36000];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-channelnumber","title":"variable channelNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::channelNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-delimiter","title":"variable delimiter","text":"<pre><code>uint16_t nebula::drivers::HesaiCorrection::delimiter;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-elevation","title":"variable elevation","text":"<pre><code>int32_t nebula::drivers::HesaiCorrection::elevation[128];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-elevationoffset","title":"variable elevationOffset","text":"<pre><code>int8_t nebula::drivers::HesaiCorrection::elevationOffset[36000];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-endframe","title":"variable endFrame","text":"<pre><code>uint32_t nebula::drivers::HesaiCorrection::endFrame[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-frameconfig","title":"variable frameConfig","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::frameConfig[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-framenumber","title":"variable frameNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::frameNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-mirrornumber","title":"variable mirrorNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::mirrorNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-resolution","title":"variable resolution","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::resolution;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-startframe","title":"variable startFrame","text":"<pre><code>uint32_t nebula::drivers::HesaiCorrection::startFrame[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-versionmajor","title":"variable versionMajor","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::versionMajor;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-versionminor","title":"variable versionMinor","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::versionMinor;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-step3","title":"variable STEP3","text":"<pre><code>const int nebula::drivers::HesaiCorrection::STEP3;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-loadfrombinary","title":"function LoadFromBinary","text":"<p>Load correction data from file. <pre><code>inline nebula::Status nebula::drivers::HesaiCorrection::LoadFromBinary (\n    const std::vector&lt; uint8_t &gt; &amp; buf\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> Binary buffer </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-loadfromfile","title":"function LoadFromFile","text":"<p>Load correction data from file. <pre><code>inline nebula::Status nebula::drivers::HesaiCorrection::LoadFromFile (\n    const std::string &amp; correction_file\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>correction_file</code> path </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-savefilefrombinary","title":"function SaveFileFromBinary","text":"<p>Save correction data from binary buffer. <pre><code>inline nebula::Status nebula::drivers::HesaiCorrection::SaveFileFromBinary (\n    const std::string &amp; correction_file,\n    const std::vector&lt; uint8_t &gt; &amp; buf\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>correction_file</code> path </li> <li><code>buf</code> correction binary </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-getazimuthadjustv3","title":"function getAzimuthAdjustV3","text":"<p>Get azimuth adjustment for channel and precision azimuth. <pre><code>inline int8_t nebula::drivers::HesaiCorrection::getAzimuthAdjustV3 (\n    uint8_t ch,\n    uint32_t azi\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ch</code> The channel id </li> <li><code>azi</code> The precision azimuth in (0.01 / 256) degree unit </li> </ul> <p>Returns:</p> <p>The azimuth adjustment in 0.01 degree unit </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-getelevationadjustv3","title":"function getElevationAdjustV3","text":"<p>Get elevation adjustment for channel and precision azimuth. <pre><code>inline int8_t nebula::drivers::HesaiCorrection::getElevationAdjustV3 (\n    uint8_t ch,\n    uint32_t azi\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ch</code> The channel id </li> <li><code>azi</code> The precision azimuth in (0.01 / 256) degree unit </li> </ul> <p>Returns:</p> <p>The elevation adjustment in 0.01 degree unit </p> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/","title":"Struct nebula::drivers::HesaiSensorConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiSensorConfiguration</p> <p>struct for Hesai sensor configuration </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::SensorConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t cloud_max_angle uint16_t cloud_min_angle double dual_return_distance_threshold   = {} uint16_t gnss_port   = {} uint8_t ptp_domain PtpProfile ptp_profile PtpTransportType ptp_transport_type uint16_t rotation_speed double scan_phase   = {}"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes-inherited-from-nebuladriverssensorconfigurationbase","title":"Public Attributes inherited from nebula::drivers::SensorConfigurationBase","text":"<p>See nebula::drivers::SensorConfigurationBase</p> Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model bool use_sensor_time   = {false}"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-cloud_max_angle","title":"variable cloud_max_angle","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::cloud_max_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-cloud_min_angle","title":"variable cloud_min_angle","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::cloud_min_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-dual_return_distance_threshold","title":"variable dual_return_distance_threshold","text":"<pre><code>double nebula::drivers::HesaiSensorConfiguration::dual_return_distance_threshold;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-gnss_port","title":"variable gnss_port","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::gnss_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-ptp_domain","title":"variable ptp_domain","text":"<pre><code>uint8_t nebula::drivers::HesaiSensorConfiguration::ptp_domain;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-ptp_profile","title":"variable ptp_profile","text":"<pre><code>PtpProfile nebula::drivers::HesaiSensorConfiguration::ptp_profile;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-ptp_transport_type","title":"variable ptp_transport_type","text":"<pre><code>PtpTransportType nebula::drivers::HesaiSensorConfiguration::ptp_transport_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::rotation_speed;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-scan_phase","title":"variable scan_phase","text":"<pre><code>double nebula::drivers::HesaiSensorConfiguration::scan_phase;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/","title":"Struct nebula::drivers::PointField","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointField</p> <p>not used? </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t count uint8_t datatype std::string name uint32_t offset"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-count","title":"variable count","text":"<pre><code>uint32_t nebula::drivers::PointField::count;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-datatype","title":"variable datatype","text":"<pre><code>uint8_t nebula::drivers::PointField::datatype;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-name","title":"variable name","text":"<pre><code>std::string nebula::drivers::PointField::name;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-offset","title":"variable offset","text":"<pre><code>uint32_t nebula::drivers::PointField::offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/","title":"Struct nebula::drivers::PointXYZICATR","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZICATR</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float azimuth std::uint16_t channel std::uint8_t intensity std::uint8_t return_type std::uint32_t time_stamp"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZICATR::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZICATR::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-channel","title":"variable channel","text":"<pre><code>std::uint16_t nebula::drivers::PointXYZICATR::channel;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-intensity","title":"variable intensity","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZICATR::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-return_type","title":"variable return_type","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZICATR::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>std::uint32_t nebula::drivers::PointXYZICATR::time_stamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/","title":"Struct nebula::drivers::PointXYZIR","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIR</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float intensity uint16_t ring"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZIR::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-intensity","title":"variable intensity","text":"<pre><code>float nebula::drivers::PointXYZIR::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-ring","title":"variable ring","text":"<pre><code>uint16_t nebula::drivers::PointXYZIR::ring;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/","title":"Struct nebula::drivers::PointXYZIRADT","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIRADT</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float azimuth float distance float intensity uint8_t return_type uint16_t ring double time_stamp"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZIRADT::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZIRADT::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::PointXYZIRADT::distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-intensity","title":"variable intensity","text":"<pre><code>float nebula::drivers::PointXYZIRADT::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-return_type","title":"variable return_type","text":"<pre><code>uint8_t nebula::drivers::PointXYZIRADT::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-ring","title":"variable ring","text":"<pre><code>uint16_t nebula::drivers::PointXYZIRADT::ring;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>double nebula::drivers::PointXYZIRADT::time_stamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/","title":"Struct nebula::drivers::PointXYZIRCAEDT","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIRCAEDT</p> <p>More...</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#public-attributes","title":"Public Attributes","text":"Type Name float azimuth std::uint16_t channel float distance float elevation std::uint8_t intensity std::uint8_t return_type std::uint32_t time_stamp float x float y float z"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#detailed-description","title":"Detailed Description","text":"<p>This point type is not using PCL_ADD_POINT4D to avoid the addition of a 32-bit dummy word. The fields are ordered to meet the SSE alignment. </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-channel","title":"variable channel","text":"<pre><code>std::uint16_t nebula::drivers::PointXYZIRCAEDT::channel;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-elevation","title":"variable elevation","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::elevation;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-intensity","title":"variable intensity","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZIRCAEDT::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-return_type","title":"variable return_type","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZIRCAEDT::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>std::uint32_t nebula::drivers::PointXYZIRCAEDT::time_stamp;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-x","title":"variable x","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::x;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-y","title":"variable y","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::y;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-z","title":"variable z","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/","title":"Struct nebula::drivers::RobosenseCalibrationConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseCalibrationConfiguration</p> <p>struct for Robosense calibration configuration </p> <ul> <li><code>#include &lt;robosense_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::CalibrationConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; ChannelCorrection &gt; calibration"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#public-attributes-inherited-from-nebuladriverscalibrationconfigurationbase","title":"Public Attributes inherited from nebula::drivers::CalibrationConfigurationBase","text":"<p>See nebula::drivers::CalibrationConfigurationBase</p> Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#public-functions","title":"Public Functions","text":"Type Name void CreateCorrectedChannels ()  ChannelCorrection GetCorrection (const size_t channel_id) const nebula::Status LoadFromFile (const std::string &amp; calibration_file)  nebula::Status LoadFromStream (stream_t &amp; stream)  nebula::Status LoadFromString (const std::string &amp; calibration_content) Loading calibration data (not used) nebula::Status SaveFile (const std::string &amp; calibration_file) Saving calibration data (not used) void SetChannelSize (const size_t channel_num)"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#variable-calibration","title":"variable calibration","text":"<pre><code>std::vector&lt;ChannelCorrection&gt; nebula::drivers::RobosenseCalibrationConfiguration::calibration;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-createcorrectedchannels","title":"function CreateCorrectedChannels","text":"<pre><code>inline void nebula::drivers::RobosenseCalibrationConfiguration::CreateCorrectedChannels () \n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-getcorrection","title":"function GetCorrection","text":"<pre><code>inline ChannelCorrection nebula::drivers::RobosenseCalibrationConfiguration::GetCorrection (\n    const size_t channel_id\n) const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline nebula::Status nebula::drivers::RobosenseCalibrationConfiguration::LoadFromFile (\n    const std::string &amp; calibration_file\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-loadfromstream","title":"function LoadFromStream","text":"<pre><code>template&lt;typename stream_t typename stream_t&gt;\ninline nebula::Status nebula::drivers::RobosenseCalibrationConfiguration::LoadFromStream (\n    stream_t &amp; stream\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-loadfromstring","title":"function LoadFromString","text":"<p>Loading calibration data (not used) <pre><code>inline nebula::Status nebula::drivers::RobosenseCalibrationConfiguration::LoadFromString (\n    const std::string &amp; calibration_content\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_content</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-savefile","title":"function SaveFile","text":"<p>Saving calibration data (not used) <pre><code>inline nebula::Status nebula::drivers::RobosenseCalibrationConfiguration::SaveFile (\n    const std::string &amp; calibration_file\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_file</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseCalibrationConfiguration/#function-setchannelsize","title":"function SetChannelSize","text":"<pre><code>inline void nebula::drivers::RobosenseCalibrationConfiguration::SetChannelSize (\n    const size_t channel_num\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/robosense/robosense_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/","title":"Struct nebula::drivers::RobosenseSensorConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseSensorConfiguration</p> <p>struct for Robosense sensor configuration </p> <ul> <li><code>#include &lt;robosense_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::SensorConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t cloud_max_angle uint16_t cloud_min_angle double dual_return_distance_threshold   = {} uint16_t gnss_port   = {} uint16_t rotation_speed double scan_phase   = {}"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#public-attributes-inherited-from-nebuladriverssensorconfigurationbase","title":"Public Attributes inherited from nebula::drivers::SensorConfigurationBase","text":"<p>See nebula::drivers::SensorConfigurationBase</p> Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model bool use_sensor_time   = {false}"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-cloud_max_angle","title":"variable cloud_max_angle","text":"<pre><code>uint16_t nebula::drivers::RobosenseSensorConfiguration::cloud_max_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-cloud_min_angle","title":"variable cloud_min_angle","text":"<pre><code>uint16_t nebula::drivers::RobosenseSensorConfiguration::cloud_min_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-dual_return_distance_threshold","title":"variable dual_return_distance_threshold","text":"<pre><code>double nebula::drivers::RobosenseSensorConfiguration::dual_return_distance_threshold;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-gnss_port","title":"variable gnss_port","text":"<pre><code>uint16_t nebula::drivers::RobosenseSensorConfiguration::gnss_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>uint16_t nebula::drivers::RobosenseSensorConfiguration::rotation_speed;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1RobosenseSensorConfiguration/#variable-scan_phase","title":"variable scan_phase","text":"<pre><code>double nebula::drivers::RobosenseSensorConfiguration::scan_phase;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/robosense/robosense_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/","title":"Struct nebula::drivers::SensorConfigurationBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; SensorConfigurationBase</p> <p>Base struct for Sensor configuration. </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiSensorConfiguration,  nebula::drivers::RobosenseSensorConfiguration,  nebula::drivers::VelodyneSensorConfiguration</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#public-attributes","title":"Public Attributes","text":"Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model bool use_sensor_time   = {false}"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-coordinate_mode","title":"variable coordinate_mode","text":"<pre><code>CoordinateMode nebula::drivers::SensorConfigurationBase::coordinate_mode;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-data_port","title":"variable data_port","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::data_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-fields","title":"variable fields","text":"<pre><code>std::vector&lt;PointField&gt; nebula::drivers::SensorConfigurationBase::fields;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-frame_id","title":"variable frame_id","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::frame_id;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-frequency_ms","title":"variable frequency_ms","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::frequency_ms;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-host_ip","title":"variable host_ip","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::host_ip;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-max_range","title":"variable max_range","text":"<pre><code>double nebula::drivers::SensorConfigurationBase::max_range;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-min_range","title":"variable min_range","text":"<pre><code>double nebula::drivers::SensorConfigurationBase::min_range;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-packet_mtu_size","title":"variable packet_mtu_size","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::packet_mtu_size;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-remove_nans","title":"variable remove_nans","text":"<pre><code>bool nebula::drivers::SensorConfigurationBase::remove_nans;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-return_mode","title":"variable return_mode","text":"<pre><code>ReturnMode nebula::drivers::SensorConfigurationBase::return_mode;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-sensor_ip","title":"variable sensor_ip","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::sensor_ip;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-sensor_model","title":"variable sensor_model","text":"<pre><code>SensorModel nebula::drivers::SensorConfigurationBase::sensor_model;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-use_sensor_time","title":"variable use_sensor_time","text":"<pre><code>bool nebula::drivers::SensorConfigurationBase::use_sensor_time;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/","title":"Class nebula::drivers::VelodyneCalibration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneCalibration</p> <p>Calibration information for the entire device. </p> <ul> <li><code>#include &lt;velodyne_calibration_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-attributes","title":"Public Attributes","text":"Type Name float distance_resolution_m bool initialized std::vector&lt; VelodyneLaserCorrection &gt; laser_corrections std::map&lt; int, VelodyneLaserCorrection &gt; laser_corrections_map int num_lasers   = {} bool ros_info"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-functions","title":"Public Functions","text":"Type Name VelodyneCalibration (bool info=true)  VelodyneCalibration (const std::string &amp; calibration_file, bool info=true)  void read (const std::string &amp; calibration_file)  void write (const std::string &amp; calibration_file)"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-distance_resolution_m","title":"variable distance_resolution_m","text":"<pre><code>float nebula::drivers::VelodyneCalibration::distance_resolution_m;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-initialized","title":"variable initialized","text":"<pre><code>bool nebula::drivers::VelodyneCalibration::initialized;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-laser_corrections","title":"variable laser_corrections","text":"<pre><code>std::vector&lt;VelodyneLaserCorrection&gt; nebula::drivers::VelodyneCalibration::laser_corrections;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-laser_corrections_map","title":"variable laser_corrections_map","text":"<pre><code>std::map&lt;int, VelodyneLaserCorrection&gt; nebula::drivers::VelodyneCalibration::laser_corrections_map;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-num_lasers","title":"variable num_lasers","text":"<pre><code>int nebula::drivers::VelodyneCalibration::num_lasers;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-ros_info","title":"variable ros_info","text":"<pre><code>bool nebula::drivers::VelodyneCalibration::ros_info;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-velodynecalibration-12","title":"function VelodyneCalibration [1/2]","text":"<pre><code>inline explicit nebula::drivers::VelodyneCalibration::VelodyneCalibration (\n    bool info=true\n) \n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-velodynecalibration-22","title":"function VelodyneCalibration [2/2]","text":"<pre><code>inline explicit nebula::drivers::VelodyneCalibration::VelodyneCalibration (\n    const std::string &amp; calibration_file,\n    bool info=true\n) \n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-read","title":"function read","text":"<pre><code>void nebula::drivers::VelodyneCalibration::read (\n    const std::string &amp; calibration_file\n) \n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-write","title":"function write","text":"<pre><code>void nebula::drivers::VelodyneCalibration::write (\n    const std::string &amp; calibration_file\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/","title":"Struct nebula::drivers::VelodyneCalibrationConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneCalibrationConfiguration</p> <p>struct for Velodyne calibration configuration </p> <ul> <li><code>#include &lt;velodyne_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::CalibrationConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name VelodyneCalibration velodyne_calibration"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes-inherited-from-nebuladriverscalibrationconfigurationbase","title":"Public Attributes inherited from nebula::drivers::CalibrationConfigurationBase","text":"<p>See nebula::drivers::CalibrationConfigurationBase</p> Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromFile (const std::string &amp; calibration_file)  nebula::Status SaveFile (const std::string &amp; calibration_file)"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#variable-velodyne_calibration","title":"variable velodyne_calibration","text":"<pre><code>VelodyneCalibration nebula::drivers::VelodyneCalibrationConfiguration::velodyne_calibration;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline nebula::Status nebula::drivers::VelodyneCalibrationConfiguration::LoadFromFile (\n    const std::string &amp; calibration_file\n) \n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#function-savefile","title":"function SaveFile","text":"<pre><code>inline nebula::Status nebula::drivers::VelodyneCalibrationConfiguration::SaveFile (\n    const std::string &amp; calibration_file\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/","title":"Struct nebula::drivers::VelodyneLaserCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneLaserCorrection</p> <ul> <li><code>#include &lt;velodyne_calibration_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#public-attributes","title":"Public Attributes","text":"Type Name float cos_rot_correction cosine of rot_correction float cos_vert_correction cosine of vert_correction float dist_correction float dist_correction_x float dist_correction_y float focal_distance float focal_slope float horiz_offset_correction int laser_ring ring number for this laser int max_intensity int min_intensity float rot_correction float sin_rot_correction sine of rot_correction float sin_vert_correction sine of vert_correction bool two_pt_correction_available float vert_correction float vert_offset_correction"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-cos_rot_correction","title":"variable cos_rot_correction","text":"<p>cosine of rot_correction <pre><code>float nebula::drivers::VelodyneLaserCorrection::cos_rot_correction;\n</code></pre></p> <p>cached values calculated when the calibration file is read </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-cos_vert_correction","title":"variable cos_vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::cos_vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction","title":"variable dist_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction_x","title":"variable dist_correction_x","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction_x;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction_y","title":"variable dist_correction_y","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction_y;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-focal_distance","title":"variable focal_distance","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::focal_distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-focal_slope","title":"variable focal_slope","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::focal_slope;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-horiz_offset_correction","title":"variable horiz_offset_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::horiz_offset_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-laser_ring","title":"variable laser_ring","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::laser_ring;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-max_intensity","title":"variable max_intensity","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::max_intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-min_intensity","title":"variable min_intensity","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::min_intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-rot_correction","title":"variable rot_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::rot_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-sin_rot_correction","title":"variable sin_rot_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::sin_rot_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-sin_vert_correction","title":"variable sin_vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::sin_vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-two_pt_correction_available","title":"variable two_pt_correction_available","text":"<pre><code>bool nebula::drivers::VelodyneLaserCorrection::two_pt_correction_available;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-vert_correction","title":"variable vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-vert_offset_correction","title":"variable vert_offset_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::vert_offset_correction;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/","title":"Struct nebula::drivers::VelodyneSensorConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneSensorConfiguration</p> <p>struct for Velodyne sensor configuration </p> <ul> <li><code>#include &lt;velodyne_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::SensorConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t cloud_max_angle uint16_t cloud_min_angle uint16_t gnss_port   = {} uint16_t rotation_speed double scan_phase   = {}"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes-inherited-from-nebuladriverssensorconfigurationbase","title":"Public Attributes inherited from nebula::drivers::SensorConfigurationBase","text":"<p>See nebula::drivers::SensorConfigurationBase</p> Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model bool use_sensor_time   = {false}"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-cloud_max_angle","title":"variable cloud_max_angle","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::cloud_max_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-cloud_min_angle","title":"variable cloud_min_angle","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::cloud_min_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-gnss_port","title":"variable gnss_port","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::gnss_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::rotation_speed;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-scan_phase","title":"variable scan_phase","text":"<pre><code>double nebula::drivers::VelodyneSensorConfiguration::scan_phase;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/dir_641be904c0d17ffe4f28a10e8f3d9a52/","title":"Dir nebula_common","text":"<p>FileList &gt; nebula_common</p>"},{"location":"nebula_common/dir_641be904c0d17ffe4f28a10e8f3d9a52/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_common/</code></p>"},{"location":"nebula_common/dir_78168b4d319b5936ba23a59e4e5ed862/","title":"Dir nebula_common/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_common/dir_78168b4d319b5936ba23a59e4e5ed862/#directories","title":"Directories","text":"Type Name dir nebula_common <p>The documentation for this class was generated from the following file <code>nebula_common/include/</code></p>"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/","title":"Dir nebula_common/include/nebula_common","text":"<p>FileList &gt; include &gt; nebula_common</p>"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/#files","title":"Files","text":"Type Name file nebula_common.hpp file nebula_status.hpp file point_types.hpp"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/#directories","title":"Directories","text":"Type Name dir hesai dir robosense dir velodyne <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/</code></p>"},{"location":"nebula_common/nebula__common_8hpp/","title":"File nebula_common.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; nebula_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;nebula_common/point_types.hpp&gt;</code></li> <li><code>#include &lt;boost/tokenizer.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_common/nebula__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/nebula__common_8hpp/#classes","title":"Classes","text":"Type Name struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) struct PointField not used? struct SensorConfigurationBase Base struct for Sensor configuration. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/nebula__common_8hpp_source/","title":"File nebula_common.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; nebula_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_COMMON_H\n#define NEBULA_COMMON_H\n\n#include &lt;nebula_common/point_types.hpp&gt;\n#include &lt;boost/tokenizer.hpp&gt;\n#include &lt;map&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nenum class CoordinateMode { UNKNOWN = 0, CARTESIAN, SPHERICAL, CYLINDRICAL };\n\nenum class ReturnType : uint8_t {\n  UNKNOWN = 0,\n  LAST,\n  FIRST,\n  STRONGEST,\n  FIRST_WEAK,\n  LAST_WEAK,\n  IDENTICAL,\n  SECOND,\n  SECONDSTRONGEST,\n  FIRST_STRONGEST,\n  LAST_STRONGEST\n};\n\nenum class ReturnMode : uint8_t {\n  UNKNOWN = 0,\n  SINGLE_STRONGEST,\n  SINGLE_LAST,\n  DUAL_FIRST,\n  DUAL_LAST,\n  DUAL_ONLY,\n  SINGLE_FIRST,\n  DUAL_STRONGEST_FIRST,\n  DUAL_STRONGEST_LAST,\n  DUAL_WEAK_FIRST,\n  DUAL_WEAK_LAST,\n  TRIPLE,\n  LAST,\n  STRONGEST,\n  DUAL_LAST_STRONGEST,\n  FIRST,\n  DUAL_LAST_FIRST,\n  DUAL_FIRST_STRONGEST,\n  DUAL\n};\n\ninline ReturnType ReturnModeToReturnType(const ReturnMode &amp; mode)\n{\n  switch (mode) {\n    case ReturnMode::SINGLE_STRONGEST:\n      return ReturnType::STRONGEST;\n      break;\n    case ReturnMode::SINGLE_LAST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::DUAL_FIRST:\n      return ReturnType::FIRST;\n      break;\n    case ReturnMode::DUAL_LAST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::DUAL_ONLY:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::SINGLE_FIRST:\n      return ReturnType::FIRST;\n      break;\n    case ReturnMode::DUAL_STRONGEST_FIRST:\n      return ReturnType::FIRST;\n      break;\n    case ReturnMode::DUAL_STRONGEST_LAST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::DUAL_WEAK_FIRST:\n      return ReturnType::FIRST_WEAK;\n      break;\n    case ReturnMode::DUAL_WEAK_LAST:\n      return ReturnType::LAST_WEAK;\n      break;\n    case ReturnMode::TRIPLE:\n      return ReturnType::STRONGEST;\n      break;\n    // for Hesai\n    case ReturnMode::LAST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::STRONGEST:\n      return ReturnType::STRONGEST;\n      break;\n    case ReturnMode::DUAL_LAST_STRONGEST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::FIRST:\n      return ReturnType::FIRST;\n      break;\n    case ReturnMode::DUAL_LAST_FIRST:\n      return ReturnType::LAST;\n      break;\n    case ReturnMode::DUAL_FIRST_STRONGEST:\n      return ReturnType::FIRST;\n      break;\n    case ReturnMode::DUAL:\n      return ReturnType::LAST;\n      break;\n    default:\n    case ReturnMode::UNKNOWN:\n      return ReturnType::UNKNOWN;\n      break;\n  }\n}\n\ninline uint8_t ReturnModeToInt(const ReturnMode &amp; mode)\n{\n  switch (mode) {\n    case ReturnMode::SINGLE_STRONGEST:\n      return 1;\n      break;\n    case ReturnMode::SINGLE_LAST:\n      return 2;\n      break;\n    case ReturnMode::DUAL_FIRST:\n      return 3;\n      break;\n    case ReturnMode::DUAL_LAST:\n      return 4;\n      break;\n    case ReturnMode::DUAL_ONLY:\n      return 5;\n      break;\n    case ReturnMode::SINGLE_FIRST:\n      return 6;\n      break;\n    case ReturnMode::DUAL_STRONGEST_FIRST:\n      return 7;\n      break;\n    case ReturnMode::DUAL_STRONGEST_LAST:\n      return 8;\n      break;\n    case ReturnMode::DUAL_WEAK_FIRST:\n      return 9;\n      break;\n    case ReturnMode::DUAL_WEAK_LAST:\n      return 10;\n      break;\n    case ReturnMode::TRIPLE:\n      return 11;\n      break;\n    // for Hesai\n    case ReturnMode::LAST:\n      return 12;\n      break;\n    case ReturnMode::STRONGEST:\n      return 13;\n      break;\n    case ReturnMode::DUAL_LAST_STRONGEST:\n      return 14;\n      break;\n    case ReturnMode::FIRST:\n      return 15;\n      break;\n    case ReturnMode::DUAL_LAST_FIRST:\n      return 16;\n      break;\n    case ReturnMode::DUAL_FIRST_STRONGEST:\n      return 17;\n      break;\n    case ReturnMode::DUAL:\n      return 18;\n      break;\n    default:\n    case ReturnMode::UNKNOWN:\n      return 0;\n      break;\n  }\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::ReturnType const &amp; arg)\n{\n  switch (arg) {\n    case ReturnType::UNKNOWN:\n      os &lt;&lt; \"Unknown\";\n      break;\n    case ReturnType::LAST:\n      os &lt;&lt; \"Last\";\n      break;\n    case ReturnType::FIRST:\n      os &lt;&lt; \"First\";\n      break;\n    case ReturnType::STRONGEST:\n      os &lt;&lt; \"Strongest\";\n      break;\n    case ReturnType::FIRST_WEAK:\n      os &lt;&lt; \"FirstWeak\";\n      break;\n    case ReturnType::LAST_WEAK:\n      os &lt;&lt; \"LastWeak\";\n      break;\n    case ReturnType::IDENTICAL:\n      os &lt;&lt; \"Identical\";\n      break;\n    case ReturnType::SECOND:\n      os &lt;&lt; \"Second\";\n      break;\n    case ReturnType::SECONDSTRONGEST:\n      os &lt;&lt; \"SecondStrongest\";\n      break;\n    case ReturnType::FIRST_STRONGEST:\n      os &lt;&lt; \"FirstStrongest\";\n      break;\n    case ReturnType::LAST_STRONGEST:\n      os &lt;&lt; \"LastStrongest\";\n      break;\n  }\n  return os;\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::ReturnMode const &amp; arg)\n{\n  switch (arg) {\n    case ReturnMode::SINGLE_FIRST:\n      os &lt;&lt; \"SingleFirst\";\n      break;\n    case ReturnMode::SINGLE_STRONGEST:\n      os &lt;&lt; \"SingleStrongest\";\n      break;\n    case ReturnMode::SINGLE_LAST:\n      os &lt;&lt; \"SingleLast\";\n      break;\n    case ReturnMode::DUAL_ONLY:\n      os &lt;&lt; \"Dual\";\n      break;\n    case ReturnMode::DUAL_FIRST:\n      os &lt;&lt; \"DualFirst\";\n      break;\n    case ReturnMode::DUAL_LAST:\n      os &lt;&lt; \"DualLast\";\n      break;\n    case ReturnMode::DUAL_WEAK_FIRST:\n      os &lt;&lt; \"WeakFirst\";\n      break;\n    case ReturnMode::DUAL_WEAK_LAST:\n      os &lt;&lt; \"WeakLast\";\n      break;\n    case ReturnMode::DUAL_STRONGEST_LAST:\n      os &lt;&lt; \"StrongLast\";\n      break;\n    case ReturnMode::DUAL_STRONGEST_FIRST:\n      os &lt;&lt; \"StrongFirst\";\n      break;\n    case ReturnMode::TRIPLE:\n      os &lt;&lt; \"Triple\";\n      break;\n    // for Hesai\n    case ReturnMode::LAST:\n      os &lt;&lt; \"Last\";\n      break;\n    case ReturnMode::STRONGEST:\n      os &lt;&lt; \"Strongest\";\n      break;\n    case ReturnMode::DUAL_LAST_STRONGEST:\n      os &lt;&lt; \"LastStrongest\";\n      break;\n    case ReturnMode::FIRST:\n      os &lt;&lt; \"First\";\n      break;\n    case ReturnMode::DUAL_LAST_FIRST:\n      os &lt;&lt; \"LastFirst\";\n      break;\n    case ReturnMode::DUAL_FIRST_STRONGEST:\n      os &lt;&lt; \"FirstStrongest\";\n      break;\n    case ReturnMode::DUAL:\n      os &lt;&lt; \"Dual\";\n      break;\n    case ReturnMode::UNKNOWN:\n      os &lt;&lt; \"Unknown\";\n      break;\n  }\n  return os;\n}\n\n// SENSOR_CONFIGURATION\n\nenum class SensorModel {\n  UNKNOWN = 0,\n  HESAI_PANDAR64,\n  HESAI_PANDAR40P,\n  HESAI_PANDAR40M,\n  HESAI_PANDARQT64,\n  HESAI_PANDARQT128,\n  HESAI_PANDARXT32,\n  HESAI_PANDARXT32M,\n  HESAI_PANDARAT128,\n  HESAI_PANDAR128_E3X,\n  HESAI_PANDAR128_E4X,\n  VELODYNE_VLS128,\n  VELODYNE_HDL64,\n  VELODYNE_VLP32,\n  VELODYNE_VLP32MR,\n  VELODYNE_HDL32,\n  VELODYNE_VLP16,\n  ROBOSENSE_HELIOS,\n  ROBOSENSE_BPEARL,\n  ROBOSENSE_BPEARL_V3,\n  ROBOSENSE_BPEARL_V4,\n};\n\nenum class datatype {\n  INT8 = 1,\n  UINT8 = 2,\n  INT16 = 3,\n  UINT16 = 4,\n  INT32 = 5,\n  UINT32 = 6,\n  FLOAT32 = 7,\n  FLOAT64 = 8\n};\n\nenum class PtpProfile {\n  IEEE_1588v2 = 0,\n  IEEE_802_1AS,\n  IEEE_802_1AS_AUTO,\n  PROFILE_UNKNOWN\n};\n\nenum class PtpTransportType {\n  UDP_IP = 0,\n  L2,\n  UNKNOWN_TRANSPORT\n};\n\nstruct PointField\n{\n  std::string name;\n  uint32_t offset;\n  uint8_t datatype;\n  uint32_t count;\n};\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::SensorModel const &amp; arg)\n{\n  switch (arg) {\n    case SensorModel::HESAI_PANDAR64:\n      os &lt;&lt; \"Pandar64\";\n      break;\n    case SensorModel::HESAI_PANDAR40P:\n      os &lt;&lt; \"Pandar40P\";\n      break;\n    case SensorModel::HESAI_PANDAR40M:\n      os &lt;&lt; \"Pandar40M\";\n      break;\n    case SensorModel::HESAI_PANDARQT64:\n      os &lt;&lt; \"PandarQT64\";\n      break;\n    case SensorModel::HESAI_PANDARQT128:\n      os &lt;&lt; \"PandarQT128\";\n      break;\n    case SensorModel::HESAI_PANDARXT32:\n      os &lt;&lt; \"PandarXT32\";\n      break;\n    case SensorModel::HESAI_PANDARXT32M:\n      os &lt;&lt; \"PandarXT32M\";\n      break;\n    case SensorModel::HESAI_PANDARAT128:\n      os &lt;&lt; \"PandarAT128\";\n      break;\n    case SensorModel::HESAI_PANDAR128_E3X:\n      os &lt;&lt; \"Pandar128_E3X\";\n      break;\n    case SensorModel::HESAI_PANDAR128_E4X:\n      os &lt;&lt; \"Pandar128_E4X_OT\";\n      break;\n    case SensorModel::VELODYNE_VLS128:\n      os &lt;&lt; \"VLS128\";\n      break;\n    case SensorModel::VELODYNE_HDL64:\n      os &lt;&lt; \"HDL64\";\n      break;\n    case SensorModel::VELODYNE_VLP32:\n      os &lt;&lt; \"VLP32\";\n      break;\n    case SensorModel::VELODYNE_VLP32MR:\n      os &lt;&lt; \"VLP32MR\";\n      break;\n    case SensorModel::VELODYNE_HDL32:\n      os &lt;&lt; \"HDL32\";\n      break;\n    case SensorModel::VELODYNE_VLP16:\n      os &lt;&lt; \"VLP16\";\n      break;\n    case SensorModel::ROBOSENSE_HELIOS:\n      os &lt;&lt; \"HELIOS\";\n      break;\n    case SensorModel::ROBOSENSE_BPEARL:\n      os &lt;&lt; \"BPEARL\";\n      break;\n    case SensorModel::ROBOSENSE_BPEARL_V3:\n      os &lt;&lt; \"BPEARL V3.0\";\n      break;\n    case SensorModel::ROBOSENSE_BPEARL_V4:\n      os &lt;&lt; \"BPEARL V4.0\";\n      break;\n    case SensorModel::UNKNOWN:\n      os &lt;&lt; \"Sensor Unknown\";\n      break;\n  }\n  return os;\n}\n\nstruct SensorConfigurationBase\n{\n  SensorModel sensor_model;\n  ReturnMode return_mode;\n  std::string host_ip;\n  std::string sensor_ip;\n  std::string frame_id;\n  uint16_t data_port;\n  uint16_t frequency_ms;\n  uint16_t packet_mtu_size;\n  CoordinateMode coordinate_mode;\n  double min_range;\n  double max_range;\n  bool remove_nans;  \n  std::vector&lt;PointField&gt; fields;\n  bool use_sensor_time{false};\n};\n\ninline std::ostream &amp; operator&lt;&lt;(\n  std::ostream &amp; os, nebula::drivers::SensorConfigurationBase const &amp; arg)\n{\n  os &lt;&lt; \"SensorModel: \" &lt;&lt; arg.sensor_model &lt;&lt; \", ReturnMode: \" &lt;&lt; arg.return_mode\n     &lt;&lt; \", HostIP: \" &lt;&lt; arg.host_ip &lt;&lt; \", SensorIP: \" &lt;&lt; arg.sensor_ip\n     &lt;&lt; \", FrameID: \" &lt;&lt; arg.frame_id &lt;&lt; \", DataPort: \" &lt;&lt; arg.data_port\n     &lt;&lt; \", Frequency: \" &lt;&lt; arg.frequency_ms &lt;&lt; \", MTU: \" &lt;&lt; arg.packet_mtu_size\n     &lt;&lt; \", Use sensor time: \" &lt;&lt; arg.use_sensor_time;\n  return os;\n}\n\nstruct CalibrationConfigurationBase\n{\n  std::string calibration_file;\n};\n\ninline SensorModel SensorModelFromString(const std::string &amp; sensor_model)\n{\n  // Hesai\n  if (sensor_model == \"Pandar64\") return SensorModel::HESAI_PANDAR64;\n  if (sensor_model == \"Pandar40P\") return SensorModel::HESAI_PANDAR40P;\n  if (sensor_model == \"Pandar40M\") return SensorModel::HESAI_PANDAR40M;\n  if (sensor_model == \"PandarXT32\") return SensorModel::HESAI_PANDARXT32;\n  if (sensor_model == \"PandarXT32M\") return SensorModel::HESAI_PANDARXT32M;\n  if (sensor_model == \"PandarAT128\") return SensorModel::HESAI_PANDARAT128;\n  if (sensor_model == \"PandarQT64\") return SensorModel::HESAI_PANDARQT64;\n  if (sensor_model == \"PandarQT128\") return SensorModel::HESAI_PANDARQT128;\n  if (sensor_model == \"Pandar128E4X\") return SensorModel::HESAI_PANDAR128_E4X;\n  // Velodyne\n  if (sensor_model == \"VLS128\") return SensorModel::VELODYNE_VLS128;\n  if (sensor_model == \"HDL64\") return SensorModel::VELODYNE_HDL64;\n  if (sensor_model == \"VLP32\") return SensorModel::VELODYNE_VLP32;\n  if (sensor_model == \"VLP32MR\") return SensorModel::VELODYNE_VLP32MR;\n  if (sensor_model == \"HDL32\") return SensorModel::VELODYNE_HDL32;\n  if (sensor_model == \"VLP16\") return SensorModel::VELODYNE_VLP16;\n  // Robosense\n  if (sensor_model == \"Helios\") return SensorModel::ROBOSENSE_HELIOS;\n  if (sensor_model == \"Bpearl\") return SensorModel::ROBOSENSE_BPEARL;\n  if (sensor_model == \"Bpearl_V3\") return SensorModel::ROBOSENSE_BPEARL_V3;\n  if (sensor_model == \"Bpearl_V4\") return SensorModel::ROBOSENSE_BPEARL_V4;\n  return SensorModel::UNKNOWN;\n}\n\ninline std::string SensorModelToString(const SensorModel &amp; sensor_model)\n{\n  switch (sensor_model) {\n    // Hesai\n    case SensorModel::HESAI_PANDAR64:\n      return \"Pandar64\";\n    case SensorModel::HESAI_PANDAR40P:\n      return \"Pandar40P\";\n    case SensorModel::HESAI_PANDAR40M:\n      return \"Pandar40M\";\n    case SensorModel::HESAI_PANDARXT32:\n      return \"PandarXT32\";\n    case SensorModel::HESAI_PANDARXT32M:\n      return \"PandarXT32M\";\n    case SensorModel::HESAI_PANDARAT128:\n      return \"PandarAT128\";\n    case SensorModel::HESAI_PANDARQT64:\n      return \"PandarQT64\";\n    case SensorModel::HESAI_PANDARQT128:\n      return \"PandarQT128\";\n    case SensorModel::HESAI_PANDAR128_E4X:\n      return \"Pandar128E4X\";\n    // Velodyne\n    case SensorModel::VELODYNE_VLS128:\n      return \"VLS128\";\n    case SensorModel::VELODYNE_HDL64:\n      return \"HDL64\";\n    case SensorModel::VELODYNE_VLP32:\n      return \"VLP32\";\n    case SensorModel::VELODYNE_VLP32MR:\n      return \"VLP32MR\";\n    case SensorModel::VELODYNE_HDL32:\n      return \"HDL32\";\n    case SensorModel::VELODYNE_VLP16:\n      return \"VLP16\";\n    // Robosense\n    case SensorModel::ROBOSENSE_HELIOS:\n      return \"Helios\";\n    case SensorModel::ROBOSENSE_BPEARL:\n      return \"Bpearl\";\n    case SensorModel::ROBOSENSE_BPEARL_V3:\n      return \"Bpearl_V3\";\n    case SensorModel::ROBOSENSE_BPEARL_V4:\n      return \"Bpearl_V4\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\n\ninline ReturnMode ReturnModeFromString(const std::string &amp; return_mode)\n{\n  if (return_mode == \"SingleFirst\") return ReturnMode::SINGLE_FIRST;\n  if (return_mode == \"SingleStrongest\") return ReturnMode::SINGLE_STRONGEST;\n  if (return_mode == \"SingleLast\") return ReturnMode::SINGLE_LAST;\n  if (return_mode == \"Dual\") return ReturnMode::DUAL_ONLY;\n\n  return ReturnMode::UNKNOWN;\n}\n\ninline PtpProfile PtpProfileFromString(const std::string &amp; ptp_profile)\n{\n  // Hesai\n  auto tmp_str = ptp_profile;\n  std::transform(tmp_str.begin(), tmp_str.end(), tmp_str.begin(),\n                 [](unsigned char c){ return std::tolower(c); });\n  if (tmp_str == \"1588v2\") return PtpProfile::IEEE_1588v2;\n  if (tmp_str == \"802.1as\") return PtpProfile::IEEE_802_1AS;\n  if (tmp_str == \"automotive\") return PtpProfile::IEEE_802_1AS_AUTO;\n\n  return PtpProfile::PROFILE_UNKNOWN;\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::PtpProfile const &amp; arg)\n{\n  switch (arg) {\n    case PtpProfile::IEEE_1588v2:\n      os &lt;&lt; \"IEEE_1588v2\";\n      break;\n    case PtpProfile::IEEE_802_1AS:\n      os &lt;&lt; \"IEEE_802.1AS\";\n      break;\n    case PtpProfile::IEEE_802_1AS_AUTO:\n      os &lt;&lt; \"IEEE_802.1AS Automotive\";\n      break;\n    case PtpProfile::PROFILE_UNKNOWN:\n      os &lt;&lt; \"UNKNOWN\";\n      break;\n  }\n  return os;\n}\n\ninline PtpTransportType PtpTransportTypeFromString(const std::string &amp; transport_type)\n{\n  // Hesai\n  auto tmp_str = transport_type;\n  std::transform(tmp_str.begin(), tmp_str.end(), tmp_str.begin(),\n                 [](unsigned char c){ return std::tolower(c); });\n  if (tmp_str == \"udp\") return PtpTransportType::UDP_IP;\n  if (tmp_str == \"l2\") return PtpTransportType::L2;\n\n  return PtpTransportType::UNKNOWN_TRANSPORT;\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::PtpTransportType const &amp; arg)\n{\n  switch (arg) {\n    case PtpTransportType::UDP_IP:\n      os &lt;&lt; \"UDP/IP\";\n      break;\n    case PtpTransportType::L2:\n      os &lt;&lt; \"L2\";\n      break;\n    case PtpTransportType::UNKNOWN_TRANSPORT:\n      os &lt;&lt; \"UNKNOWN\";\n      break;\n  }\n  return os;\n}\n\n[[maybe_unused]] pcl::PointCloud&lt;PointXYZIR&gt;::Ptr convertPointXYZIRADTToPointXYZIR(\n  const pcl::PointCloud&lt;PointXYZIRADT&gt;::ConstPtr &amp; input_pointcloud);\n\n[[maybe_unused]] pcl::PointCloud&lt;PointXYZIR&gt;::Ptr convertPointXYZIRCAEDTToPointXYZIR(\n  const pcl::PointCloud&lt;PointXYZIRCAEDT&gt;::ConstPtr &amp; input_pointcloud);\n\npcl::PointCloud&lt;PointXYZIRADT&gt;::Ptr convertPointXYZIRCAEDTToPointXYZIRADT(\n  const pcl::PointCloud&lt;PointXYZIRCAEDT&gt;::ConstPtr &amp; input_pointcloud, double stamp);\n\nstatic inline float deg2rad(double degrees)\n{\n  return degrees * M_PI / 180.0;\n}\n\nstatic inline float rad2deg(double radians)\n{\n  return radians * 180.0 / M_PI;\n}\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_CONFIGURATION_BASE_H\n</code></pre>"},{"location":"nebula_common/dir_618777836fb6f6d5617fcbcab933ec7b/","title":"Dir nebula_common/include/nebula_common/hesai","text":"<p>FileList &gt; hesai</p>"},{"location":"nebula_common/dir_618777836fb6f6d5617fcbcab933ec7b/#files","title":"Files","text":"Type Name file hesai_common.hpp file hesai_status.hpp <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/</code></p>"},{"location":"nebula_common/hesai__common_8hpp/","title":"File hesai_common.hpp","text":"<p>FileList &gt; hesai &gt; hesai_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"nebula_common/hesai__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/hesai__common_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiCalibrationConfiguration struct for Hesai calibration configuration struct HesaiCorrection struct for Hesai correction configuration (for AT) struct HesaiSensorConfiguration struct for Hesai sensor configuration <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/hesai__common_8hpp_source/","title":"File hesai_common.hpp","text":"<p>File List &gt; hesai &gt; hesai_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_COMMON_H\n#define NEBULA_HESAI_COMMON_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\nnamespace nebula\n{\nnamespace drivers\n{\nstruct HesaiSensorConfiguration : SensorConfigurationBase\n{\n  uint16_t gnss_port{};\n  double scan_phase{};\n  double dual_return_distance_threshold{};\n  uint16_t rotation_speed;\n  uint16_t cloud_min_angle;\n  uint16_t cloud_max_angle;\n  PtpProfile ptp_profile;\n  uint8_t ptp_domain;\n  PtpTransportType ptp_transport_type;\n};\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, HesaiSensorConfiguration const &amp; arg)\n{\n  os &lt;&lt; (SensorConfigurationBase)(arg) &lt;&lt; \", GnssPort: \" &lt;&lt; arg.gnss_port\n     &lt;&lt; \", ScanPhase:\" &lt;&lt; arg.scan_phase &lt;&lt; \", RotationSpeed:\" &lt;&lt; arg.rotation_speed\n     &lt;&lt; \", FOV(Start):\" &lt;&lt; arg.cloud_min_angle &lt;&lt; \", FOV(End):\" &lt;&lt; arg.cloud_max_angle\n     &lt;&lt; \", DualReturnDistanceThreshold:\" &lt;&lt; arg.dual_return_distance_threshold\n     &lt;&lt; \", PtpProfile:\" &lt;&lt; arg.ptp_profile &lt;&lt; \", PtpDomain:\" &lt;&lt; std::to_string(arg.ptp_domain)\n     &lt;&lt; \", PtpTransportType:\" &lt;&lt; arg.ptp_transport_type;\n  return os;\n}\n\nstruct HesaiCalibrationConfiguration : CalibrationConfigurationBase\n{\n  std::map&lt;size_t, float&gt; elev_angle_map;\n  std::map&lt;size_t, float&gt; azimuth_offset_map;\n\n  inline nebula::Status LoadFromFile(const std::string &amp; calibration_file)\n  {\n    std::ifstream ifs(calibration_file);\n    if (!ifs) {\n      return Status::INVALID_CALIBRATION_FILE;\n    }\n    std::ostringstream ss;\n    ss &lt;&lt; ifs.rdbuf(); // reading data\n    ifs.close();\n    return LoadFromString(ss.str());\n  }\n\n  inline nebula::Status LoadFromString(const std::string &amp; calibration_content)\n  {\n    std::stringstream ss;\n    ss &lt;&lt; calibration_content;\n    std::string line;\n    constexpr size_t expected_cols = 3;\n    while(std::getline(ss, line)) {\n      boost::char_separator&lt;char&gt; sep(\",\");\n      boost::tokenizer&lt;boost::char_separator&lt;char&gt;&gt; tok(line, sep);\n\n      std::vector&lt;std::string&gt; actual_tokens(tok.begin(), tok.end());\n      if (actual_tokens.size() &lt; expected_cols\n        || actual_tokens.size() &gt; expected_cols\n        ) {\n        std::cerr &lt;&lt; \"Ignoring line with unexpected data:\" &lt;&lt; line &lt;&lt; std::endl;\n        continue;\n      }\n\n      try {\n        int laser_id = std::stoi(actual_tokens[0]);\n        float elevation = std::stof(actual_tokens[1]);\n        float azimuth = std::stof(actual_tokens[2]);\n        elev_angle_map[laser_id - 1] = elevation;\n        azimuth_offset_map[laser_id - 1] = azimuth;\n      } catch (const std::invalid_argument&amp; ia) {\n        continue;\n      }\n\n    }\n    return Status::OK;\n  }\n\n  inline nebula::Status SaveFile(const std::string &amp; calibration_file)\n  {\n    std::ofstream ofs(calibration_file);\n    if (!ofs) {\n      return Status::CANNOT_SAVE_FILE;\n    }\n    ofs &lt;&lt; \"Laser id,Elevation,Azimuth\" &lt;&lt; std::endl;\n    for (const auto &amp; pair : elev_angle_map) {\n      auto laser_id = pair.first + 1;\n      float elevation = pair.second;\n      float azimuth = azimuth_offset_map[pair.first];\n      ofs &lt;&lt; laser_id &lt;&lt; \",\" &lt;&lt; elevation &lt;&lt; \",\" &lt;&lt; azimuth &lt;&lt; std::endl;\n    }\n    ofs.close();\n\n    return Status::OK;\n  }\n\n  inline nebula::Status SaveFileFromString(const std::string &amp; calibration_file, const std::string &amp; calibration_string)\n  {\n    std::ofstream ofs(calibration_file);\n    if (!ofs) {\n      return Status::CANNOT_SAVE_FILE;\n    }\n    ofs &lt;&lt; calibration_string;\n    ofs.close();\n    return Status::OK;\n  }\n};\n\nstruct HesaiCorrection\n{\n  uint16_t delimiter;\n  uint8_t versionMajor;\n  uint8_t versionMinor;\n  uint8_t channelNumber;\n  uint8_t mirrorNumber;\n  uint8_t frameNumber;\n  uint8_t frameConfig[8];\n  uint8_t resolution;\n\n  uint32_t startFrame[8];\n  uint32_t endFrame[8];\n  int32_t azimuth[128];\n  int32_t elevation[128];\n  int8_t azimuthOffset[36000];\n  int8_t elevationOffset[36000];\n  uint8_t SHA256[32];\n\n  inline nebula::Status LoadFromBinary(const std::vector&lt;uint8_t&gt; &amp; buf)\n  {\n    size_t index;\n    for (index = 0; index &lt; buf.size()-1; index++) {\n      if(buf[index]==0xee &amp;&amp; buf[index+1]==0xff)\n        break;\n    }\n    delimiter = (buf[index] &amp; 0xff) &lt;&lt; 8 | ((buf[index + 1] &amp; 0xff));\n    versionMajor = buf[index + 2] &amp; 0xff;\n    versionMinor = buf[index + 3] &amp; 0xff;\n    channelNumber = buf[index + 4] &amp; 0xff;\n    mirrorNumber = buf[index + 5] &amp; 0xff;\n    frameNumber = buf[index + 6] &amp; 0xff;\n    index += 7;\n    for (uint8_t i = 0; i &lt; 8; i++) {\n      frameConfig[i] = buf[index] &amp; 0xff;\n      index++;\n    }\n    resolution = buf[index] &amp; 0xff;\n    index++;\n    switch (versionMinor) {\n      case 5:\n        for (uint8_t i = 0; i &lt; mirrorNumber; i++) {\n          startFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n                          ((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\n          index += 4;\n        }\n        for (uint8_t i = 0; i &lt; mirrorNumber; i++) {\n          endFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n                        ((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\n          index += 4;\n        }\n        for (uint8_t i = 0; i &lt; channelNumber; i++) {\n          azimuth[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n                       ((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\n          index += 4;\n        }\n        for (uint8_t i = 0; i &lt; channelNumber; i++) {\n          elevation[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n                         ((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\n          index += 4;\n        }\n        for (int i = 0; i &lt; channelNumber * 180; i++) {\n          azimuthOffset[i] = buf[index] &amp; 0xff;\n          index++;\n        }\n        for (int i = 0; i &lt; channelNumber * 180; i++) {\n          elevationOffset[i] = buf[index] &amp; 0xff;\n          index++;\n        }\n\n        for (uint8_t i = 0; i &lt; mirrorNumber; i++) {\n          startFrame[i] *= resolution;\n          endFrame[i] *= resolution;\n        }\n        for (uint8_t i = 0; i &lt; channelNumber; i++) {\n          azimuth[i] *= resolution;\n          elevation[i] *= resolution;\n        }\n        for (int i = 0; i &lt; channelNumber * 180; i++) {\n          azimuthOffset[i] *= resolution;\n          elevationOffset[i] *= resolution;\n        }\n        break;\n\n      case 3:  // not worked...\n        for (uint8_t i = 0; i &lt; mirrorNumber; i++) {\n          startFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\n          index += 2;\n        }\n        for (uint8_t i = 0; i &lt; mirrorNumber; i++) {\n          endFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\n          index += 2;\n        }\n        for (uint8_t i = 0; i &lt; channelNumber; i++) {\n          azimuth[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\n          index += 2;\n        }\n        for (uint8_t i = 0; i &lt; channelNumber; i++) {\n          elevation[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\n          index += 2;\n        }\n        for (int i = 0; i &lt; 36000; i++) {\n          azimuthOffset[i] = buf[index] &amp; 0xff;\n          index++;\n        }\n        for (int i = 0; i &lt; 36000; i++) {\n          elevationOffset[i] = buf[index] &amp; 0xff;\n          index++;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n    return Status::OK;\n  }\n\n  inline nebula::Status LoadFromFile(const std::string &amp; correction_file)\n  {\n    std::ifstream ifs(correction_file, std::ios::in | std::ios::binary);\n    if (!ifs) {\n      return Status::INVALID_CALIBRATION_FILE;\n    }\n    std::vector&lt;unsigned char&gt; buf;\n    //    int cnt = 0;\n    while (!ifs.eof()) {\n      unsigned char c;\n      ifs.read((char *)&amp;c, sizeof(unsigned char));\n      buf.emplace_back(c);\n    }\n    LoadFromBinary(buf);\n\n    ifs.close();\n    return Status::OK;\n  }\n\n  inline nebula::Status SaveFileFromBinary(const std::string &amp; correction_file, const std::vector&lt;uint8_t&gt; &amp; buf)\n  {\n    std::cerr &lt;&lt; \"Saving in:\" &lt;&lt; correction_file &lt;&lt; \"\\n\";\n    std::ofstream ofs(correction_file, std::ios::trunc | std::ios::binary);\n    if (!ofs) {\n      std::cerr &lt;&lt; \"Could not create file:\" &lt;&lt; correction_file &lt;&lt; \"\\n\";\n      return Status::CANNOT_SAVE_FILE;\n    }\n    std::cerr &lt;&lt; \"Writing start....\" &lt;&lt; buf.size() &lt;&lt; \"\\n\";\n    bool sop_received = false;\n    for (const auto &amp;byte : buf) {\n      if (!sop_received) {\n        if (byte == 0xEE) {\n          std::cerr &lt;&lt; \"SOP received....\\n\";\n          sop_received = true;\n        }\n      }\n      if(sop_received) {\n        ofs &lt;&lt; byte;\n      }\n    }\n    std::cerr &lt;&lt; \"Closing file\\n\";\n    ofs.close();\n    if(sop_received)\n      return Status::OK;\n    return Status::INVALID_CALIBRATION_FILE;\n  }\n\n  static const int STEP3 = 200 * 256;\n\n  int8_t getAzimuthAdjustV3(uint8_t ch, uint32_t azi) const\n  {\n    unsigned int i = std::floor(1.f * azi / STEP3);\n    unsigned int l = azi - i * STEP3;\n    float k = 1.f * l / STEP3;\n    return round((1 - k) * azimuthOffset[ch * 180 + i] + k * azimuthOffset[ch * 180 + i + 1]);\n  }\n\n  int8_t getElevationAdjustV3(uint8_t ch, uint32_t azi) const\n  {\n    unsigned int i = std::floor(1.f * azi / STEP3);\n    unsigned int l = azi - i * STEP3;\n    float k = 1.f * l / STEP3;\n    return round((1 - k) * elevationOffset[ch * 180 + i] + k * elevationOffset[ch * 180 + i + 1]);\n  }\n};\n\n/*\n&lt;option value=\"0\"&gt;Last Return&lt;/option&gt;\n&lt;option value=\"1\"&gt;Strongest Return&lt;/option&gt;\n&lt;option value=\"3\"&gt;First Return&lt;/option&gt;\n&lt;option value=\"2\"&gt;Last Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"4\"&gt;First Return + Last Return&lt;/option&gt;\n&lt;option value=\"5\"&gt;First Return + Strongest Return&lt;/option&gt;\n*/\n/*\n&lt;option value=\"0\"&gt;Last Return&lt;/option&gt;\n&lt;option value=\"1\"&gt;Strongest Return&lt;/option&gt;\n&lt;option value=\"3\"&gt;First Return&lt;/option&gt;\n&lt;option value=\"2\"&gt;Last Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"4\"&gt;First Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"5\"&gt;First Return + Last Return&lt;/option&gt;\n&lt;option value=\"6\"&gt;First Return + Last Return + Strongest Return&lt;/option&gt;\n*/\n\ninline ReturnMode ReturnModeFromStringHesai(\n  const std::string &amp; return_mode, const SensorModel &amp; sensor_model)\n{\n  switch (sensor_model) {\n    case SensorModel::HESAI_PANDARXT32M:\n    case SensorModel::HESAI_PANDARAT128:\n    case SensorModel::HESAI_PANDAR128_E4X:\n    case SensorModel::HESAI_PANDARQT128:\n      if (return_mode == \"Last\") return ReturnMode::LAST;\n      if (return_mode == \"Strongest\") return ReturnMode::STRONGEST;\n      if (return_mode == \"LastStrongest\") return ReturnMode::DUAL_LAST_STRONGEST;\n      if (return_mode == \"First\") return ReturnMode::FIRST;\n      if (return_mode == \"LastFirst\") return ReturnMode::DUAL_LAST_FIRST;\n      if (return_mode == \"FirstStrongest\") return ReturnMode::DUAL_FIRST_STRONGEST;\n      if (return_mode == \"Dual\") return ReturnMode::DUAL;\n      break;\n    case SensorModel::HESAI_PANDARQT64:\n      if (return_mode == \"Last\") return ReturnMode::LAST;\n      if (return_mode == \"Dual\") return ReturnMode::DUAL;\n      if (return_mode == \"First\") return ReturnMode::FIRST;\n      break;\n    default:\n      if (return_mode == \"Last\") return ReturnMode::LAST;\n      if (return_mode == \"Strongest\") return ReturnMode::STRONGEST;\n      if (return_mode == \"Dual\") return ReturnMode::DUAL;\n      break;\n  }\n\n  return ReturnMode::UNKNOWN;\n}\n\ninline ReturnMode ReturnModeFromIntHesai(const int return_mode, const SensorModel &amp; sensor_model)\n{\n  switch (sensor_model) {\n    case SensorModel::HESAI_PANDARXT32M:\n    case SensorModel::HESAI_PANDARAT128:\n    case SensorModel::HESAI_PANDAR128_E4X:\n    case SensorModel::HESAI_PANDARQT128:\n      if (return_mode == 0) return ReturnMode::LAST;\n      if (return_mode == 1) return ReturnMode::STRONGEST;\n      if (return_mode == 2) return ReturnMode::DUAL_LAST_STRONGEST;\n      if (return_mode == 3) return ReturnMode::FIRST;\n      if (return_mode == 4) return ReturnMode::DUAL_LAST_FIRST;\n      if (return_mode == 5) return ReturnMode::DUAL_FIRST_STRONGEST;\n      break;\n    case SensorModel::HESAI_PANDARQT64:\n      if (return_mode == 0) return ReturnMode::LAST;\n      if (return_mode == 2) return ReturnMode::DUAL;\n      if (return_mode == 3) return ReturnMode::FIRST;\n      break;\n    default:\n      if (return_mode == 0) return ReturnMode::LAST;\n      if (return_mode == 1) return ReturnMode::STRONGEST;\n      if (return_mode == 2) return ReturnMode::DUAL;\n      break;\n  }\n\n  return ReturnMode::UNKNOWN;\n}\n\ninline int IntFromReturnModeHesai(const ReturnMode return_mode, const SensorModel &amp; sensor_model)\n{\n  switch (sensor_model) {\n    case SensorModel::HESAI_PANDARXT32M:\n    case SensorModel::HESAI_PANDARAT128:\n    case SensorModel::HESAI_PANDAR128_E4X:\n    case SensorModel::HESAI_PANDARQT128:\n      if (return_mode == ReturnMode::LAST) return 0;\n      if (return_mode == ReturnMode::STRONGEST) return 1;\n      if (return_mode == ReturnMode::DUAL_LAST_STRONGEST\n      || return_mode == ReturnMode::DUAL) return 2;\n      if (return_mode == ReturnMode::FIRST) return 3;\n      if (return_mode == ReturnMode::DUAL_LAST_FIRST) return 4;\n      if (return_mode == ReturnMode::DUAL_FIRST_STRONGEST) return 5;\n      break;\n    case SensorModel::HESAI_PANDARQT64:\n      if (return_mode == ReturnMode::LAST) return 0;\n      if (return_mode == ReturnMode::DUAL) return 2;\n      if (return_mode == ReturnMode::FIRST) return 3;\n      break;\n    default:\n      if (return_mode == ReturnMode::LAST) return 0;\n      if (return_mode == ReturnMode::STRONGEST) return 1;\n      if (return_mode == ReturnMode::DUAL) return 2;\n      break;\n  }\n\n  return -1;\n}\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_COMMON_H\n</code></pre>"},{"location":"nebula_common/hesai__status_8hpp/","title":"File hesai_status.hpp","text":"<p>FileList &gt; hesai &gt; hesai_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/hesai__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/hesai__status_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiStatus Status definition for Hesai. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_status.hpp</code></p>"},{"location":"nebula_common/hesai__status_8hpp_source/","title":"File hesai_status.hpp","text":"<p>File List &gt; hesai &gt; hesai_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HESAI_STATUS_HPP\n#define HESAI_STATUS_HPP\n\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct HesaiStatus : Status\n{\n  using Status::Status;\n\nprivate:\n  int _type_num;\n\npublic:\n  enum HesaiType {\n    INVALID_RPM_ERROR = Type_end_of_Status + 1,\n    INVALID_FOV_ERROR,\n    INVALID_RETURN_MODE_ERROR,\n    Type_end_of_Status = INVALID_RPM_ERROR\n  } _hesai_type;\n  HesaiStatus() : _type_num(static_cast&lt;int&gt;(Status::OK)) { _type = static_cast&lt;Type&gt;(type()); }\n  HesaiStatus(Type v) : _type_num(static_cast&lt;int&gt;(v)) { _type = v; }\n  HesaiStatus(HesaiType v) : _type_num(static_cast&lt;int&gt;(v)), _hesai_type(v)\n  {\n    _type = Type::Type_end_of_Status;\n  }\n  HesaiStatus(int type) : _type_num(type) {}\n  int type() const { return _type_num; }\n  friend bool operator==(const HesaiStatus &amp; L, const HesaiStatus &amp; R)\n  {\n    return L.type() == R.type();\n  }\n  friend bool operator!=(const HesaiStatus &amp; L, const HesaiStatus &amp; R)\n  {\n    return L.type() != R.type();\n  }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiStatus const &amp; arg)\n  {\n    switch (arg.type()) {\n      // Velodyne\n      case HesaiStatus::INVALID_RPM_ERROR:\n        os &lt;&lt; \"Invalid rotation speed value(range from 300 to 1200, in increments of 60)\";\n        break;\n      case HesaiStatus::INVALID_FOV_ERROR:\n        os &lt;&lt; \"Invalid fov value(0 to 359)\";\n        break;\n      case HesaiStatus::INVALID_RETURN_MODE_ERROR:\n        os &lt;&lt; \"Invalid return mode(only SINGLE_STRONGEST, SINGLE_LAST, DUAL_ONLY)\";\n        break;\n      default:\n        os &lt;&lt; Status(arg._type);\n    }\n    return os;\n  }\n};\n}  // namespace nebula\n#endif  // HESAI_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/dir_91f96517686776969bb22f81ea2cd293/","title":"Dir nebula_common/include/nebula_common/robosense","text":"<p>FileList &gt; include &gt; nebula_common &gt; robosense</p>"},{"location":"nebula_common/dir_91f96517686776969bb22f81ea2cd293/#files","title":"Files","text":"Type Name file robosense_common.hpp <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/robosense/</code></p>"},{"location":"nebula_common/robosense__common_8hpp/","title":"File robosense_common.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; robosense &gt; robosense_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_common/robosense__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/robosense__common_8hpp/#classes","title":"Classes","text":"Type Name struct ChannelCorrection struct RobosenseCalibrationConfiguration struct for Robosense calibration configuration struct RobosenseSensorConfiguration struct for Robosense sensor configuration <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/robosense/robosense_common.hpp</code></p>"},{"location":"nebula_common/robosense__common_8hpp_source/","title":"File robosense_common.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; robosense &gt; robosense_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\n// Flag for detecting Bpearl version\nconstexpr uint8_t BPEARL_V4_FLAG = 0x04;\n\nstruct RobosenseSensorConfiguration : SensorConfigurationBase\n{\n  uint16_t gnss_port{};  // difop\n  double scan_phase{};   // start/end angle\n  double dual_return_distance_threshold{};\n  uint16_t rotation_speed;\n  uint16_t cloud_min_angle;\n  uint16_t cloud_max_angle;\n};\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, RobosenseSensorConfiguration const &amp; arg)\n{\n  os &lt;&lt; (SensorConfigurationBase)(arg) &lt;&lt; \", GnssPort: \" &lt;&lt; arg.gnss_port\n     &lt;&lt; \", ScanPhase:\" &lt;&lt; arg.scan_phase &lt;&lt; \", RotationSpeed:\" &lt;&lt; arg.rotation_speed\n     &lt;&lt; \", FOV(Start):\" &lt;&lt; arg.cloud_min_angle &lt;&lt; \", FOV(End):\" &lt;&lt; arg.cloud_max_angle;\n  return os;\n}\n\ninline ReturnMode ReturnModeFromStringRobosense(const std::string &amp; return_mode)\n{\n  if (return_mode == \"Dual\") return ReturnMode::DUAL;\n  if (return_mode == \"Strongest\") return ReturnMode::SINGLE_STRONGEST;\n  if (return_mode == \"Last\") return ReturnMode::SINGLE_LAST;\n  if (return_mode == \"First\") return ReturnMode::SINGLE_FIRST;\n\n  return ReturnMode::UNKNOWN;\n}\n\nsize_t GetChannelSize(const SensorModel &amp; model)\n{\n  switch (model) {\n    case SensorModel::ROBOSENSE_BPEARL_V3:\n      return 32;\n    case SensorModel::ROBOSENSE_HELIOS:\n      return 32;\n  }\n}\n\nstruct ChannelCorrection\n{\n  float azimuth{NAN};\n  float elevation{NAN};\n  uint16_t channel{};\n\n  [[nodiscard]] bool has_value() const { return !std::isnan(azimuth) &amp;&amp; !std::isnan(elevation); }\n};\n\nstruct RobosenseCalibrationConfiguration : CalibrationConfigurationBase\n{\n  std::vector&lt;ChannelCorrection&gt; calibration;\n\n  void SetChannelSize(const size_t channel_num) { calibration.resize(channel_num); }\n\n  template &lt;typename stream_t&gt;\n  inline nebula::Status LoadFromStream(stream_t &amp; stream)\n  {\n    std::string header;\n    std::getline(stream, header);\n\n    char sep;\n    int laser_id;\n    float elevation;\n    float azimuth;\n    Status load_status = Status::OK;\n    for (size_t i = 0; i &lt; calibration.size(); ++i) {\n      stream &gt;&gt; laser_id &gt;&gt; sep &gt;&gt; elevation &gt;&gt; sep &gt;&gt; azimuth;\n\n      if (laser_id &lt;= 0 || laser_id &gt; calibration.size()) {\n        std::cout &lt;&lt; \"Invalid laser id: \" &lt;&lt; laser_id &lt;&lt; std::endl;\n        load_status = Status::INVALID_CALIBRATION_FILE;\n      }\n      if (std::isnan(elevation) || std::isnan(azimuth)) {\n        std::cout &lt;&lt; \"Invalid calibration data\" &lt;&lt; laser_id &lt;&lt; \",\" &lt;&lt; elevation &lt;&lt; \",\" &lt;&lt; azimuth\n                  &lt;&lt; std::endl;\n        load_status = Status::INVALID_CALIBRATION_FILE;\n      }\n      if (\n        calibration[laser_id - 1].has_value() &amp;&amp; calibration[laser_id - 1].elevation != elevation &amp;&amp;\n        calibration[laser_id - 1].azimuth != azimuth) {\n        std::cout &lt;&lt; \"Duplicate calibration data for laser id: \" &lt;&lt; laser_id &lt;&lt; std::endl;\n        load_status = Status::INVALID_CALIBRATION_FILE;\n      }\n\n      ChannelCorrection correction{azimuth, elevation};\n      calibration[laser_id - 1] = correction;\n    }\n\n    for (auto &amp; calib : calibration) {\n      if (!calib.has_value()) {\n        std::cout &lt;&lt; calib.elevation &lt;&lt; \",\" &lt;&lt; calib.azimuth &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Missing calibration data\" &lt;&lt; std::endl;\n        load_status = Status::INVALID_CALIBRATION_FILE;\n      }\n    }\n\n    if (load_status != Status::OK) {\n      for (auto &amp; correction : calibration) {\n        correction.elevation = NAN;\n        correction.azimuth = NAN;\n      }\n    }\n\n    return load_status;\n  }\n\n  inline nebula::Status LoadFromFile(const std::string &amp; calibration_file)\n  {\n    std::ifstream ifs(calibration_file);\n    if (!ifs) {\n      return Status::INVALID_CALIBRATION_FILE;\n    }\n\n    const auto status = LoadFromStream(ifs);\n    ifs.close();\n    return status;\n  }\n\n  inline nebula::Status LoadFromString(const std::string &amp; calibration_content)\n  {\n    std::stringstream ss;\n    ss &lt;&lt; calibration_content;\n\n    const auto status = LoadFromStream(ss);\n    return status;\n  }\n\n  //  inline nebula::Status LoadFromDifop(const std::string &amp; calibration_file)\n\n  inline nebula::Status SaveFile(const std::string &amp; calibration_file)\n  {\n    std::ofstream ofs(calibration_file);\n    if (!ofs) {\n      return Status::CANNOT_SAVE_FILE;\n    }\n    ofs &lt;&lt; \"Laser id,Elevation,Azimuth\" &lt;&lt; std::endl;\n\n    for (size_t i = 0; i &lt; calibration.size(); ++i) {\n      auto laser_id = i + 1;\n      float elevation = calibration[i].elevation;\n      float azimuth = calibration[i].azimuth;\n      ofs &lt;&lt; laser_id &lt;&lt; \",\" &lt;&lt; elevation &lt;&lt; \",\" &lt;&lt; azimuth &lt;&lt; std::endl;\n    }\n\n    ofs.close();\n    return Status::OK;\n  }\n\n  [[nodiscard]] inline ChannelCorrection GetCorrection(const size_t channel_id) const\n  {\n    return calibration[channel_id];\n  }\n\n  void CreateCorrectedChannels()\n  {\n    for(auto&amp; correction : calibration) {\n      uint16_t channel = 0;\n      for(const auto&amp; compare:calibration) {\n        if(compare.elevation &lt; correction.elevation) ++channel;\n      }\n      correction.channel = channel;\n    }\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_common/dir_a9be73d3a179cc984b65f35408b847b4/","title":"Dir nebula_common/include/nebula_common/velodyne","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne</p>"},{"location":"nebula_common/dir_a9be73d3a179cc984b65f35408b847b4/#files","title":"Files","text":"Type Name file velodyne_calibration_decoder.hpp file velodyne_common.hpp file velodyne_status.hpp <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/</code></p>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/","title":"File velodyne_calibration_decoder.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_calibration_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;yaml-cpp/yaml.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneCalibration Calibration information for the entire device. struct VelodyneLaserCorrection <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp_source/","title":"File velodyne_calibration_decoder.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_calibration_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_CALIBRATION_DECODER_H\n#define NEBULA_VELODYNE_CALIBRATION_DECODER_H\n\n#include &lt;yaml-cpp/yaml.h&gt;\n\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstruct VelodyneLaserCorrection\n{\n  float rot_correction;\n  float vert_correction;\n  float dist_correction;\n  bool two_pt_correction_available;\n  float dist_correction_x;\n  float dist_correction_y;\n  float vert_offset_correction;\n  float horiz_offset_correction;\n  int max_intensity;\n  int min_intensity;\n  float focal_distance;\n  float focal_slope;\n\n  float cos_rot_correction;   \n  float sin_rot_correction;   \n  float cos_vert_correction;  \n  float sin_vert_correction;  \n\n  int laser_ring;  \n};\n\nclass VelodyneCalibration\n{\npublic:\n  float distance_resolution_m;\n  std::map&lt;int, VelodyneLaserCorrection&gt; laser_corrections_map;\n  std::vector&lt;VelodyneLaserCorrection&gt; laser_corrections;\n  int num_lasers{};\n  bool initialized;\n  bool ros_info;\n\npublic:\n  explicit VelodyneCalibration(bool info = true)\n  : distance_resolution_m(0.002f), initialized(false), ros_info(info)\n  {\n  }\n  explicit VelodyneCalibration(const std::string &amp; calibration_file, bool info = true)\n  : distance_resolution_m(0.002f), ros_info(info)\n  {\n    read(calibration_file);\n  }\n\n  void read(const std::string &amp; calibration_file);\n  void write(const std::string &amp; calibration_file);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_CALIBRATION_DECODER_H\n</code></pre>"},{"location":"nebula_common/velodyne__common_8hpp/","title":"File velodyne_common.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/velodyne__common_8hpp/#classes","title":"Classes","text":"Type Name struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration struct VelodyneSensorConfiguration struct for Velodyne sensor configuration <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/velodyne__common_8hpp_source/","title":"File velodyne_common.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_COMMON_H\n#define NEBULA_VELODYNE_COMMON_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"\n\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\nnamespace nebula\n{\nnamespace drivers\n{\nstruct VelodyneSensorConfiguration : SensorConfigurationBase\n{\n  uint16_t gnss_port{};\n  double scan_phase{};\n  uint16_t rotation_speed;\n  uint16_t cloud_min_angle;\n  uint16_t cloud_max_angle;\n};\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, VelodyneSensorConfiguration const &amp; arg)\n{\n  os &lt;&lt; (SensorConfigurationBase)(arg) &lt;&lt; \", GnssPort: \" &lt;&lt; arg.gnss_port\n     &lt;&lt; \", ScanPhase:\" &lt;&lt; arg.scan_phase &lt;&lt; \", RotationSpeed:\" &lt;&lt; arg.rotation_speed\n     &lt;&lt; \", FOV(Start):\" &lt;&lt; arg.cloud_min_angle &lt;&lt; \", FOV(End):\" &lt;&lt; arg.cloud_max_angle;\n  return os;\n}\n\nstruct VelodyneCalibrationConfiguration : CalibrationConfigurationBase\n{\n  VelodyneCalibration velodyne_calibration;\n  inline nebula::Status LoadFromFile(const std::string &amp; calibration_file)\n  {\n    velodyne_calibration.read(calibration_file);\n    if (!velodyne_calibration.initialized) {\n      return Status::INVALID_CALIBRATION_FILE;\n    } else {\n      return Status::OK;\n    }\n  }\n  inline nebula::Status SaveFile(const std::string &amp; calibration_file)\n  {\n    velodyne_calibration.write(calibration_file);\n    return Status::OK;\n  }\n};\n\ninline ReturnMode ReturnModeFromStringVelodyne(const std::string &amp; return_mode)\n{\n  if (return_mode == \"Strongest\") return ReturnMode::SINGLE_STRONGEST;\n  if (return_mode == \"Last\") return ReturnMode::SINGLE_LAST;\n  if (return_mode == \"Dual\") return ReturnMode::DUAL_ONLY;\n\n  return ReturnMode::UNKNOWN;\n}\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_COMMON_H\n</code></pre>"},{"location":"nebula_common/velodyne__status_8hpp/","title":"File velodyne_status.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/velodyne__status_8hpp/#classes","title":"Classes","text":"Type Name struct VelodyneStatus Status definition for Velodyne. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_status.hpp</code></p>"},{"location":"nebula_common/velodyne__status_8hpp_source/","title":"File velodyne_status.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef VELODYNE_STATUS_HPP\n#define VELODYNE_STATUS_HPP\n\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct VelodyneStatus : Status\n{\n  using Status::Status;\n\nprivate:\n  int _type_num;\n\npublic:\n  enum VelodyneType {\n    INVALID_RPM_ERROR = Type_end_of_Status + 1,\n    INVALID_FOV_ERROR,\n    INVALID_RETURN_MODE_ERROR,\n    Type_end_of_Status = INVALID_RPM_ERROR\n  } _velo_type;\n  VelodyneStatus() : _type_num(static_cast&lt;int&gt;(Status::OK)) { _type = static_cast&lt;Type&gt;(type()); }\n  VelodyneStatus(Type v) : _type_num(static_cast&lt;int&gt;(v)) { _type = v; }\n  VelodyneStatus(VelodyneType v) : _type_num(static_cast&lt;int&gt;(v)), _velo_type(v)\n  {\n    _type = Type::Type_end_of_Status;\n  }\n  VelodyneStatus(int type) : _type_num(type) {}\n  int type() const { return _type_num; }\n  friend bool operator==(const VelodyneStatus &amp; L, const VelodyneStatus &amp; R)\n  {\n    return L.type() == R.type();\n  }\n  friend bool operator!=(const VelodyneStatus &amp; L, const VelodyneStatus &amp; R)\n  {\n    return L.type() != R.type();\n  }\n  //  friend VelodyneStatus operator VelodyneStatus(const Status &amp; s) {return VelodyneStatus(s);}\n  // implicit\n  //  operator Status() const {std::cout &lt;&lt; \"implicit\" &lt;&lt; std::endl; return Status(type());}\n  //  operator const Status() {std::cout &lt;&lt; \"implicit\" &lt;&lt; std::endl; return Status(type());}\n  //  explicit operator Status() const {std::cout &lt;&lt; \"explicit\" &lt;&lt; std::endl; return\n  //  Status(type());} Status Status::operator=(const VelodyneStatus&amp;) {std::cout &lt;&lt; \"implicit = \"\n  //  &lt;&lt; std::endl; return Status(type());} Status operator=(const VelodyneStatus) {std::cout &lt;&lt;\n  //  \"implicit = \" &lt;&lt; std::endl; return Status(type());} Status&amp; operator=(const VelodyneStatus&amp;)\n  //  {std::cout &lt;&lt; \"implicit = \" &lt;&lt; std::endl; Status rt = Status(type()); return rt;}\n  //  Status::Status(const VelodyneStatus&amp; vs) {_type = v;}\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::VelodyneStatus const &amp; arg)\n  {\n    switch (arg.type()) {\n      /*\n      // in nebula_status.hpp\n      case Status::OK:\n        os &lt;&lt; \"OK\";\n        break;\n      case Status::UDP_CONNECTION_ERROR:\n        os &lt;&lt; \"Udp Connection Error\";\n        break;\n      case Status::SENSOR_CONFIG_ERROR:\n        os &lt;&lt; \"Could not set SensorConfiguration\";\n        break;\n      case Status::INVALID_SENSOR_MODEL:\n        os &lt;&lt; \"Invalid sensor model provided\";\n        break;\n      case Status::INVALID_ECHO_MODE:\n        os &lt;&lt; \"Invalid echo model provided\";\n        break;\n      case Status::NOT_IMPLEMENTED:\n        os &lt;&lt; \"Not Implemented\";\n        break;\n      case Status::NOT_INITIALIZED:\n        os &lt;&lt; \"Not Initialized\";\n        break;\n      case Status::INVALID_CALIBRATION_FILE:\n        os &lt;&lt; \"Invalid Calibration File\";\n        break;\n      case Status::CANNOT_SAVE_FILE:\n        os &lt;&lt; \"Cannot Save File\";\n        break;\n      case Status::HTTP_CONNECTION_ERROR:\n        os &lt;&lt; \"Http Connection Error\";\n        break;\n      */\n      // Velodyne\n      case VelodyneStatus::INVALID_RPM_ERROR:\n        os &lt;&lt; \"Invalid rotation speed value(range from 300 to 1200, in increments of 60)\";\n        break;\n      case VelodyneStatus::INVALID_FOV_ERROR:\n        os &lt;&lt; \"Invalid fov value(0 to 359)\";\n        break;\n      case VelodyneStatus::INVALID_RETURN_MODE_ERROR:\n        os &lt;&lt; \"Invalid return mode(only SINGLE_STRONGEST, SINGLE_LAST, DUAL_ONLY)\";\n        break;\n      default:\n        os &lt;&lt; Status(arg._type);\n    }\n    return os;\n  }\n};\n}  // namespace nebula\n#endif  // VELODYNE_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/nebula__status_8hpp/","title":"File nebula_status.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; nebula_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/nebula__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/nebula__status_8hpp/#classes","title":"Classes","text":"Type Name struct Status Status definition. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_status.hpp</code></p>"},{"location":"nebula_common/nebula__status_8hpp_source/","title":"File nebula_status.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; nebula_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_STATUS_HPP\n#define NEBULA_STATUS_HPP\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct Status\n{\n  enum Type {\n    OK = 0,\n    UDP_CONNECTION_ERROR,\n    SENSOR_CONFIG_ERROR,\n    INVALID_SENSOR_MODEL,\n    INVALID_ECHO_MODE,\n    NOT_IMPLEMENTED,\n    NOT_INITIALIZED,\n    INVALID_CALIBRATION_FILE,\n    CANNOT_SAVE_FILE,\n    HTTP_CONNECTION_ERROR,\n    WAITING_FOR_SENSOR_RESPONSE,\n    ERROR_1,\n    Type_end_of_Status = ERROR_1\n  } _type;\n  Status() : _type(Type::OK) {}\n  Status(Type v) : _type(v) {}\n  Status(int type) : _type(static_cast&lt;Type&gt;(type)) {}\n  Type type() const { return _type; }\n  friend bool operator==(const Status &amp; L, const Status &amp; R) { return L.type() == R.type(); }\n  friend bool operator!=(const Status &amp; L, const Status &amp; R) { return L.type() != R.type(); }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::Status const &amp; arg)\n  {\n    switch (arg.type()) {\n      case Status::OK:\n        os &lt;&lt; \"OK\";\n        break;\n      case Status::UDP_CONNECTION_ERROR:\n        os &lt;&lt; \"Udp Connection Error\";\n        break;\n      case Status::SENSOR_CONFIG_ERROR:\n        os &lt;&lt; \"Could not set SensorConfiguration\";\n        break;\n      case Status::INVALID_SENSOR_MODEL:\n        os &lt;&lt; \"Invalid sensor model provided\";\n        break;\n      case Status::INVALID_ECHO_MODE:\n        os &lt;&lt; \"Invalid echo model provided\";\n        break;\n      case Status::NOT_IMPLEMENTED:\n        os &lt;&lt; \"Not Implemented\";\n        break;\n      case Status::NOT_INITIALIZED:\n        os &lt;&lt; \"Not Initialized\";\n        break;\n      case Status::INVALID_CALIBRATION_FILE:\n        os &lt;&lt; \"Invalid Calibration File\";\n        break;\n      case Status::CANNOT_SAVE_FILE:\n        os &lt;&lt; \"Cannot Save File\";\n        break;\n      case Status::HTTP_CONNECTION_ERROR:\n        os &lt;&lt; \"Http Connection Error\";\n        break;\n      case Status::WAITING_FOR_SENSOR_RESPONSE:\n        os &lt;&lt; \"Waiting for Sensor Response\";\n        break;\n      case Status::ERROR_1:\n      default:\n        os &lt;&lt; \"Generic Error\";\n    }\n    return os;\n  }\n};\n\n}  // namespace nebula\n#endif  // NEBULA_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/point__types_8hpp/","title":"File point_types.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; point_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;pcl/point_cloud.h&gt;</code></li> <li><code>#include &lt;pcl/point_types.h&gt;</code></li> </ul>"},{"location":"nebula_common/point__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/point__types_8hpp/#classes","title":"Classes","text":"Type Name struct PointXYZICATR struct PointXYZIR struct PointXYZIRADT struct PointXYZIRCAEDT <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/point__types_8hpp_source/","title":"File point_types.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; point_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_POINT_TYPES_H\n#define NEBULA_POINT_TYPES_H\n\n#include &lt;pcl/point_cloud.h&gt;\n#include &lt;pcl/point_types.h&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstruct PointXYZIR\n{\n  PCL_ADD_POINT4D;\n  float intensity;\n  uint16_t ring;\n  EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n} EIGEN_ALIGN16;\n\nstruct PointXYZICATR\n{\n  PCL_ADD_POINT4D;\n  std::uint8_t intensity;\n  std::uint16_t channel;\n  float azimuth;\n  std::uint32_t time_stamp;\n  std::uint8_t return_type;\n};\nstruct PointXYZIRCAEDT\n{\n  float x;\n  float y;\n  float z;\n  std::uint8_t intensity;\n  std::uint8_t return_type;\n  std::uint16_t channel;\n  float azimuth;\n  float elevation;\n  float distance;\n  std::uint32_t time_stamp;\n};\n\nstruct PointXYZIRADT\n{\n  PCL_ADD_POINT4D;\n  float intensity;\n  uint16_t ring;\n  float azimuth;\n  float distance;\n  uint8_t return_type;\n  double time_stamp;\n  EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n} EIGEN_ALIGN16;\n\nusing NebulaPoint = PointXYZIRCAEDT;\nusing NebulaPointPtr = std::shared_ptr&lt;NebulaPoint&gt;;\nusing NebulaPointCloud = pcl::PointCloud&lt;NebulaPoint&gt;;\nusing NebulaPointCloudPtr = pcl::PointCloud&lt;NebulaPoint&gt;::Ptr;\n\n}  // namespace drivers\n}  // namespace nebula\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(nebula::drivers::PointXYZIR,\n                                  (float, x, x)(float, y, y)(float, z, z)(float, intensity, intensity)(std::uint16_t,\n                                                                                                       ring, ring))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(nebula::drivers::PointXYZIRADT,\n                                  (float, x, x)\n                                    (float, y, y)\n                                    (float, z, z)\n                                    (float, intensity, intensity)\n                                    (std::uint16_t, ring, ring)\n                                    (float, azimuth, azimuth)\n                                    (float, distance, distance)\n                                    (std::uint8_t, return_type, return_type)\n                                    (double, time_stamp, time_stamp))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(\n  nebula::drivers::PointXYZICATR,\n  (float, x, x)(float, y, y)(float, z, z)(std::uint8_t, intensity, intensity)(\n    std::uint16_t, channel, channel)(float, azimuth, azimuth)(\n    std::uint32_t, time_stamp, time_stamp)(std::uint8_t, return_type, return_type))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(\n  nebula::drivers::PointXYZIRCAEDT,\n  (float, x, x)(float, y, y)(float, z, z)(std::uint8_t, intensity, intensity)(\n    std::uint8_t, return_type,\n    return_type)(std::uint16_t, channel, channel)(float, azimuth, azimuth)(\n    float, elevation, elevation)(float, distance, distance)(std::uint32_t, time_stamp, time_stamp))\n\n#endif\n</code></pre>"},{"location":"nebula_common/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers </li> </ul> </li> </ul>"},{"location":"nebula_common/classes/","title":"Class Index","text":""},{"location":"nebula_common/classes/#c","title":"c","text":"<ul> <li>CalibrationConfigurationBase (nebula::drivers)</li> <li>ChannelCorrection (nebula::drivers)</li> </ul>"},{"location":"nebula_common/classes/#h","title":"h","text":"<ul> <li>HesaiCalibrationConfiguration (nebula::drivers)</li> <li>HesaiCorrection (nebula::drivers)</li> <li>HesaiSensorConfiguration (nebula::drivers)</li> <li>HesaiStatus (nebula)</li> </ul>"},{"location":"nebula_common/classes/#p","title":"p","text":"<ul> <li>PointField (nebula::drivers)</li> <li>PointXYZICATR (nebula::drivers)</li> <li>PointXYZIR (nebula::drivers)</li> <li>PointXYZIRADT (nebula::drivers)</li> <li>PointXYZIRCAEDT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/classes/#r","title":"r","text":"<ul> <li>RobosenseCalibrationConfiguration (nebula::drivers)</li> <li>RobosenseSensorConfiguration (nebula::drivers)</li> </ul>"},{"location":"nebula_common/classes/#s","title":"s","text":"<ul> <li>SensorConfigurationBase (nebula::drivers)</li> <li>Status (nebula)</li> </ul>"},{"location":"nebula_common/classes/#v","title":"v","text":"<ul> <li>VelodyneCalibration (nebula::drivers)</li> <li>VelodyneCalibrationConfiguration (nebula::drivers)</li> <li>VelodyneLaserCorrection (nebula::drivers)</li> <li>VelodyneSensorConfiguration (nebula::drivers)</li> <li>VelodyneStatus (nebula)</li> </ul>"},{"location":"nebula_common/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::VelodyneCalibration Calibration information for the entire device. </li> <li>struct nebula::Status Status definition. <ul> <li>struct nebula::HesaiStatus Status definition for Hesai.</li> <li>struct nebula::VelodyneStatus Status definition for Velodyne.</li> </ul> </li> <li>struct nebula::drivers::CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) <ul> <li>struct nebula::drivers::HesaiCalibrationConfiguration struct for Hesai calibration configuration </li> <li>struct nebula::drivers::RobosenseCalibrationConfiguration struct for Robosense calibration configuration </li> <li>struct nebula::drivers::VelodyneCalibrationConfiguration struct for Velodyne calibration configuration </li> </ul> </li> <li>struct nebula::drivers::ChannelCorrection </li> <li>struct nebula::drivers::HesaiCorrection struct for Hesai correction configuration (for AT) </li> <li>struct nebula::drivers::SensorConfigurationBase Base struct for Sensor configuration. <ul> <li>struct nebula::drivers::HesaiSensorConfiguration struct for Hesai sensor configuration </li> <li>struct nebula::drivers::RobosenseSensorConfiguration struct for Robosense sensor configuration </li> <li>struct nebula::drivers::VelodyneSensorConfiguration struct for Velodyne sensor configuration </li> </ul> </li> <li>struct nebula::drivers::PointField not used? </li> <li>struct nebula::drivers::PointXYZICATR </li> <li>struct nebula::drivers::PointXYZIR </li> <li>struct nebula::drivers::PointXYZIRADT </li> <li>struct nebula::drivers::PointXYZIRCAEDT </li> <li>struct nebula::drivers::VelodyneLaserCorrection </li> </ul>"},{"location":"nebula_common/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_common/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_common/class_members/","title":"Class Members","text":""},{"location":"nebula_common/class_members/#a","title":"a","text":"<ul> <li>azimuth (nebula::drivers::ChannelCorrection, nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>azimuth_offset_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>azimuthOffset (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#c","title":"c","text":"<ul> <li>calibration_file (nebula::drivers::CalibrationConfigurationBase)</li> <li>channel (nebula::drivers::ChannelCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRCAEDT)</li> <li>channelNumber (nebula::drivers::HesaiCorrection)</li> <li>cloud_max_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>cloud_min_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>count (nebula::drivers::PointField)</li> <li>CreateCorrectedChannels (nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>calibration (nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>coordinate_mode (nebula::drivers::SensorConfigurationBase)</li> <li>cos_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>cos_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#d","title":"d","text":"<ul> <li>delimiter (nebula::drivers::HesaiCorrection)</li> <li>dual_return_distance_threshold (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration)</li> <li>datatype (nebula::drivers::PointField)</li> <li>distance (nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>data_port (nebula::drivers::SensorConfigurationBase)</li> <li>distance_resolution_m (nebula::drivers::VelodyneCalibration)</li> <li>dist_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_x (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_y (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#e","title":"e","text":"<ul> <li>elevation (nebula::drivers::ChannelCorrection, nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZIRCAEDT)</li> <li>elev_angle_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>elevationOffset (nebula::drivers::HesaiCorrection)</li> <li>endFrame (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#f","title":"f","text":"<ul> <li>frameConfig (nebula::drivers::HesaiCorrection)</li> <li>frameNumber (nebula::drivers::HesaiCorrection)</li> <li>fields (nebula::drivers::SensorConfigurationBase)</li> <li>frame_id (nebula::drivers::SensorConfigurationBase)</li> <li>frequency_ms (nebula::drivers::SensorConfigurationBase)</li> <li>focal_distance (nebula::drivers::VelodyneLaserCorrection)</li> <li>focal_slope (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#g","title":"g","text":"<ul> <li>getAzimuthAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>getElevationAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>gnss_port (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>GetCorrection (nebula::drivers::RobosenseCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_members/#h","title":"h","text":"<ul> <li>HesaiStatus (nebula::HesaiStatus)</li> <li>HesaiType (nebula::HesaiStatus)</li> <li>has_value (nebula::drivers::ChannelCorrection)</li> <li>host_ip (nebula::drivers::SensorConfigurationBase)</li> <li>horiz_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#i","title":"i","text":"<ul> <li>intensity (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>initialized (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#l","title":"l","text":"<ul> <li>LoadFromFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::HesaiCorrection, nebula::drivers::RobosenseCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>LoadFromString (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>LoadFromBinary (nebula::drivers::HesaiCorrection)</li> <li>LoadFromStream (nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>laser_corrections (nebula::drivers::VelodyneCalibration)</li> <li>laser_corrections_map (nebula::drivers::VelodyneCalibration)</li> <li>laser_ring (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#m","title":"m","text":"<ul> <li>mirrorNumber (nebula::drivers::HesaiCorrection)</li> <li>max_range (nebula::drivers::SensorConfigurationBase)</li> <li>min_range (nebula::drivers::SensorConfigurationBase)</li> <li>max_intensity (nebula::drivers::VelodyneLaserCorrection)</li> <li>min_intensity (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#n","title":"n","text":"<ul> <li>name (nebula::drivers::PointField)</li> <li>num_lasers (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#o","title":"o","text":"<ul> <li>offset (nebula::drivers::PointField)</li> </ul>"},{"location":"nebula_common/class_members/#p","title":"p","text":"<ul> <li>ptp_domain (nebula::drivers::HesaiSensorConfiguration)</li> <li>ptp_profile (nebula::drivers::HesaiSensorConfiguration)</li> <li>ptp_transport_type (nebula::drivers::HesaiSensorConfiguration)</li> <li>PCL_ADD_POINT4D (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>packet_mtu_size (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_members/#r","title":"r","text":"<ul> <li>resolution (nebula::drivers::HesaiCorrection)</li> <li>rotation_speed (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>return_type (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>ring (nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>remove_nans (nebula::drivers::SensorConfigurationBase)</li> <li>return_mode (nebula::drivers::SensorConfigurationBase)</li> <li>read (nebula::drivers::VelodyneCalibration)</li> <li>ros_info (nebula::drivers::VelodyneCalibration)</li> <li>rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#s","title":"s","text":"<ul> <li>Status (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>SaveFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::RobosenseCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>SaveFileFromString (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>SHA256 (nebula::drivers::HesaiCorrection)</li> <li>STEP3 (nebula::drivers::HesaiCorrection)</li> <li>SaveFileFromBinary (nebula::drivers::HesaiCorrection)</li> <li>startFrame (nebula::drivers::HesaiCorrection)</li> <li>scan_phase (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>SetChannelSize (nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>sensor_ip (nebula::drivers::SensorConfigurationBase)</li> <li>sensor_model (nebula::drivers::SensorConfigurationBase)</li> <li>sin_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>sin_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#t","title":"t","text":"<ul> <li>type (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>Type (nebula::Status)</li> <li>time_stamp (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>two_pt_correction_available (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#u","title":"u","text":"<ul> <li>use_sensor_time (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_members/#v","title":"v","text":"<ul> <li>VelodyneStatus (nebula::VelodyneStatus)</li> <li>VelodyneType (nebula::VelodyneStatus)</li> <li>versionMajor (nebula::drivers::HesaiCorrection)</li> <li>versionMinor (nebula::drivers::HesaiCorrection)</li> <li>VelodyneCalibration (nebula::drivers::VelodyneCalibration)</li> <li>velodyne_calibration (nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>vert_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#w","title":"w","text":"<ul> <li>write (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#x","title":"x","text":"<ul> <li>x (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#y","title":"y","text":"<ul> <li>y (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#z","title":"z","text":"<ul> <li>z (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#_","title":"_","text":"<ul> <li>_hesai_type (nebula::HesaiStatus)</li> <li>_type_num (nebula::HesaiStatus, nebula::VelodyneStatus)</li> <li>_type (nebula::Status)</li> <li>_velo_type (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_common/class_member_functions/#c","title":"c","text":"<ul> <li>CreateCorrectedChannels (nebula::drivers::RobosenseCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#g","title":"g","text":"<ul> <li>getAzimuthAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>getElevationAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>GetCorrection (nebula::drivers::RobosenseCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiStatus (nebula::HesaiStatus)</li> <li>has_value (nebula::drivers::ChannelCorrection)</li> </ul>"},{"location":"nebula_common/class_member_functions/#l","title":"l","text":"<ul> <li>LoadFromFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::HesaiCorrection, nebula::drivers::RobosenseCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>LoadFromString (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>LoadFromBinary (nebula::drivers::HesaiCorrection)</li> <li>LoadFromStream (nebula::drivers::RobosenseCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#r","title":"r","text":"<ul> <li>read (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#s","title":"s","text":"<ul> <li>Status (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>SaveFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::RobosenseCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>SaveFileFromString (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>SaveFileFromBinary (nebula::drivers::HesaiCorrection)</li> <li>SetChannelSize (nebula::drivers::RobosenseCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#t","title":"t","text":"<ul> <li>type (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneStatus (nebula::VelodyneStatus)</li> <li>VelodyneCalibration (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#w","title":"w","text":"<ul> <li>write (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_common/class_member_variables/#a","title":"a","text":"<ul> <li>azimuth (nebula::drivers::ChannelCorrection, nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>azimuth_offset_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>azimuthOffset (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#c","title":"c","text":"<ul> <li>calibration_file (nebula::drivers::CalibrationConfigurationBase)</li> <li>channel (nebula::drivers::ChannelCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRCAEDT)</li> <li>channelNumber (nebula::drivers::HesaiCorrection)</li> <li>cloud_max_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>cloud_min_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>count (nebula::drivers::PointField)</li> <li>calibration (nebula::drivers::RobosenseCalibrationConfiguration)</li> <li>coordinate_mode (nebula::drivers::SensorConfigurationBase)</li> <li>cos_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>cos_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#d","title":"d","text":"<ul> <li>delimiter (nebula::drivers::HesaiCorrection)</li> <li>dual_return_distance_threshold (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration)</li> <li>datatype (nebula::drivers::PointField)</li> <li>distance (nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>data_port (nebula::drivers::SensorConfigurationBase)</li> <li>distance_resolution_m (nebula::drivers::VelodyneCalibration)</li> <li>dist_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_x (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_y (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#e","title":"e","text":"<ul> <li>elevation (nebula::drivers::ChannelCorrection, nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZIRCAEDT)</li> <li>elev_angle_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>elevationOffset (nebula::drivers::HesaiCorrection)</li> <li>endFrame (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#f","title":"f","text":"<ul> <li>frameConfig (nebula::drivers::HesaiCorrection)</li> <li>frameNumber (nebula::drivers::HesaiCorrection)</li> <li>fields (nebula::drivers::SensorConfigurationBase)</li> <li>frame_id (nebula::drivers::SensorConfigurationBase)</li> <li>frequency_ms (nebula::drivers::SensorConfigurationBase)</li> <li>focal_distance (nebula::drivers::VelodyneLaserCorrection)</li> <li>focal_slope (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#g","title":"g","text":"<ul> <li>gnss_port (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#h","title":"h","text":"<ul> <li>host_ip (nebula::drivers::SensorConfigurationBase)</li> <li>horiz_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#i","title":"i","text":"<ul> <li>intensity (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>initialized (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#l","title":"l","text":"<ul> <li>laser_corrections (nebula::drivers::VelodyneCalibration)</li> <li>laser_corrections_map (nebula::drivers::VelodyneCalibration)</li> <li>laser_ring (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#m","title":"m","text":"<ul> <li>mirrorNumber (nebula::drivers::HesaiCorrection)</li> <li>max_range (nebula::drivers::SensorConfigurationBase)</li> <li>min_range (nebula::drivers::SensorConfigurationBase)</li> <li>max_intensity (nebula::drivers::VelodyneLaserCorrection)</li> <li>min_intensity (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#n","title":"n","text":"<ul> <li>name (nebula::drivers::PointField)</li> <li>num_lasers (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#o","title":"o","text":"<ul> <li>offset (nebula::drivers::PointField)</li> </ul>"},{"location":"nebula_common/class_member_variables/#p","title":"p","text":"<ul> <li>ptp_domain (nebula::drivers::HesaiSensorConfiguration)</li> <li>ptp_profile (nebula::drivers::HesaiSensorConfiguration)</li> <li>ptp_transport_type (nebula::drivers::HesaiSensorConfiguration)</li> <li>PCL_ADD_POINT4D (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>packet_mtu_size (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_member_variables/#r","title":"r","text":"<ul> <li>resolution (nebula::drivers::HesaiCorrection)</li> <li>rotation_speed (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>return_type (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>ring (nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>remove_nans (nebula::drivers::SensorConfigurationBase)</li> <li>return_mode (nebula::drivers::SensorConfigurationBase)</li> <li>ros_info (nebula::drivers::VelodyneCalibration)</li> <li>rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#s","title":"s","text":"<ul> <li>SHA256 (nebula::drivers::HesaiCorrection)</li> <li>STEP3 (nebula::drivers::HesaiCorrection)</li> <li>startFrame (nebula::drivers::HesaiCorrection)</li> <li>scan_phase (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::RobosenseSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>sensor_ip (nebula::drivers::SensorConfigurationBase)</li> <li>sensor_model (nebula::drivers::SensorConfigurationBase)</li> <li>sin_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>sin_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#t","title":"t","text":"<ul> <li>time_stamp (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>two_pt_correction_available (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#u","title":"u","text":"<ul> <li>use_sensor_time (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_member_variables/#v","title":"v","text":"<ul> <li>versionMajor (nebula::drivers::HesaiCorrection)</li> <li>versionMinor (nebula::drivers::HesaiCorrection)</li> <li>velodyne_calibration (nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>vert_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#x","title":"x","text":"<ul> <li>x (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#y","title":"y","text":"<ul> <li>y (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#z","title":"z","text":"<ul> <li>z (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#_","title":"_","text":"<ul> <li>_hesai_type (nebula::HesaiStatus)</li> <li>_type_num (nebula::HesaiStatus, nebula::VelodyneStatus)</li> <li>_type (nebula::Status)</li> <li>_velo_type (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_common/class_member_enums/","title":"Class Member Enums","text":""},{"location":"nebula_common/class_member_enums/#h","title":"h","text":"<ul> <li>HesaiType (nebula::HesaiStatus)</li> </ul>"},{"location":"nebula_common/class_member_enums/#t","title":"t","text":"<ul> <li>Type (nebula::Status)</li> </ul>"},{"location":"nebula_common/class_member_enums/#v","title":"v","text":"<ul> <li>VelodyneType (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_common/namespace_members/#b","title":"b","text":"<ul> <li>BPEARL_V4_FLAG (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#c","title":"c","text":"<ul> <li>CoordinateMode (nebula::drivers)</li> <li>convertPointXYZIRADTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIRADT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#d","title":"d","text":"<ul> <li>datatype (nebula::drivers)</li> <li>deg2rad (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#e","title":"e","text":"<ul> <li>EIGEN_ALIGN16 (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#g","title":"g","text":"<ul> <li>GetChannelSize (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#i","title":"i","text":"<ul> <li>IntFromReturnModeHesai (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#n","title":"n","text":"<ul> <li>NebulaPoint (nebula::drivers)</li> <li>NebulaPointCloud (nebula::drivers)</li> <li>NebulaPointCloudPtr (nebula::drivers)</li> <li>NebulaPointPtr (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#p","title":"p","text":"<ul> <li>PtpProfile (nebula::drivers)</li> <li>PtpProfileFromString (nebula::drivers)</li> <li>PtpTransportType (nebula::drivers)</li> <li>PtpTransportTypeFromString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#r","title":"r","text":"<ul> <li>ReturnMode (nebula::drivers)</li> <li>ReturnModeFromIntHesai (nebula::drivers)</li> <li>ReturnModeFromString (nebula::drivers)</li> <li>ReturnModeFromStringHesai (nebula::drivers)</li> <li>ReturnModeFromStringRobosense (nebula::drivers)</li> <li>ReturnModeFromStringVelodyne (nebula::drivers)</li> <li>ReturnModeToInt (nebula::drivers)</li> <li>ReturnModeToReturnType (nebula::drivers)</li> <li>ReturnType (nebula::drivers)</li> <li>rad2deg (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#s","title":"s","text":"<ul> <li>SensorModel (nebula::drivers)</li> <li>SensorModelFromString (nebula::drivers)</li> <li>SensorModelToString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"nebula_common/namespace_member_functions/#c","title":"c","text":"<ul> <li>convertPointXYZIRADTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIRADT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#d","title":"d","text":"<ul> <li>deg2rad (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#g","title":"g","text":"<ul> <li>GetChannelSize (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#i","title":"i","text":"<ul> <li>IntFromReturnModeHesai (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#p","title":"p","text":"<ul> <li>PtpProfileFromString (nebula::drivers)</li> <li>PtpTransportTypeFromString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#r","title":"r","text":"<ul> <li>ReturnModeFromIntHesai (nebula::drivers)</li> <li>ReturnModeFromString (nebula::drivers)</li> <li>ReturnModeFromStringHesai (nebula::drivers)</li> <li>ReturnModeFromStringRobosense (nebula::drivers)</li> <li>ReturnModeFromStringVelodyne (nebula::drivers)</li> <li>ReturnModeToInt (nebula::drivers)</li> <li>ReturnModeToReturnType (nebula::drivers)</li> <li>rad2deg (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#s","title":"s","text":"<ul> <li>SensorModelFromString (nebula::drivers)</li> <li>SensorModelToString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_common/namespace_member_variables/#b","title":"b","text":"<ul> <li>BPEARL_V4_FLAG (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_variables/#e","title":"e","text":"<ul> <li>EIGEN_ALIGN16 (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"nebula_common/namespace_member_typedefs/#n","title":"n","text":"<ul> <li>NebulaPoint (nebula::drivers)</li> <li>NebulaPointCloud (nebula::drivers)</li> <li>NebulaPointCloudPtr (nebula::drivers)</li> <li>NebulaPointPtr (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"nebula_common/namespace_member_enums/#c","title":"c","text":"<ul> <li>CoordinateMode (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#d","title":"d","text":"<ul> <li>datatype (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#p","title":"p","text":"<ul> <li>PtpProfile (nebula::drivers)</li> <li>PtpTransportType (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#r","title":"r","text":"<ul> <li>ReturnMode (nebula::drivers)</li> <li>ReturnType (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#s","title":"s","text":"<ul> <li>SensorModel (nebula::drivers)</li> </ul>"},{"location":"nebula_common/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_common/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_common/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_common/links/","title":"Nebula Common","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_decoders/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace endian </li> <li>namespace nebula <ul> <li>namespace drivers <ul> <li>class AngleCorrector Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. </li> <li>class AngleCorrectorCalibrationBased </li> <li>class AngleCorrectorCorrectionBased </li> <li>class BpearlV3 </li> <li>class BpearlV4 </li> <li>struct CorrectedAngleData </li> <li>class Helios </li> <li>class HesaiDecoder </li> <li>class HesaiDriver Hesai driver. </li> <li>class HesaiScanDecoder Base class for Hesai LiDAR decoder. </li> <li>class HesaiSensor Base class for all sensor definitions. </li> <li>class NebulaDriverBase Base class for each sensor driver. </li> <li>class Pandar128E3X </li> <li>class Pandar128E4X </li> <li>class Pandar40 </li> <li>class Pandar64 </li> <li>class PandarAT128 </li> <li>class PandarQT128 </li> <li>class PandarQT64 </li> <li>class PandarXT32 </li> <li>class PandarXT32M </li> <li>class RobosenseDecoder </li> <li>class RobosenseDriver Robosense driver. </li> <li>class RobosenseInfoDecoder </li> <li>class RobosenseInfoDecoderBase </li> <li>class RobosenseInfoDriver Robosense driver. </li> <li>class RobosenseScanDecoder Base class for Robosense LiDAR decoder. </li> <li>class RobosenseSensor Base class for all sensor definitions. </li> <li>class VelodyneDriver Velodyne driver. </li> <li>class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. </li> <li>namespace hesai_packet <ul> <li>struct Block </li> <li>struct Body </li> <li>struct DateTime DateTime struct for Hesai packets. </li> <li>struct FineAzimuthBlock </li> <li>struct FunctionalSafety </li> <li>struct Header12B </li> <li>struct Header8B </li> <li>struct Packet128E3X </li> <li>struct Packet40P </li> <li>struct Packet64 </li> <li>struct PacketAT128E2X </li> <li>struct PacketBase Base struct for all Hesai packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. </li> <li>struct PacketQT128C2X </li> <li>struct PacketQT64 </li> <li>struct PacketXT32 </li> <li>struct PacketXT32M2X </li> <li>struct SOBBlock </li> <li>struct SecondsSinceEpoch </li> <li>struct Tail128E3X </li> <li>struct Tail40P </li> <li>struct TailAT128E2X </li> <li>struct TailQT128C2X </li> <li>struct TailQT64 </li> <li>struct TailXT32 </li> <li>struct Unit3B </li> <li>struct Unit4B </li> <li>namespace return_mode </li> </ul> </li> <li>struct raw_block Raw Velodyne data block. </li> <li>struct raw_packet Raw Velodyne packet. </li> <li>namespace robosense_packet <ul> <li>struct Block </li> <li>struct Body </li> <li>struct ChannelAngleCorrection </li> <li>struct CorrectedHorizontalAngle </li> <li>struct CorrectedVerticalAngle </li> <li>struct Ethernet </li> <li>struct FirmwareVersion </li> <li>struct FovSetting </li> <li>struct IpAddress </li> <li>struct MacAddress </li> <li>struct PacketBase Base struct for all Robosense packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. </li> <li>struct SensorCalibration </li> <li>struct SerialNumber </li> <li>struct Timestamp </li> <li>struct Unit </li> <li>namespace bpearl_v3 <ul> <li>struct FaultDiagnosis </li> <li>struct Header </li> <li>struct InfoPacket </li> <li>struct OperatingStatus </li> <li>struct Packet </li> <li>struct Timestamp </li> </ul> </li> <li>namespace bpearl_v4 <ul> <li>struct FaultDiagnosis </li> <li>struct Header </li> <li>struct InfoPacket </li> <li>struct OperatingStatus </li> <li>struct Packet </li> </ul> </li> <li>namespace helios <ul> <li>struct FaultDiagnosis </li> <li>struct Header </li> <li>struct InfoPacket </li> <li>struct OperatingStatus </li> <li>struct Packet </li> <li>struct SensorHwVersion </li> <li>struct WebPageVersion </li> </ul> </li> </ul> </li> <li>union two_bytes </li> <li>namespace vlp16 <ul> <li>class Vlp16Decoder Velodyne LiDAR decoder (VLP16) </li> </ul> </li> <li>namespace vlp32 <ul> <li>class Vlp32Decoder Velodyne LiDAR decoder (VLP32) </li> </ul> </li> <li>namespace vls128 <ul> <li>class Vls128Decoder Velodyne LiDAR decoder (VLS128) </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_decoders <ul> <li>dir include <ul> <li>dir nebula_decoders <ul> <li>dir nebula_decoders_common <ul> <li>file nebula_driver_base.hpp </li> </ul> </li> <li>dir nebula_decoders_hesai <ul> <li>file hesai_driver.hpp </li> <li>dir decoders <ul> <li>file angle_corrector.hpp </li> <li>file angle_corrector_calibration_based.hpp </li> <li>file angle_corrector_correction_based.hpp </li> <li>file hesai_decoder.hpp </li> <li>file hesai_packet.hpp </li> <li>file hesai_scan_decoder.hpp </li> <li>file hesai_sensor.hpp </li> <li>file pandar_128e3x.hpp </li> <li>file pandar_128e4x.hpp </li> <li>file pandar_40.hpp </li> <li>file pandar_64.hpp </li> <li>file pandar_at128.hpp </li> <li>file pandar_qt128.hpp </li> <li>file pandar_qt64.hpp </li> <li>file pandar_xt32.hpp </li> <li>file pandar_xt32m.hpp </li> </ul> </li> </ul> </li> <li>dir nebula_decoders_robosense <ul> <li>dir decoders <ul> <li>file angle_corrector.hpp </li> <li>file angle_corrector_calibration_based.hpp </li> <li>file bpearl_v3.hpp </li> <li>file bpearl_v4.hpp </li> <li>file helios.hpp </li> <li>file robosense_decoder.hpp </li> <li>file robosense_info_decoder.hpp </li> <li>file robosense_info_decoder_base.hpp </li> <li>file robosense_packet.hpp </li> <li>file robosense_scan_decoder.hpp </li> <li>file robosense_sensor.hpp </li> </ul> </li> <li>file robosense_driver.hpp </li> <li>file robosense_info_driver.hpp </li> </ul> </li> <li>dir nebula_decoders_velodyne <ul> <li>dir decoders <ul> <li>file velodyne_scan_decoder.hpp </li> <li>file vlp16_decoder.hpp </li> <li>file vlp32_decoder.hpp </li> <li>file vls128_decoder.hpp </li> </ul> </li> <li>file velodyne_driver.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/namespaceboost_1_1endian/","title":"Namespace boost::endian","text":"<p>Namespace List &gt; endian</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_decoders/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#namespaces","title":"Namespaces","text":"Type Name namespace hesai_packet namespace robosense_packet namespace vlp16 namespace vlp32 namespace vls128"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name class AngleCorrector Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. class AngleCorrectorCalibrationBased &lt;ChannelN, AngleUnit&gt; class AngleCorrectorCorrectionBased &lt;ChannelN, AngleUnit&gt; class BpearlV3 class BpearlV4 struct CorrectedAngleData class Helios class HesaiDecoder &lt;typename SensorT&gt; class HesaiDriver Hesai driver. class HesaiScanDecoder Base class for Hesai LiDAR decoder. class HesaiSensor &lt;typename PacketT, AngleCorrection&gt;Base class for all sensor definitions. class NebulaDriverBase Base class for each sensor driver. class Pandar128E3X class Pandar128E4X class Pandar40 class Pandar64 class PandarAT128 class PandarQT128 class PandarQT64 class PandarXT32 class PandarXT32M class RobosenseDecoder &lt;typename SensorT&gt; class RobosenseDriver Robosense driver. class RobosenseInfoDecoder &lt;typename SensorT&gt; class RobosenseInfoDecoderBase class RobosenseInfoDriver Robosense driver. class RobosenseScanDecoder Base class for Robosense LiDAR decoder. class RobosenseSensor &lt;typename PacketT, typename InfoPacketT&gt;Base class for all sensor definitions. class VelodyneDriver Velodyne driver. class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. struct raw_block Raw Velodyne data block. struct raw_packet Raw Velodyne packet."},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-types","title":"Public Types","text":"Type Name enum AngleCorrectionType enum RETURN_TYPE Velodyne echo types. union two_bytes typedef struct nebula::drivers::raw_block raw_block_t Raw Velodyne data block. typedef struct nebula::drivers::raw_packet raw_packet_t Raw Velodyne packet."},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int BLOCKS_PER_PACKET   = = 12 const int BLOCK_DATA_SIZE   = = (SCANS_PER_BLOCK * RAW_SCAN_SIZE) const uint16_t LOWER_BANK   = = 0xddff const int PACKET_SIZE   = = 1206 const int PACKET_STATUS_SIZE   = = 4 const int RAW_SCAN_SIZE   = = 3 const uint16_t RETURN_MODE_DUAL   = = 57 const size_t RETURN_MODE_INDEX   = = 1204 const uint16_t RETURN_MODE_LAST   = = 56 const uint16_t RETURN_MODE_STRONGEST   = = 55 const uint16_t ROTATION_MAX_UNITS   = = 36000u const double ROTATION_RESOLUTION   = = 0.01 const int SCANS_PER_BLOCK   = = 32 const int SCANS_PER_PACKET   = = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET) const int SIZE_BLOCK   = = 100 const uint16_t UPPER_BANK   = = 0xeeff const float VLP128_DISTANCE_RESOLUTION   = = 0.004f const float VLP16_BLOCK_DURATION   = = 110.592f const float VLP16_DSR_TOFFSET   = = 2.304f const int VLP16_FIRINGS_PER_BLOCK   = = 2 const float VLP16_FIRING_TOFFSET   = = 55.296f const int VLP16_SCANS_PER_FIRING   = = 16 const uint16_t VLS128_BANK_1   = = 0xeeff const uint16_t VLS128_BANK_2   = = 0xddff const uint16_t VLS128_BANK_3   = = 0xccff const uint16_t VLS128_BANK_4   = = 0xbbff const float VLS128_CHANNEL_DURATION   = = 2.665f const float VLS128_SEQ_DURATION   = = 53.3f"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers/#enum-anglecorrectiontype","title":"enum AngleCorrectionType","text":"<pre><code>enum nebula::drivers::AngleCorrectionType {\n    CALIBRATION,\n    CORRECTION\n};\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#enum-return_type","title":"enum RETURN_TYPE","text":"<pre><code>enum nebula::drivers::RETURN_TYPE {\n    INVALID = 0,\n    SINGLE_STRONGEST = 1,\n    SINGLE_LAST = 2,\n    DUAL_STRONGEST_FIRST = 3,\n    DUAL_STRONGEST_LAST = 4,\n    DUAL_WEAK_FIRST = 5,\n    DUAL_WEAK_LAST = 6,\n    DUAL_ONLY = 7\n};\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#union-two_bytes","title":"union two_bytes","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#typedef-raw_block_t","title":"typedef raw_block_t","text":"<p>Raw Velodyne data block. <pre><code>typedef struct nebula::drivers::raw_block nebula::drivers::raw_block_t;\n</code></pre></p> <p>Each block contains data from either the upper or lower laser bank. The device returns three times as many upper bank blocks.</p> <p>use stdint.h types, so things work with both 64 and 32-bit machines </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#typedef-raw_packet_t","title":"typedef raw_packet_t","text":"<p>Raw Velodyne packet. <pre><code>typedef struct nebula::drivers::raw_packet nebula::drivers::raw_packet_t;\n</code></pre></p> <p>revolution is described in the device manual as incrementing (mod 65536) for each physical turn of the device. Our device seems to alternate between two different values every third packet. One value increases, the other decreases.</p> <p>Todo</p> <p>figure out if revolution is only present for one of the two types of status fields</p> <p>status has either a temperature encoding or the microcode level </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>const int nebula::drivers::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-block_data_size","title":"variable BLOCK_DATA_SIZE","text":"<pre><code>const int nebula::drivers::BLOCK_DATA_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-lower_bank","title":"variable LOWER_BANK","text":"<pre><code>const uint16_t nebula::drivers::LOWER_BANK;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>const int nebula::drivers::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-packet_status_size","title":"variable PACKET_STATUS_SIZE","text":"<pre><code>const int nebula::drivers::PACKET_STATUS_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-raw_scan_size","title":"variable RAW_SCAN_SIZE","text":"<pre><code>const int nebula::drivers::RAW_SCAN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_dual","title":"variable RETURN_MODE_DUAL","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_DUAL;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_index","title":"variable RETURN_MODE_INDEX","text":"<pre><code>const size_t nebula::drivers::RETURN_MODE_INDEX;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_last","title":"variable RETURN_MODE_LAST","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_LAST;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_strongest","title":"variable RETURN_MODE_STRONGEST","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_STRONGEST;\n</code></pre> <p>Return Modes </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-rotation_max_units","title":"variable ROTATION_MAX_UNITS","text":"<pre><code>const uint16_t nebula::drivers::ROTATION_MAX_UNITS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-rotation_resolution","title":"variable ROTATION_RESOLUTION","text":"<pre><code>const double nebula::drivers::ROTATION_RESOLUTION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-scans_per_block","title":"variable SCANS_PER_BLOCK","text":"<pre><code>const int nebula::drivers::SCANS_PER_BLOCK;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-scans_per_packet","title":"variable SCANS_PER_PACKET","text":"<pre><code>const int nebula::drivers::SCANS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-size_block","title":"variable SIZE_BLOCK","text":"<pre><code>const int nebula::drivers::SIZE_BLOCK;\n</code></pre> <p>Raw Velodyne packet constants and structures. </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-upper_bank","title":"variable UPPER_BANK","text":"<pre><code>const uint16_t nebula::drivers::UPPER_BANK;\n</code></pre> <p>Todo</p> <p>make this work for both big and little-endian machines </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp128_distance_resolution","title":"variable VLP128_DISTANCE_RESOLUTION","text":"<pre><code>const float nebula::drivers::VLP128_DISTANCE_RESOLUTION;\n</code></pre> <p>Special Definitions for VLS128 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_block_duration","title":"variable VLP16_BLOCK_DURATION","text":"<pre><code>const float nebula::drivers::VLP16_BLOCK_DURATION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_dsr_toffset","title":"variable VLP16_DSR_TOFFSET","text":"<pre><code>const float nebula::drivers::VLP16_DSR_TOFFSET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_firings_per_block","title":"variable VLP16_FIRINGS_PER_BLOCK","text":"<pre><code>const int nebula::drivers::VLP16_FIRINGS_PER_BLOCK;\n</code></pre> <p>Special Defines for VLP16 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_firing_toffset","title":"variable VLP16_FIRING_TOFFSET","text":"<pre><code>const float nebula::drivers::VLP16_FIRING_TOFFSET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_scans_per_firing","title":"variable VLP16_SCANS_PER_FIRING","text":"<pre><code>const int nebula::drivers::VLP16_SCANS_PER_FIRING;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_1","title":"variable VLS128_BANK_1","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_1;\n</code></pre> <p>Special Definitions for VLS128 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_2","title":"variable VLS128_BANK_2","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_2;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_3","title":"variable VLS128_BANK_3","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_3;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_4","title":"variable VLS128_BANK_4","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_4;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_channel_duration","title":"variable VLS128_CHANNEL_DURATION","text":"<pre><code>const float nebula::drivers::VLS128_CHANNEL_DURATION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_seq_duration","title":"variable VLS128_SEQ_DURATION","text":"<pre><code>const float nebula::drivers::VLS128_SEQ_DURATION;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/","title":"Class nebula::drivers::AngleCorrector","text":"<p>ClassList &gt; nebula &gt; drivers &gt; AngleCorrector</p> <p>Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. </p> <ul> <li><code>#include &lt;angle_corrector.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::AngleCorrectorCalibrationBased,  nebula::drivers::AngleCorrectorCalibrationBased,  nebula::drivers::AngleCorrectorCorrectionBased</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#public-functions","title":"Public Functions","text":"Type Name AngleCorrector (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  AngleCorrector (const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. virtual bool hasScanned (int current_azimuth, int last_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#protected-attributes","title":"Protected Attributes","text":"Type Name const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; HesaiCorrection &gt; sensor_correction_"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-anglecorrector-12","title":"function AngleCorrector [1/2]","text":"<pre><code>inline nebula::drivers::AngleCorrector::AngleCorrector (\n    const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-anglecorrector-22","title":"function AngleCorrector [2/2]","text":"<pre><code>inline explicit nebula::drivers::AngleCorrector::AngleCorrector (\n    const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-getcorrectedangledata-12","title":"function getCorrectedAngleData [1/2]","text":"<p>Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. <pre><code>virtual CorrectedAngleData nebula::drivers::AngleCorrector::getCorrectedAngleData (\n    uint32_t block_azimuth,\n    uint32_t channel_id\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_azimuth</code> The block's azimuth (including optional fine azimuth), in the sensor's angle unit </li> <li><code>channel_id</code> The laser channel's id </li> </ul> <p>Returns:</p> <p>The corrected angles (azimuth, elevation) in radians and their sin/cos values </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-getcorrectedangledata-12_1","title":"function getCorrectedAngleData [1/2]","text":"<p>Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. <pre><code>virtual CorrectedAngleData nebula::drivers::AngleCorrector::getCorrectedAngleData (\n    uint32_t block_azimuth,\n    uint32_t channel_id\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_azimuth</code> The block's azimuth (including optional fine azimuth), in the sensor's angle unit </li> <li><code>channel_id</code> The laser channel's id </li> </ul> <p>Returns:</p> <p>The corrected angles (azimuth, elevation) in radians and their sin/cos values </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-hasscanned-12","title":"function hasScanned [1/2]","text":"<p>Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. <pre><code>virtual bool nebula::drivers::AngleCorrector::hasScanned (\n    uint32_t current_azimuth,\n    uint32_t last_azimuth,\n    uint32_t sync_azimuth\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_azimuth</code> The current azimuth value in the sensor's angle resolution </li> <li><code>last_azimuth</code> The last azimuth in the sensor's angle resolution </li> <li><code>sync_azimuth</code> The azimuth set in the sensor configuration, for which the timestamp is aligned to the full second </li> </ul> <p>Returns:</p> <p>true if the current azimuth is in a different scan than the last one, false otherwise </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#function-hasscanned-22","title":"function hasScanned [2/2]","text":"<p>Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. <pre><code>virtual bool nebula::drivers::AngleCorrector::hasScanned (\n    int current_azimuth,\n    int last_azimuth\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_azimuth</code> The current azimuth value in the sensor's angle resolution </li> <li><code>last_azimuth</code> The last azimuth in the sensor's angle resolution </li> </ul> <p>Returns:</p> <p>true if the current azimuth is in a different scan than the last one, false otherwise </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#variable-sensor_calibration_-12","title":"variable sensor_calibration_ [1/2]","text":"<pre><code>const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; nebula::drivers::AngleCorrector::sensor_calibration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#variable-sensor_calibration_-22","title":"variable sensor_calibration_ [2/2]","text":"<pre><code>const std::shared_ptr&lt;RobosenseCalibrationConfiguration&gt; nebula::drivers::AngleCorrector::sensor_calibration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrector/#variable-sensor_correction_","title":"variable sensor_correction_","text":"<pre><code>const std::shared_ptr&lt;HesaiCorrection&gt; nebula::drivers::AngleCorrector::sensor_correction_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/","title":"Class nebula::drivers::AngleCorrectorCalibrationBased","text":"<p>template &lt;size_t ChannelN, size_t AngleUnit&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; AngleCorrectorCalibrationBased</p> <ul> <li><code>#include &lt;angle_corrector_calibration_based.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::AngleCorrector,  nebula::drivers::AngleCorrector</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#public-functions","title":"Public Functions","text":"Type Name AngleCorrectorCalibrationBased (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  AngleCorrectorCalibrationBased (const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) overrideGet the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) overrideGet the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) overrideReturns true if the current azimuth lies in a different (new) scan compared to the last azimuth. virtual bool hasScanned (int current_azimuth, int last_azimuth) overrideReturns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#public-functions-inherited-from-nebuladriversanglecorrector","title":"Public Functions inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name AngleCorrector (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  AngleCorrector (const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. virtual bool hasScanned (int current_azimuth, int last_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#public-functions-inherited-from-nebuladriversanglecorrector_1","title":"Public Functions inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name AngleCorrector (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  AngleCorrector (const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. virtual bool hasScanned (int current_azimuth, int last_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#protected-attributes-inherited-from-nebuladriversanglecorrector","title":"Protected Attributes inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; HesaiCorrection &gt; sensor_correction_"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#protected-attributes-inherited-from-nebuladriversanglecorrector_1","title":"Protected Attributes inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; HesaiCorrection &gt; sensor_correction_"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-anglecorrectorcalibrationbased-12","title":"function AngleCorrectorCalibrationBased [1/2]","text":"<pre><code>inline nebula::drivers::AngleCorrectorCalibrationBased::AngleCorrectorCalibrationBased (\n    const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-anglecorrectorcalibrationbased-22","title":"function AngleCorrectorCalibrationBased [2/2]","text":"<pre><code>inline explicit nebula::drivers::AngleCorrectorCalibrationBased::AngleCorrectorCalibrationBased (\n    const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-getcorrectedangledata-12","title":"function getCorrectedAngleData [1/2]","text":"<p>Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. <pre><code>inline virtual CorrectedAngleData nebula::drivers::AngleCorrectorCalibrationBased::getCorrectedAngleData (\n    uint32_t block_azimuth,\n    uint32_t channel_id\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_azimuth</code> The block's azimuth (including optional fine azimuth), in the sensor's angle unit </li> <li><code>channel_id</code> The laser channel's id </li> </ul> <p>Returns:</p> <p>The corrected angles (azimuth, elevation) in radians and their sin/cos values </p> <p>Implements nebula::drivers::AngleCorrector::getCorrectedAngleData</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-getcorrectedangledata-12_1","title":"function getCorrectedAngleData [1/2]","text":"<p>Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. <pre><code>inline virtual CorrectedAngleData nebula::drivers::AngleCorrectorCalibrationBased::getCorrectedAngleData (\n    uint32_t block_azimuth,\n    uint32_t channel_id\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_azimuth</code> The block's azimuth (including optional fine azimuth), in the sensor's angle unit </li> <li><code>channel_id</code> The laser channel's id </li> </ul> <p>Returns:</p> <p>The corrected angles (azimuth, elevation) in radians and their sin/cos values </p> <p>Implements nebula::drivers::AngleCorrector::getCorrectedAngleData</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-hasscanned-12","title":"function hasScanned [1/2]","text":"<p>Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. <pre><code>inline virtual bool nebula::drivers::AngleCorrectorCalibrationBased::hasScanned (\n    uint32_t current_azimuth,\n    uint32_t last_azimuth,\n    uint32_t sync_azimuth\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_azimuth</code> The current azimuth value in the sensor's angle resolution </li> <li><code>last_azimuth</code> The last azimuth in the sensor's angle resolution </li> <li><code>sync_azimuth</code> The azimuth set in the sensor configuration, for which the timestamp is aligned to the full second </li> </ul> <p>Returns:</p> <p>true if the current azimuth is in a different scan than the last one, false otherwise </p> <p>Implements nebula::drivers::AngleCorrector::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCalibrationBased/#function-hasscanned-22","title":"function hasScanned [2/2]","text":"<p>Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. <pre><code>inline virtual bool nebula::drivers::AngleCorrectorCalibrationBased::hasScanned (\n    int current_azimuth,\n    int last_azimuth\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_azimuth</code> The current azimuth value in the sensor's angle resolution </li> <li><code>last_azimuth</code> The last azimuth in the sensor's angle resolution </li> </ul> <p>Returns:</p> <p>true if the current azimuth is in a different scan than the last one, false otherwise </p> <p>Implements nebula::drivers::AngleCorrector::hasScanned</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_calibration_based.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/","title":"Class nebula::drivers::AngleCorrectorCorrectionBased","text":"<p>template &lt;size_t ChannelN, size_t AngleUnit&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; AngleCorrectorCorrectionBased</p> <ul> <li><code>#include &lt;angle_corrector_correction_based.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::AngleCorrector</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#public-functions","title":"Public Functions","text":"Type Name AngleCorrectorCorrectionBased (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) overrideGet the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) overrideReturns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#public-functions-inherited-from-nebuladriversanglecorrector","title":"Public Functions inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name AngleCorrector (const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction)  AngleCorrector (const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; sensor_calibration)  virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual CorrectedAngleData getCorrectedAngleData (uint32_t block_azimuth, uint32_t channel_id) = 0Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. virtual bool hasScanned (uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. virtual bool hasScanned (int current_azimuth, int last_azimuth) = 0Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#protected-attributes-inherited-from-nebuladriversanglecorrector","title":"Protected Attributes inherited from nebula::drivers::AngleCorrector","text":"<p>See nebula::drivers::AngleCorrector</p> Type Name const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; sensor_calibration_ const std::shared_ptr&lt; HesaiCorrection &gt; sensor_correction_"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#function-anglecorrectorcorrectionbased","title":"function AngleCorrectorCorrectionBased","text":"<pre><code>inline nebula::drivers::AngleCorrectorCorrectionBased::AngleCorrectorCorrectionBased (\n    const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt; HesaiCorrection &gt; &amp; sensor_correction\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#function-getcorrectedangledata","title":"function getCorrectedAngleData","text":"<p>Get the corrected azimuth and elevation for a given block and channel, along with their sin/cos values. <pre><code>inline virtual CorrectedAngleData nebula::drivers::AngleCorrectorCorrectionBased::getCorrectedAngleData (\n    uint32_t block_azimuth,\n    uint32_t channel_id\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_azimuth</code> The block's azimuth (including optional fine azimuth), in the sensor's angle unit </li> <li><code>channel_id</code> The laser channel's id </li> </ul> <p>Returns:</p> <p>The corrected angles (azimuth, elevation) in radians and their sin/cos values </p> <p>Implements nebula::drivers::AngleCorrector::getCorrectedAngleData</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1AngleCorrectorCorrectionBased/#function-hasscanned","title":"function hasScanned","text":"<p>Returns true if the current azimuth lies in a different (new) scan compared to the last azimuth. <pre><code>inline virtual bool nebula::drivers::AngleCorrectorCorrectionBased::hasScanned (\n    uint32_t current_azimuth,\n    uint32_t last_azimuth,\n    uint32_t sync_azimuth\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_azimuth</code> The current azimuth value in the sensor's angle resolution </li> <li><code>last_azimuth</code> The last azimuth in the sensor's angle resolution </li> <li><code>sync_azimuth</code> The azimuth set in the sensor configuration, for which the timestamp is aligned to the full second </li> </ul> <p>Returns:</p> <p>true if the current azimuth is in a different scan than the last one, false otherwise </p> <p>Implements nebula::drivers::AngleCorrector::hasScanned</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_correction_based.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/","title":"Class nebula::drivers::BpearlV3","text":"<p>ClassList &gt; nebula &gt; drivers &gt; BpearlV3</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::RobosenseSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-types-inherited-from-nebuladriversrobosensesensor","title":"Public Types inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name typedef class AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; angle_corrector_t typedef InfoPacketT info_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 30.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 1152000 constexpr float MIN_RANGE   = = 0.1f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (const uint32_t block_id, const uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnMode getReturnMode (const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)  RobosenseCalibrationConfiguration getSensorCalibration (const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)  std::map&lt; std::string, std::string &gt; getSensorInfo (const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)  bool getSyncStatus (const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name RobosenseSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~RobosenseSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-static-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Static Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name bool is_duplicate (uint32_t return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Whether the unit given by return_idx is a duplicate of any other unit in return_units."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::BpearlV3::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::BpearlV3::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::BpearlV3::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::BpearlV3::getPacketRelativePointTimeOffset (\n    const uint32_t block_id,\n    const uint32_t channel_id,\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>sensor_configuration</code> The sensor configuration </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::RobosenseSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#function-getreturnmode","title":"function getReturnMode","text":"<pre><code>inline ReturnMode nebula::drivers::BpearlV3::getReturnMode (\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#function-getsensorcalibration","title":"function getSensorCalibration","text":"<pre><code>inline RobosenseCalibrationConfiguration nebula::drivers::BpearlV3::getSensorCalibration (\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#function-getsensorinfo","title":"function getSensorInfo","text":"<pre><code>inline std::map&lt; std::string, std::string &gt; nebula::drivers::BpearlV3::getSensorInfo (\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV3/#function-getsyncstatus","title":"function getSyncStatus","text":"<pre><code>inline bool nebula::drivers::BpearlV3::getSyncStatus (\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/","title":"Class nebula::drivers::BpearlV4","text":"<p>ClassList &gt; nebula &gt; drivers &gt; BpearlV4</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::RobosenseSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-types-inherited-from-nebuladriversrobosensesensor","title":"Public Types inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name typedef class AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; angle_corrector_t typedef InfoPacketT info_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 30.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 1152000 constexpr float MIN_RANGE   = = 0.1f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (const uint32_t block_id, const uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnMode getReturnMode (const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)  RobosenseCalibrationConfiguration getSensorCalibration (const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)  std::map&lt; std::string, std::string &gt; getSensorInfo (const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)  bool getSyncStatus (const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name RobosenseSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~RobosenseSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-static-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Static Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name bool is_duplicate (uint32_t return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Whether the unit given by return_idx is a duplicate of any other unit in return_units."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::BpearlV4::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::BpearlV4::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::BpearlV4::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::BpearlV4::getPacketRelativePointTimeOffset (\n    const uint32_t block_id,\n    const uint32_t channel_id,\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>sensor_configuration</code> The sensor configuration </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::RobosenseSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#function-getreturnmode","title":"function getReturnMode","text":"<pre><code>inline ReturnMode nebula::drivers::BpearlV4::getReturnMode (\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#function-getsensorcalibration","title":"function getSensorCalibration","text":"<pre><code>inline RobosenseCalibrationConfiguration nebula::drivers::BpearlV4::getSensorCalibration (\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#function-getsensorinfo","title":"function getSensorInfo","text":"<pre><code>inline std::map&lt; std::string, std::string &gt; nebula::drivers::BpearlV4::getSensorInfo (\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1BpearlV4/#function-getsyncstatus","title":"function getSyncStatus","text":"<pre><code>inline bool nebula::drivers::BpearlV4::getSyncStatus (\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/","title":"Struct nebula::drivers::CorrectedAngleData","text":"<p>ClassList &gt; nebula &gt; drivers &gt; CorrectedAngleData</p> <ul> <li><code>#include &lt;angle_corrector.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#public-attributes","title":"Public Attributes","text":"Type Name float azimuth_rad uint16_t corrected_channel_id float cos_azimuth float cos_elevation float elevation_rad float sin_azimuth float sin_elevation"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-azimuth_rad","title":"variable azimuth_rad","text":"<pre><code>float nebula::drivers::CorrectedAngleData::azimuth_rad;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-corrected_channel_id","title":"variable corrected_channel_id","text":"<pre><code>uint16_t nebula::drivers::CorrectedAngleData::corrected_channel_id;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-cos_azimuth","title":"variable cos_azimuth","text":"<pre><code>float nebula::drivers::CorrectedAngleData::cos_azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-cos_elevation","title":"variable cos_elevation","text":"<pre><code>float nebula::drivers::CorrectedAngleData::cos_elevation;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-elevation_rad","title":"variable elevation_rad","text":"<pre><code>float nebula::drivers::CorrectedAngleData::elevation_rad;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-sin_azimuth","title":"variable sin_azimuth","text":"<pre><code>float nebula::drivers::CorrectedAngleData::sin_azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1CorrectedAngleData/#variable-sin_elevation","title":"variable sin_elevation","text":"<pre><code>float nebula::drivers::CorrectedAngleData::sin_elevation;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/","title":"Class nebula::drivers::Helios","text":"<p>ClassList &gt; nebula &gt; drivers &gt; Helios</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::RobosenseSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-types-inherited-from-nebuladriversrobosensesensor","title":"Public Types inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name typedef class AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; angle_corrector_t typedef InfoPacketT info_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 150.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 1152000 constexpr float MIN_RANGE   = = 0.2f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (const uint32_t block_id, const uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnMode getReturnMode (const robosense_packet::helios::InfoPacket &amp; info_packet)  RobosenseCalibrationConfiguration getSensorCalibration (const robosense_packet::helios::InfoPacket &amp; info_packet)  std::map&lt; std::string, std::string &gt; getSensorInfo (const robosense_packet::helios::InfoPacket &amp; info_packet)  bool getSyncStatus (const robosense_packet::helios::InfoPacket &amp; info_packet)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name RobosenseSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~RobosenseSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-static-functions-inherited-from-nebuladriversrobosensesensor","title":"Public Static Functions inherited from nebula::drivers::RobosenseSensor","text":"<p>See nebula::drivers::RobosenseSensor</p> Type Name bool is_duplicate (uint32_t return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Whether the unit given by return_idx is a duplicate of any other unit in return_units."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::Helios::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::Helios::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::Helios::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::Helios::getPacketRelativePointTimeOffset (\n    const uint32_t block_id,\n    const uint32_t channel_id,\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>sensor_configuration</code> The sensor configuration </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::RobosenseSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#function-getreturnmode","title":"function getReturnMode","text":"<pre><code>inline ReturnMode nebula::drivers::Helios::getReturnMode (\n    const robosense_packet::helios::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#function-getsensorcalibration","title":"function getSensorCalibration","text":"<pre><code>inline RobosenseCalibrationConfiguration nebula::drivers::Helios::getSensorCalibration (\n    const robosense_packet::helios::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#function-getsensorinfo","title":"function getSensorInfo","text":"<pre><code>inline std::map&lt; std::string, std::string &gt; nebula::drivers::Helios::getSensorInfo (\n    const robosense_packet::helios::InfoPacket &amp; info_packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Helios/#function-getsyncstatus","title":"function getSyncStatus","text":"<pre><code>inline bool nebula::drivers::Helios::getSyncStatus (\n    const robosense_packet::helios::InfoPacket &amp; info_packet\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/","title":"Class nebula::drivers::HesaiDecoder","text":"<p>template &lt;typename SensorT typename SensorT&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; HesaiDecoder</p> <ul> <li><code>#include &lt;hesai_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#public-functions","title":"Public Functions","text":"Type Name HesaiDecoder (const std::shared_ptr&lt; HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; calibration_configuration, const std::shared_ptr&lt; HesaiCorrection &gt; &amp; correction_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () overrideReturns the point cloud and timestamp of the last scan. virtual bool hasScanned () overrideIndicates whether one full scan is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideParses PandarPacket and add its points to the point cloud."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () = 0Returns the point cloud and timestamp of the last scan. virtual bool hasScanned () = 0Indicates whether one full scan is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Parses PandarPacket and add its points to the point cloud. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name SensorT::angle_corrector_t angle_corrector_ Decodes azimuth/elevation angles given calibration/correction data. std::array&lt; std::array&lt; int, SensorT::packet_t::N_BLOCKS &gt;, SensorT::packet_t::MAX_RETURNS &gt; block_firing_offset_ns_ For each return mode, the firing offset of each block relative to its packet in nanoseconds. std::array&lt; int, SensorT::packet_t::N_CHANNELS &gt; channel_firing_offset_ns_ For each channel, its firing offset relative to the block in nanoseconds. NebulaPointCloudPtr decode_pc_ The point cloud new points get added to. uint64_t decode_scan_timestamp_ns_ The timestamp of the scan currently in progress. bool has_scanned_ Whether a full scan has been processed. int last_phase_ The last azimuth processed. rclcpp::Logger logger_ NebulaPointCloudPtr output_pc_ The point cloud that is returned when a scan is complete. uint64_t output_scan_timestamp_ns_ The timestamp of the last completed scan in nanoseconds. SensorT::packet_t packet_ The last decoded packet. SensorT sensor_   = {}The sensor definition, used for return mode and time offset handling. const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ Configuration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#protected-functions","title":"Protected Functions","text":"Type Name bool checkScanCompleted (uint32_t current_phase, uint32_t sync_phase) Checks whether the last processed block was the last block of a scan. void convertReturns (size_t start_block_id, size_t n_blocks) Converts a group of returns (i.e. 1 for single return, 2 for dual return, etc.) to points and appends them to the point cloud. float getDistance (const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit) Get the distance of the given unit in meters. uint32_t getPointTimeRelative (uint64_t packet_timestamp_ns, size_t block_id, size_t channel_id) Get timestamp of point in nanoseconds, relative to scan timestamp. Includes firing time offset correction for channel and block. bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) Validates and parse PandarPacket. Currently only checks size, not checksums etc."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-hesaidecoder","title":"function HesaiDecoder","text":"<p>Constructor. <pre><code>inline explicit nebula::drivers::HesaiDecoder::HesaiDecoder (\n    const std::shared_ptr&lt; HesaiSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; HesaiCalibrationConfiguration &gt; &amp; calibration_configuration,\n    const std::shared_ptr&lt; HesaiCorrection &gt; &amp; correction_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder (can be nullptr if correction_configuration is set) </li> <li><code>correction_configuration</code> Correction for this decoder (can be nullptr if calibration_configuration is set) </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-getpointcloud","title":"function getPointcloud","text":"<p>Returns the point cloud and timestamp of the last scan. <pre><code>inline virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::HesaiDecoder::getPointcloud () override\n</code></pre></p> <p>Returns:</p> <p>A tuple of point cloud and timestamp in nanoseconds </p> <p>Implements nebula::drivers::HesaiScanDecoder::getPointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Indicates whether one full scan is ready. <pre><code>inline virtual bool nebula::drivers::HesaiDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Whether a scan is ready </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-unpack","title":"function unpack","text":"<p>Parses PandarPacket and add its points to the point cloud. <pre><code>inline virtual int nebula::drivers::HesaiDecoder::unpack (\n    const pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> The incoming PandarPacket </li> </ul> <p>Returns:</p> <p>The last azimuth processed </p> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-angle_corrector_","title":"variable angle_corrector_","text":"<pre><code>SensorT::angle_corrector_t nebula::drivers::HesaiDecoder&lt; SensorT &gt;::angle_corrector_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-block_firing_offset_ns_","title":"variable block_firing_offset_ns_","text":"<pre><code>std::array&lt;std::array&lt;int, SensorT::packet_t::N_BLOCKS&gt;, SensorT::packet_t::MAX_RETURNS&gt; nebula::drivers::HesaiDecoder&lt; SensorT &gt;::block_firing_offset_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-channel_firing_offset_ns_","title":"variable channel_firing_offset_ns_","text":"<pre><code>std::array&lt;int, SensorT::packet_t::N_CHANNELS&gt; nebula::drivers::HesaiDecoder&lt; SensorT &gt;::channel_firing_offset_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-decode_pc_","title":"variable decode_pc_","text":"<pre><code>NebulaPointCloudPtr nebula::drivers::HesaiDecoder&lt; SensorT &gt;::decode_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-decode_scan_timestamp_ns_","title":"variable decode_scan_timestamp_ns_","text":"<pre><code>uint64_t nebula::drivers::HesaiDecoder&lt; SensorT &gt;::decode_scan_timestamp_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-has_scanned_","title":"variable has_scanned_","text":"<pre><code>bool nebula::drivers::HesaiDecoder&lt; SensorT &gt;::has_scanned_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-last_phase_","title":"variable last_phase_","text":"<pre><code>int nebula::drivers::HesaiDecoder&lt; SensorT &gt;::last_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-logger_","title":"variable logger_","text":"<pre><code>rclcpp::Logger nebula::drivers::HesaiDecoder&lt; SensorT &gt;::logger_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-output_pc_","title":"variable output_pc_","text":"<pre><code>NebulaPointCloudPtr nebula::drivers::HesaiDecoder&lt; SensorT &gt;::output_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-output_scan_timestamp_ns_","title":"variable output_scan_timestamp_ns_","text":"<pre><code>uint64_t nebula::drivers::HesaiDecoder&lt; SensorT &gt;::output_scan_timestamp_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-packet_","title":"variable packet_","text":"<pre><code>SensorT::packet_t nebula::drivers::HesaiDecoder&lt; SensorT &gt;::packet_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-sensor_","title":"variable sensor_","text":"<pre><code>SensorT nebula::drivers::HesaiDecoder&lt; SensorT &gt;::sensor_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#variable-sensor_configuration_","title":"variable sensor_configuration_","text":"<pre><code>const std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; nebula::drivers::HesaiDecoder&lt; SensorT &gt;::sensor_configuration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-checkscancompleted","title":"function checkScanCompleted","text":"<p>Checks whether the last processed block was the last block of a scan. <pre><code>inline bool nebula::drivers::HesaiDecoder::checkScanCompleted (\n    uint32_t current_phase,\n    uint32_t sync_phase\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_phase</code> The azimuth of the last processed block </li> <li><code>sync_phase</code> The azimuth set in the sensor configuration, for which the timestamp is aligned to the full second </li> </ul> <p>Returns:</p> <p>Whether the scan has completed </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-convertreturns","title":"function convertReturns","text":"<p>Converts a group of returns (i.e. 1 for single return, 2 for dual return, etc.) to points and appends them to the point cloud. <pre><code>inline void nebula::drivers::HesaiDecoder::convertReturns (\n    size_t start_block_id,\n    size_t n_blocks\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>start_block_id</code> The first block in the group of returns </li> <li><code>n_blocks</code> The number of returns in the group (has to align with the <code>n_returns</code> field in the packet footer) </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-getdistance","title":"function getDistance","text":"<pre><code>inline float nebula::drivers::HesaiDecoder::getDistance (\n    const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-getpointtimerelative","title":"function getPointTimeRelative","text":"<p>Get timestamp of point in nanoseconds, relative to scan timestamp. Includes firing time offset correction for channel and block. <pre><code>inline uint32_t nebula::drivers::HesaiDecoder::getPointTimeRelative (\n    uint64_t packet_timestamp_ns,\n    size_t block_id,\n    size_t channel_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>packet_timestamp_ns</code> The timestamp of the current PandarPacket in nanoseconds </li> <li><code>block_id</code> The block index of the point </li> <li><code>channel_id</code> The channel index of the point </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Validates and parse PandarPacket. Currently only checks size, not checksums etc. <pre><code>inline bool nebula::drivers::HesaiDecoder::parsePacket (\n    const pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> The incoming PandarPacket </li> </ul> <p>Returns:</p> <p>Whether the packet was parsed successfully </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/","title":"Class nebula::drivers::HesaiDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiDriver</p> <p>Hesai driver. </p> <ul> <li><code>#include &lt;hesai_driver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaDriverBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions","title":"Public Functions","text":"Type Name std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; ConvertScanToPointcloud (const std::shared_ptr&lt; pandar_msgs::msg::PandarScan &gt; &amp; pandar_scan) Convert PandarScan message to point cloud. Status GetStatus () Get current status of this driver. HesaiDriver () = delete HesaiDriver (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration, const std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration=nullptr) Constructor. virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) overrideSetting CalibrationConfiguration (not used)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions-inherited-from-nebuladriversnebuladriverbase","title":"Public Functions inherited from nebula::drivers::NebulaDriverBase","text":"<p>See nebula::drivers::NebulaDriverBase</p> Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-convertscantopointcloud","title":"function ConvertScanToPointcloud","text":"<p>Convert PandarScan message to point cloud. <pre><code>std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::HesaiDriver::ConvertScanToPointcloud (\n    const std::shared_ptr&lt; pandar_msgs::msg::PandarScan &gt; &amp; pandar_scan\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_scan</code> Message </li> </ul> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::HesaiDriver::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-hesaidriver-12","title":"function HesaiDriver [1/2]","text":"<pre><code>nebula::drivers::HesaiDriver::HesaiDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-hesaidriver-22","title":"function HesaiDriver [2/2]","text":"<p>Constructor. <pre><code>explicit nebula::drivers::HesaiDriver::HesaiDriver (\n    const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration,\n    const std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration=nullptr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> <li><code>calibration_configuration</code> CalibrationConfiguration for this driver </li> <li><code>correction_configuration</code> CorrectionConfiguration for this driver (for AT) </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Setting CalibrationConfiguration (not used) <pre><code>virtual Status nebula::drivers::HesaiDriver::SetCalibrationConfiguration (\n    const CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/","title":"Class nebula::drivers::HesaiScanDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiScanDecoder</p> <p>Base class for Hesai LiDAR decoder. </p> <ul> <li><code>#include &lt;hesai_scan_decoder.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#public-functions","title":"Public Functions","text":"Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () = 0Returns the point cloud and timestamp of the last scan. virtual bool hasScanned () = 0Indicates whether one full scan is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Parses PandarPacket and add its points to the point cloud. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-13","title":"function HesaiScanDecoder [1/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder (\n    HesaiScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-23","title":"function HesaiScanDecoder [2/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder (\n    const HesaiScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-33","title":"function HesaiScanDecoder [3/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-getpointcloud","title":"function getPointcloud","text":"<p>Returns the point cloud and timestamp of the last scan. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::HesaiScanDecoder::getPointcloud () = 0\n</code></pre></p> <p>Returns:</p> <p>A tuple of point cloud and timestamp in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Indicates whether one full scan is ready. <pre><code>virtual bool nebula::drivers::HesaiScanDecoder::hasScanned () = 0\n</code></pre></p> <p>Returns:</p> <p>Whether a scan is ready </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-operator","title":"function operator=","text":"<pre><code>HesaiScanDecoder &amp; nebula::drivers::HesaiScanDecoder::operator= (\n    HesaiScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-operator_1","title":"function operator=","text":"<pre><code>HesaiScanDecoder &amp; nebula::drivers::HesaiScanDecoder::operator= (\n    const HesaiScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-unpack","title":"function unpack","text":"<p>Parses PandarPacket and add its points to the point cloud. <pre><code>virtual int nebula::drivers::HesaiScanDecoder::unpack (\n    const pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> The incoming PandarPacket </li> </ul> <p>Returns:</p> <p>The last azimuth processed </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder","title":"function ~HesaiScanDecoder","text":"<pre><code>virtual nebula::drivers::HesaiScanDecoder::~HesaiScanDecoder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/","title":"Class nebula::drivers::HesaiSensor","text":"<p>template &lt;typename PacketT typename PacketT, AngleCorrectionType AngleCorrection&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; HesaiSensor</p> <p>Base class for all sensor definitions. More...</p> <ul> <li><code>#include &lt;hesai_sensor.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#public-types","title":"Public Types","text":"Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#public-functions","title":"Public Functions","text":"Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type of the sensor </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#typedef-angle_corrector_t","title":"typedef angle_corrector_t","text":"<pre><code>typedef std::conditional&lt; (AngleCorrection == AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt;PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS&gt;, AngleCorrectorCorrectionBased&lt;PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS&gt; &gt;::type nebula::drivers::HesaiSensor&lt; PacketT, AngleCorrection &gt;::angle_corrector_t;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#typedef-packet_t","title":"typedef packet_t","text":"<pre><code>typedef PacketT nebula::drivers::HesaiSensor&lt; PacketT, AngleCorrection &gt;::packet_t;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#function-hesaisensor","title":"function HesaiSensor","text":"<pre><code>nebula::drivers::HesaiSensor::HesaiSensor () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#function-getearliestpointtimeoffsetforblock","title":"function getEarliestPointTimeOffsetForBlock","text":"<p>For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. <pre><code>inline int nebula::drivers::HesaiSensor::getEarliestPointTimeOffsetForBlock (\n    uint32_t start_block_id,\n    const PacketT &amp; packet\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>start_block_id</code> The index of the block in and after which to consider points </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The lowest point time offset (relative to the packet timestamp) of any point in or after the start block, in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>virtual int nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const PacketT &amp; packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#function-getreturntype","title":"function getReturnType","text":"<p>Get the return type of the point given by return_idx. <pre><code>inline virtual ReturnType nebula::drivers::HesaiSensor::getReturnType (\n    hesai_packet::return_mode::ReturnMode return_mode,\n    unsigned int return_idx,\n    const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units\n) \n</code></pre></p> <p>For duplicate points, the return type is reported as ReturnType::IDENTICAL for all identical points. For DUAL_LAST_STRONGEST and DUAL_FIRST_STRONGEST, if the last/first point is also the strongest, it will be returned as ReturnType::LAST_STRONGEST / ReturnType::FIRST_STRONGEST respectively, with the second point being reported as ReturnType::SECONDSTRONGEST.</p> <p>Parameters:</p> <ul> <li><code>return_mode</code> The sensor's currently active return mode </li> <li><code>return_idx</code> The block index of the point within the group of blocks that make up the return group (e.g. either 0 or 1 for dual return) </li> <li><code>return_units</code> The units corresponding to all the returns in the group. These are usually from the same column across adjascent blocks. </li> </ul> <p>Returns:</p> <p>The return type of the point </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiSensor/#function-hesaisensor_1","title":"function ~HesaiSensor","text":"<pre><code>virtual nebula::drivers::HesaiSensor::~HesaiSensor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/","title":"Class nebula::drivers::NebulaDriverBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; NebulaDriverBase</p> <p>Base class for each sensor driver. </p> <ul> <li><code>#include &lt;nebula_driver_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiDriver,  nebula::drivers::RobosenseDriver,  nebula::drivers::VelodyneDriver</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#public-functions","title":"Public Functions","text":"Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-13","title":"function NebulaDriverBase [1/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase (\n    NebulaDriverBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-23","title":"function NebulaDriverBase [2/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase (\n    const NebulaDriverBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-33","title":"function NebulaDriverBase [3/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Virtual function for setting calibration configuration. <pre><code>virtual Status nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration (\n    const CalibrationConfigurationBase &amp; calibration_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration including file path </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaDriverBase &amp; nebula::drivers::NebulaDriverBase::operator= (\n    NebulaDriverBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaDriverBase &amp; nebula::drivers::NebulaDriverBase::operator= (\n    const NebulaDriverBase &amp; c\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/","title":"Class nebula::drivers::Pandar128E3X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; Pandar128E3X</p> <ul> <li><code>#include &lt;pandar_128e3x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 230.0 constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 691200 constexpr float MIN_RANGE   = = 0.1"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units) override"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar128E3X::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::Pandar128E3X::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar128E3X::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::Pandar128E3X::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E3X/#function-getreturntype","title":"function getReturnType","text":"<pre><code>inline ReturnType nebula::drivers::Pandar128E3X::getReturnType (\n    hesai_packet::return_mode::ReturnMode return_mode,\n    unsigned int return_idx,\n    const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/","title":"Class nebula::drivers::Pandar128E4X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; Pandar128E4X</p> <ul> <li><code>#include &lt;pandar_128e4x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 230.0 constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 691200 constexpr float MIN_RANGE   = = 0.1"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units) override"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar128E4X::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::Pandar128E4X::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar128E4X::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::Pandar128E4X::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar128E4X/#function-getreturntype","title":"function getReturnType","text":"<pre><code>inline ReturnType nebula::drivers::Pandar128E4X::getReturnType (\n    hesai_packet::return_mode::ReturnMode return_mode,\n    unsigned int return_idx,\n    const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e4x.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/","title":"Class nebula::drivers::Pandar40","text":"<p>ClassList &gt; nebula &gt; drivers &gt; Pandar40</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 200.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 144000 constexpr float MIN_RANGE   = = 0.3f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar40::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::Pandar40::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar40::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar40/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::Pandar40::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/","title":"Class nebula::drivers::Pandar64","text":"<p>ClassList &gt; nebula &gt; drivers &gt; Pandar64</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 200.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 230400 constexpr float MIN_RANGE   = = 0.3f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar64::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::Pandar64::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::Pandar64::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1Pandar64/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::Pandar64::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/","title":"Class nebula::drivers::PandarAT128","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PandarAT128</p> <ul> <li><code>#include &lt;pandar_at128.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 180.0f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 307200 constexpr float MIN_RANGE   = = 1.f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarAT128::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::PandarAT128::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarAT128::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarAT128/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::PandarAT128::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at128.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/","title":"Class nebula::drivers::PandarQT128","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PandarQT128</p> <ul> <li><code>#include &lt;pandar_qt128.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 50.0 constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 172800 constexpr float MIN_RANGE   = = 0.05"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarQT128::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::PandarQT128::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarQT128::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT128/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::PandarQT128::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt128.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/","title":"Class nebula::drivers::PandarQT64","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PandarQT64</p> <ul> <li><code>#include &lt;pandar_qt64.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 60.f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 76800 constexpr float MIN_RANGE   = = 0.1f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarQT64::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::PandarQT64::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarQT64::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarQT64/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::PandarQT64::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt64.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/","title":"Class nebula::drivers::PandarXT32","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PandarXT32</p> <ul> <li><code>#include &lt;pandar_xt32.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 120.0f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 256000 constexpr float MIN_RANGE   = = 0.05f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units) override"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarXT32::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::PandarXT32::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarXT32::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::PandarXT32::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32/#function-getreturntype","title":"function getReturnType","text":"<pre><code>inline ReturnType nebula::drivers::PandarXT32::getReturnType (\n    hesai_packet::return_mode::ReturnMode return_mode,\n    unsigned int return_idx,\n    const std::vector&lt; const typename packet_t::body_t::block_t::unit_t * &gt; &amp; return_units\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/","title":"Class nebula::drivers::PandarXT32M","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PandarXT32M</p> <ul> <li><code>#include &lt;pandar_xt32m.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiSensor</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-types-inherited-from-nebuladrivershesaisensor","title":"Public Types inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name typedef std::conditional&lt;(AngleCorrection==AngleCorrectionType::CALIBRATION), AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt;, AngleCorrectorCorrectionBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; &gt;::type angle_corrector_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr float MAX_RANGE   = = 300.0f constexpr size_t MAX_SCAN_BUFFER_POINTS   = = 384000 constexpr float MIN_RANGE   = = 0.5f"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-functions","title":"Public Functions","text":"Type Name virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) overrideComputes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-functions-inherited-from-nebuladrivershesaisensor","title":"Public Functions inherited from nebula::drivers::HesaiSensor","text":"<p>See nebula::drivers::HesaiSensor</p> Type Name HesaiSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const PacketT &amp; packet) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~HesaiSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarXT32M::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#variable-max_scan_buffer_points","title":"variable MAX_SCAN_BUFFER_POINTS","text":"<pre><code>constexpr size_t nebula::drivers::PandarXT32M::MAX_SCAN_BUFFER_POINTS;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::PandarXT32M::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1PandarXT32M/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>inline virtual int nebula::drivers::PandarXT32M::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const packet_t &amp; packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>packet</code> The packet </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p> <p>Implements nebula::drivers::HesaiSensor::getPacketRelativePointTimeOffset</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32m.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/","title":"Class nebula::drivers::RobosenseDecoder","text":"<p>template &lt;typename SensorT typename SensorT&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; RobosenseDecoder</p> <ul> <li><code>#include &lt;robosense_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::RobosenseScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#public-functions","title":"Public Functions","text":"Type Name RobosenseDecoder (const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () overrideReturns the point cloud and timestamp of the last scan. virtual bool hasScanned () overrideIndicates whether one full scan is ready. virtual int unpack (const robosense_msgs::msg::RobosensePacket &amp; msop_packet) overrideParses RobosensePacket and add its points to the point cloud."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#public-functions-inherited-from-nebuladriversrobosensescandecoder","title":"Public Functions inherited from nebula::drivers::RobosenseScanDecoder","text":"<p>See nebula::drivers::RobosenseScanDecoder</p> Type Name RobosenseScanDecoder (RobosenseScanDecoder &amp;&amp; c) = delete RobosenseScanDecoder (const RobosenseScanDecoder &amp; c) = delete RobosenseScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () = 0Returns the point cloud and timestamp of the last scan. virtual bool hasScanned () = 0Indicates whether one full scan is ready. RobosenseScanDecoder &amp; operator= (RobosenseScanDecoder &amp;&amp; c) = delete RobosenseScanDecoder &amp; operator= (const RobosenseScanDecoder &amp; c) = delete virtual int unpack (const robosense_msgs::msg::RobosensePacket &amp; msop_packet) = 0Parses RobosensePacket and add its points to the point cloud. virtual ~RobosenseScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name SensorT::angle_corrector_t angle_corrector_ Decodes azimuth/elevation angles given calibration/correction data. NebulaPointCloudPtr decode_pc_ The point cloud new points get added to. uint64_t decode_scan_timestamp_ns_ The timestamp of the scan currently in progress. bool has_scanned_ Whether a full scan has been processed. int last_phase_ The last azimuth processed. rclcpp::Logger logger_ NebulaPointCloudPtr output_pc_ The point cloud that is returned when a scan is complete. uint64_t output_scan_timestamp_ns_ The timestamp of the last completed scan in nanoseconds. SensorT::packet_t packet_ The last decoded packet. SensorT sensor_   = {}The sensor definition, used for return mode and time offset handling. const std::shared_ptr&lt; drivers::RobosenseSensorConfiguration &gt; sensor_configuration_ Configuration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#protected-functions","title":"Protected Functions","text":"Type Name bool checkScanCompleted (int current_phase) Checks whether the last processed block was the last block of a scan. void convertReturns (size_t start_block_id, size_t n_blocks) Converts a group of returns (i.e. 1 for single return, 2 for dual return, etc.) to points and appends them to the point cloud. float getDistance (const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit) Get the distance of the given unit in meters. uint32_t getPointTimeRelative (uint64_t packet_timestamp_ns, size_t block_id, size_t channel_id) Get timestamp of point in nanoseconds, relative to scan timestamp. Includes firing time offset correction for channel and block. bool parsePacket (const robosense_msgs::msg::RobosensePacket &amp; msop_packet) Validates and parses MsopPacket. Currently only checks size, not checksums etc."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-robosensedecoder","title":"function RobosenseDecoder","text":"<p>Constructor. <pre><code>inline explicit nebula::drivers::RobosenseDecoder::RobosenseDecoder (\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; RobosenseCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder calibration_configuration is set) </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-getpointcloud","title":"function getPointcloud","text":"<p>Returns the point cloud and timestamp of the last scan. <pre><code>inline virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::RobosenseDecoder::getPointcloud () override\n</code></pre></p> <p>Returns:</p> <p>A tuple of point cloud and timestamp in nanoseconds </p> <p>Implements nebula::drivers::RobosenseScanDecoder::getPointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Indicates whether one full scan is ready. <pre><code>inline virtual bool nebula::drivers::RobosenseDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Whether a scan is ready </p> <p>Implements nebula::drivers::RobosenseScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-unpack","title":"function unpack","text":"<p>Parses RobosensePacket and add its points to the point cloud. <pre><code>inline virtual int nebula::drivers::RobosenseDecoder::unpack (\n    const robosense_msgs::msg::RobosensePacket &amp; msop_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msop_packet</code> The incoming MsopPacket </li> </ul> <p>Returns:</p> <p>The last azimuth processed </p> <p>Implements nebula::drivers::RobosenseScanDecoder::unpack</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-angle_corrector_","title":"variable angle_corrector_","text":"<pre><code>SensorT::angle_corrector_t nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::angle_corrector_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-decode_pc_","title":"variable decode_pc_","text":"<pre><code>NebulaPointCloudPtr nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::decode_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-decode_scan_timestamp_ns_","title":"variable decode_scan_timestamp_ns_","text":"<pre><code>uint64_t nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::decode_scan_timestamp_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-has_scanned_","title":"variable has_scanned_","text":"<pre><code>bool nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::has_scanned_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-last_phase_","title":"variable last_phase_","text":"<pre><code>int nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::last_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-logger_","title":"variable logger_","text":"<pre><code>rclcpp::Logger nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::logger_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-output_pc_","title":"variable output_pc_","text":"<pre><code>NebulaPointCloudPtr nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::output_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-output_scan_timestamp_ns_","title":"variable output_scan_timestamp_ns_","text":"<pre><code>uint64_t nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::output_scan_timestamp_ns_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-packet_","title":"variable packet_","text":"<pre><code>SensorT::packet_t nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::packet_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-sensor_","title":"variable sensor_","text":"<pre><code>SensorT nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::sensor_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#variable-sensor_configuration_","title":"variable sensor_configuration_","text":"<pre><code>const std::shared_ptr&lt;drivers::RobosenseSensorConfiguration&gt; nebula::drivers::RobosenseDecoder&lt; SensorT &gt;::sensor_configuration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-checkscancompleted","title":"function checkScanCompleted","text":"<p>Checks whether the last processed block was the last block of a scan. <pre><code>inline bool nebula::drivers::RobosenseDecoder::checkScanCompleted (\n    int current_phase\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>current_phase</code> The azimuth of the last processed block </li> </ul> <p>Returns:</p> <p>Whether the scan has completed </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-convertreturns","title":"function convertReturns","text":"<p>Converts a group of returns (i.e. 1 for single return, 2 for dual return, etc.) to points and appends them to the point cloud. <pre><code>inline void nebula::drivers::RobosenseDecoder::convertReturns (\n    size_t start_block_id,\n    size_t n_blocks\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>start_block_id</code> The first block in the group of returns </li> <li><code>n_blocks</code> The number of returns in the group </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-getdistance","title":"function getDistance","text":"<p>Get the distance of the given unit in meters. <pre><code>inline float nebula::drivers::RobosenseDecoder::getDistance (\n    const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>unit</code> The unit to get the distance from </li> </ul> <p>Returns:</p> <p>The distance in meters </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-getpointtimerelative","title":"function getPointTimeRelative","text":"<p>Get timestamp of point in nanoseconds, relative to scan timestamp. Includes firing time offset correction for channel and block. <pre><code>inline uint32_t nebula::drivers::RobosenseDecoder::getPointTimeRelative (\n    uint64_t packet_timestamp_ns,\n    size_t block_id,\n    size_t channel_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>packet_timestamp_ns</code> The timestamp of the current MsopPacket in nanoseconds </li> <li><code>block_id</code> The block index of the point </li> <li><code>channel_id</code> The channel index of the point </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Validates and parses MsopPacket. Currently only checks size, not checksums etc. <pre><code>inline bool nebula::drivers::RobosenseDecoder::parsePacket (\n    const robosense_msgs::msg::RobosensePacket &amp; msop_packet\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msop_packet</code> The incoming MsopPacket </li> </ul> <p>Returns:</p> <p>Whether the packet was parsed successfully </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/","title":"Class nebula::drivers::RobosenseDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseDriver</p> <p>Robosense driver. </p> <ul> <li><code>#include &lt;robosense_driver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaDriverBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#public-functions","title":"Public Functions","text":"Type Name std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; ConvertScanToPointcloud (const std::shared_ptr&lt; robosense_msgs::msg::RobosenseScan &gt; &amp; robosense_scan) Convert RobosenseScan message to point cloud. Status GetStatus () Get current status of this driver. RobosenseDriver () = delete RobosenseDriver (const std::shared_ptr&lt; drivers::RobosenseSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::RobosenseCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) overrideSetting CalibrationConfiguration (not used)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#public-functions-inherited-from-nebuladriversnebuladriverbase","title":"Public Functions inherited from nebula::drivers::NebulaDriverBase","text":"<p>See nebula::drivers::NebulaDriverBase</p> Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#function-convertscantopointcloud","title":"function ConvertScanToPointcloud","text":"<p>Convert RobosenseScan message to point cloud. <pre><code>std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::RobosenseDriver::ConvertScanToPointcloud (\n    const std::shared_ptr&lt; robosense_msgs::msg::RobosenseScan &gt; &amp; robosense_scan\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>robosense_scan</code> Message </li> </ul> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::RobosenseDriver::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#function-robosensedriver-12","title":"function RobosenseDriver [1/2]","text":"<pre><code>nebula::drivers::RobosenseDriver::RobosenseDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#function-robosensedriver-22","title":"function RobosenseDriver [2/2]","text":"<p>Constructor. <pre><code>explicit nebula::drivers::RobosenseDriver::RobosenseDriver (\n    const std::shared_ptr&lt; drivers::RobosenseSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::RobosenseCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> <li><code>calibration_configuration</code> CalibrationConfiguration for this driver </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseDriver/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Setting CalibrationConfiguration (not used) <pre><code>virtual Status nebula::drivers::RobosenseDriver::SetCalibrationConfiguration (\n    const CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/robosense_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/","title":"Class nebula::drivers::RobosenseInfoDecoder","text":"<p>template &lt;typename SensorT typename SensorT&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; RobosenseInfoDecoder</p> <ul> <li><code>#include &lt;robosense_info_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::RobosenseInfoDecoderBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#public-functions","title":"Public Functions","text":"Type Name RobosenseInfoDecoder () Constructor. virtual ReturnMode getReturnMode () overrideGet the laser return mode. virtual RobosenseCalibrationConfiguration getSensorCalibration () overrideGet sensor calibration. virtual std::map&lt; std::string, std::string &gt; getSensorInfo () overrideGet the sensor telemetry. virtual bool getSyncStatus () overrideGet the status of time synchronization. virtual bool parsePacket (const std::vector&lt; uint8_t &gt; &amp; raw_packet) overrideValidates and parses DIFOP packet. Currently only checks size, not checksums etc."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#public-functions-inherited-from-nebuladriversrobosenseinfodecoderbase","title":"Public Functions inherited from nebula::drivers::RobosenseInfoDecoderBase","text":"<p>See nebula::drivers::RobosenseInfoDecoderBase</p> Type Name RobosenseInfoDecoderBase (RobosenseInfoDecoderBase &amp;&amp; c) = delete RobosenseInfoDecoderBase (const RobosenseInfoDecoderBase &amp; c) = delete RobosenseInfoDecoderBase () = default virtual ReturnMode getReturnMode () = 0Get the laser return mode. virtual RobosenseCalibrationConfiguration getSensorCalibration () = 0Get sensor calibration. virtual std::map&lt; std::string, std::string &gt; getSensorInfo () = 0Get the sensor telemetry. virtual bool getSyncStatus () = 0Get the status of time synchronization. RobosenseInfoDecoderBase &amp; operator= (RobosenseInfoDecoderBase &amp;&amp; c) = delete RobosenseInfoDecoderBase &amp; operator= (const RobosenseInfoDecoderBase &amp; c) = delete virtual bool parsePacket (const std::vector&lt; uint8_t &gt; &amp; raw_packet) = 0Parses DIFOP and add its telemetry. virtual ~RobosenseInfoDecoderBase () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name rclcpp::Logger logger_ SensorT::info_t packet_   = {}The last decoded packet. SensorT sensor_   = {}The sensor definition, used for return mode and time offset handling."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-robosenseinfodecoder","title":"function RobosenseInfoDecoder","text":"<pre><code>inline nebula::drivers::RobosenseInfoDecoder::RobosenseInfoDecoder () \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-getreturnmode","title":"function getReturnMode","text":"<p>Get the laser return mode. <pre><code>inline virtual ReturnMode nebula::drivers::RobosenseInfoDecoder::getReturnMode () override\n</code></pre></p> <p>Returns:</p> <p>The laser return mode </p> <p>Implements nebula::drivers::RobosenseInfoDecoderBase::getReturnMode</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-getsensorcalibration","title":"function getSensorCalibration","text":"<p>Get sensor calibration. <pre><code>inline virtual RobosenseCalibrationConfiguration nebula::drivers::RobosenseInfoDecoder::getSensorCalibration () override\n</code></pre></p> <p>Returns:</p> <p>The sensor calibration </p> <p>Implements nebula::drivers::RobosenseInfoDecoderBase::getSensorCalibration</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-getsensorinfo","title":"function getSensorInfo","text":"<p>Get the sensor telemetry. <pre><code>inline virtual std::map&lt; std::string, std::string &gt; nebula::drivers::RobosenseInfoDecoder::getSensorInfo () override\n</code></pre></p> <p>Returns:</p> <p>The sensor telemetry </p> <p>Implements nebula::drivers::RobosenseInfoDecoderBase::getSensorInfo</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-getsyncstatus","title":"function getSyncStatus","text":"<p>Get the status of time synchronization. <pre><code>inline virtual bool nebula::drivers::RobosenseInfoDecoder::getSyncStatus () override\n</code></pre></p> <p>Returns:</p> <p>True if the sensor's clock is synchronized </p> <p>Implements nebula::drivers::RobosenseInfoDecoderBase::getSyncStatus</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Validates and parses DIFOP packet. Currently only checks size, not checksums etc. <pre><code>inline virtual bool nebula::drivers::RobosenseInfoDecoder::parsePacket (\n    const std::vector&lt; uint8_t &gt; &amp; raw_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li>raw_packet The incoming DIFOP packet </li> </ul> <p>Returns:</p> <p>Whether the packet was parsed successfully </p> <p>Implements nebula::drivers::RobosenseInfoDecoderBase::parsePacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#variable-logger_","title":"variable logger_","text":"<pre><code>rclcpp::Logger nebula::drivers::RobosenseInfoDecoder&lt; SensorT &gt;::logger_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#variable-packet_","title":"variable packet_","text":"<pre><code>SensorT::info_t nebula::drivers::RobosenseInfoDecoder&lt; SensorT &gt;::packet_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoder/#variable-sensor_","title":"variable sensor_","text":"<pre><code>SensorT nebula::drivers::RobosenseInfoDecoder&lt; SensorT &gt;::sensor_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/","title":"Class nebula::drivers::RobosenseInfoDecoderBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseInfoDecoderBase</p> <ul> <li><code>#include &lt;robosense_info_decoder_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::RobosenseInfoDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#public-functions","title":"Public Functions","text":"Type Name RobosenseInfoDecoderBase (RobosenseInfoDecoderBase &amp;&amp; c) = delete RobosenseInfoDecoderBase (const RobosenseInfoDecoderBase &amp; c) = delete RobosenseInfoDecoderBase () = default virtual ReturnMode getReturnMode () = 0Get the laser return mode. virtual RobosenseCalibrationConfiguration getSensorCalibration () = 0Get sensor calibration. virtual std::map&lt; std::string, std::string &gt; getSensorInfo () = 0Get the sensor telemetry. virtual bool getSyncStatus () = 0Get the status of time synchronization. RobosenseInfoDecoderBase &amp; operator= (RobosenseInfoDecoderBase &amp;&amp; c) = delete RobosenseInfoDecoderBase &amp; operator= (const RobosenseInfoDecoderBase &amp; c) = delete virtual bool parsePacket (const std::vector&lt; uint8_t &gt; &amp; raw_packet) = 0Parses DIFOP and add its telemetry. virtual ~RobosenseInfoDecoderBase () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-robosenseinfodecoderbase-13","title":"function RobosenseInfoDecoderBase [1/3]","text":"<pre><code>nebula::drivers::RobosenseInfoDecoderBase::RobosenseInfoDecoderBase (\n    RobosenseInfoDecoderBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-robosenseinfodecoderbase-23","title":"function RobosenseInfoDecoderBase [2/3]","text":"<pre><code>nebula::drivers::RobosenseInfoDecoderBase::RobosenseInfoDecoderBase (\n    const RobosenseInfoDecoderBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-robosenseinfodecoderbase-33","title":"function RobosenseInfoDecoderBase [3/3]","text":"<pre><code>nebula::drivers::RobosenseInfoDecoderBase::RobosenseInfoDecoderBase () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-getreturnmode","title":"function getReturnMode","text":"<p>Get the laser return mode. <pre><code>virtual ReturnMode nebula::drivers::RobosenseInfoDecoderBase::getReturnMode () = 0\n</code></pre></p> <p>Returns:</p> <p>The laser return mode </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-getsensorcalibration","title":"function getSensorCalibration","text":"<p>Get sensor calibration. <pre><code>virtual RobosenseCalibrationConfiguration nebula::drivers::RobosenseInfoDecoderBase::getSensorCalibration () = 0\n</code></pre></p> <p>Returns:</p> <p>The sensor calibration </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-getsensorinfo","title":"function getSensorInfo","text":"<p>Get the sensor telemetry. <pre><code>virtual std::map&lt; std::string, std::string &gt; nebula::drivers::RobosenseInfoDecoderBase::getSensorInfo () = 0\n</code></pre></p> <p>Returns:</p> <p>The sensor telemetry </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-getsyncstatus","title":"function getSyncStatus","text":"<p>Get the status of time synchronization. <pre><code>virtual bool nebula::drivers::RobosenseInfoDecoderBase::getSyncStatus () = 0\n</code></pre></p> <p>Returns:</p> <p>True if the sensor's clock is synchronized </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-operator","title":"function operator=","text":"<pre><code>RobosenseInfoDecoderBase &amp; nebula::drivers::RobosenseInfoDecoderBase::operator= (\n    RobosenseInfoDecoderBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-operator_1","title":"function operator=","text":"<pre><code>RobosenseInfoDecoderBase &amp; nebula::drivers::RobosenseInfoDecoderBase::operator= (\n    const RobosenseInfoDecoderBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-parsepacket","title":"function parsePacket","text":"<p>Parses DIFOP and add its telemetry. <pre><code>virtual bool nebula::drivers::RobosenseInfoDecoderBase::parsePacket (\n    const std::vector&lt; uint8_t &gt; &amp; raw_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li>raw_packet The incoming DIFOP packet </li> </ul> <p>Returns:</p> <p>Whether the packet was parsed successfully </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDecoderBase/#function-robosenseinfodecoderbase","title":"function ~RobosenseInfoDecoderBase","text":"<pre><code>virtual nebula::drivers::RobosenseInfoDecoderBase::~RobosenseInfoDecoderBase () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/","title":"Class nebula::drivers::RobosenseInfoDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseInfoDriver</p> <p>Robosense driver. </p> <ul> <li><code>#include &lt;robosense_info_driver.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#public-functions","title":"Public Functions","text":"Type Name Status DecodeInfoPacket (const std::vector&lt; uint8_t &gt; &amp; packet)  ReturnMode GetReturnMode ()  RobosenseCalibrationConfiguration GetSensorCalibration ()  std::map&lt; std::string, std::string &gt; GetSensorInfo ()  Status GetStatus () Get current status of this driver. bool GetSyncStatus () Get the status of time synchronization. RobosenseInfoDriver () = delete RobosenseInfoDriver (const std::shared_ptr&lt; drivers::RobosenseSensorConfiguration &gt; &amp; sensor_configuration) Constructor."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-decodeinfopacket","title":"function DecodeInfoPacket","text":"<pre><code>Status nebula::drivers::RobosenseInfoDriver::DecodeInfoPacket (\n    const std::vector&lt; uint8_t &gt; &amp; packet\n) \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-getreturnmode","title":"function GetReturnMode","text":"<pre><code>ReturnMode nebula::drivers::RobosenseInfoDriver::GetReturnMode () \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-getsensorcalibration","title":"function GetSensorCalibration","text":"<pre><code>RobosenseCalibrationConfiguration nebula::drivers::RobosenseInfoDriver::GetSensorCalibration () \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-getsensorinfo","title":"function GetSensorInfo","text":"<pre><code>std::map&lt; std::string, std::string &gt; nebula::drivers::RobosenseInfoDriver::GetSensorInfo () \n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::RobosenseInfoDriver::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-getsyncstatus","title":"function GetSyncStatus","text":"<p>Get the status of time synchronization. <pre><code>bool nebula::drivers::RobosenseInfoDriver::GetSyncStatus () \n</code></pre></p> <p>Returns:</p> <p>True if the sensor's clock is synchronized </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-robosenseinfodriver-12","title":"function RobosenseInfoDriver [1/2]","text":"<pre><code>nebula::drivers::RobosenseInfoDriver::RobosenseInfoDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseInfoDriver/#function-robosenseinfodriver-22","title":"function RobosenseInfoDriver [2/2]","text":"<p>Constructor. <pre><code>explicit nebula::drivers::RobosenseInfoDriver::RobosenseInfoDriver (\n    const std::shared_ptr&lt; drivers::RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> </ul> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/","title":"Class nebula::drivers::RobosenseScanDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseScanDecoder</p> <p>Base class for Robosense LiDAR decoder. </p> <ul> <li><code>#include &lt;robosense_scan_decoder.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::RobosenseDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#public-functions","title":"Public Functions","text":"Type Name RobosenseScanDecoder (RobosenseScanDecoder &amp;&amp; c) = delete RobosenseScanDecoder (const RobosenseScanDecoder &amp; c) = delete RobosenseScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; getPointcloud () = 0Returns the point cloud and timestamp of the last scan. virtual bool hasScanned () = 0Indicates whether one full scan is ready. RobosenseScanDecoder &amp; operator= (RobosenseScanDecoder &amp;&amp; c) = delete RobosenseScanDecoder &amp; operator= (const RobosenseScanDecoder &amp; c) = delete virtual int unpack (const robosense_msgs::msg::RobosensePacket &amp; msop_packet) = 0Parses RobosensePacket and add its points to the point cloud. virtual ~RobosenseScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-robosensescandecoder-13","title":"function RobosenseScanDecoder [1/3]","text":"<pre><code>nebula::drivers::RobosenseScanDecoder::RobosenseScanDecoder (\n    RobosenseScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-robosensescandecoder-23","title":"function RobosenseScanDecoder [2/3]","text":"<pre><code>nebula::drivers::RobosenseScanDecoder::RobosenseScanDecoder (\n    const RobosenseScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-robosensescandecoder-33","title":"function RobosenseScanDecoder [3/3]","text":"<pre><code>nebula::drivers::RobosenseScanDecoder::RobosenseScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-getpointcloud","title":"function getPointcloud","text":"<p>Returns the point cloud and timestamp of the last scan. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::RobosenseScanDecoder::getPointcloud () = 0\n</code></pre></p> <p>Returns:</p> <p>A tuple of point cloud and timestamp in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Indicates whether one full scan is ready. <pre><code>virtual bool nebula::drivers::RobosenseScanDecoder::hasScanned () = 0\n</code></pre></p> <p>Returns:</p> <p>Whether a scan is ready </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-operator","title":"function operator=","text":"<pre><code>RobosenseScanDecoder &amp; nebula::drivers::RobosenseScanDecoder::operator= (\n    RobosenseScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-operator_1","title":"function operator=","text":"<pre><code>RobosenseScanDecoder &amp; nebula::drivers::RobosenseScanDecoder::operator= (\n    const RobosenseScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-unpack","title":"function unpack","text":"<p>Parses RobosensePacket and add its points to the point cloud. <pre><code>virtual int nebula::drivers::RobosenseScanDecoder::unpack (\n    const robosense_msgs::msg::RobosensePacket &amp; msop_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msop_packet</code> The incoming MsopPacket </li> </ul> <p>Returns:</p> <p>The last azimuth processed </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseScanDecoder/#function-robosensescandecoder","title":"function ~RobosenseScanDecoder","text":"<pre><code>virtual nebula::drivers::RobosenseScanDecoder::~RobosenseScanDecoder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/","title":"Class nebula::drivers::RobosenseSensor","text":"<p>template &lt;typename PacketT typename PacketT, typename InfoPacketT typename InfoPacketT&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; RobosenseSensor</p> <p>Base class for all sensor definitions. More...</p> <ul> <li><code>#include &lt;robosense_sensor.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-types","title":"Public Types","text":"Type Name typedef class AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; angle_corrector_t typedef InfoPacketT info_t typedef PacketT packet_t"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-functions","title":"Public Functions","text":"Type Name RobosenseSensor () = default int getEarliestPointTimeOffsetForBlock (uint32_t start_block_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. virtual int getPacketRelativePointTimeOffset (uint32_t block_id, uint32_t channel_id, const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration) = 0Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. virtual ReturnType getReturnType (ReturnMode return_mode, unsigned int return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Get the return type of the point given by return_idx. virtual ~RobosenseSensor () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-static-functions","title":"Public Static Functions","text":"Type Name bool is_duplicate (uint32_t return_idx, const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units) Whether the unit given by return_idx is a duplicate of any other unit in return_units."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type of the sensor </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#typedef-angle_corrector_t","title":"typedef angle_corrector_t","text":"<pre><code>typedef class AngleCorrectorCalibrationBased&lt; PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS &gt; nebula::drivers::RobosenseSensor&lt; PacketT, InfoPacketT &gt;::angle_corrector_t;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#typedef-info_t","title":"typedef info_t","text":"<pre><code>typedef InfoPacketT nebula::drivers::RobosenseSensor&lt; PacketT, InfoPacketT &gt;::info_t;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#typedef-packet_t","title":"typedef packet_t","text":"<pre><code>typedef PacketT nebula::drivers::RobosenseSensor&lt; PacketT, InfoPacketT &gt;::packet_t;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-robosensesensor","title":"function RobosenseSensor","text":"<pre><code>nebula::drivers::RobosenseSensor::RobosenseSensor () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-getearliestpointtimeoffsetforblock","title":"function getEarliestPointTimeOffsetForBlock","text":"<p>For a given start block index, find the earliest (lowest) relative time offset of any point in the packet in or after the start block. <pre><code>inline int nebula::drivers::RobosenseSensor::getEarliestPointTimeOffsetForBlock (\n    uint32_t start_block_id,\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>start_block_id</code> The index of the block in and after which to consider points </li> <li><code>sensor_configuration</code> The sensor configuration </li> </ul> <p>Returns:</p> <p>The lowest point time offset (relative to the packet timestamp) of any point in or after the start block, in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-getpacketrelativepointtimeoffset","title":"function getPacketRelativePointTimeOffset","text":"<p>Computes the exact relative time between the timestamp of the given packet and the one of the point identified by the given block and channel, in nanoseconds. <pre><code>virtual int nebula::drivers::RobosenseSensor::getPacketRelativePointTimeOffset (\n    uint32_t block_id,\n    uint32_t channel_id,\n    const std::shared_ptr&lt; RobosenseSensorConfiguration &gt; &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The point's block id </li> <li><code>channel_id</code> The point's channel id </li> <li><code>sensor_configuration</code> The sensor configuration </li> </ul> <p>Returns:</p> <p>The relative time offset in nanoseconds </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-getreturntype","title":"function getReturnType","text":"<p>Get the return type of the point given by return_idx. <pre><code>inline virtual ReturnType nebula::drivers::RobosenseSensor::getReturnType (\n    ReturnMode return_mode,\n    unsigned int return_idx,\n    const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> The sensor's currently active return mode </li> <li><code>return_idx</code> The block index of the point within the group of blocks that make up the return group (e.g. either 0 or 1 for dual return) </li> <li><code>return_units</code> The units corresponding to all the returns in the group. These are usually from the same column across adjascent blocks. </li> </ul> <p>Returns:</p> <p>The return type of the point </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-robosensesensor_1","title":"function ~RobosenseSensor","text":"<pre><code>virtual nebula::drivers::RobosenseSensor::~RobosenseSensor () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1RobosenseSensor/#function-is_duplicate","title":"function is_duplicate","text":"<p>Whether the unit given by return_idx is a duplicate of any other unit in return_units. <pre><code>static inline bool nebula::drivers::RobosenseSensor::is_duplicate (\n    uint32_t return_idx,\n    const std::vector&lt; const typename PacketT::body_t::block_t::unit_t * &gt; &amp; return_units\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_idx</code> The unit's index in the return_units vector </li> <li><code>return_units</code> The vector of all the units corresponding to the same return group (i.e. length 2 for dual-return with both units having the same channel but coming from different blocks) </li> </ul> <p>Returns:</p> <p>true if the unit is identical to any other one in return_units, false otherwise </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/","title":"Class nebula::drivers::VelodyneDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneDriver</p> <p>Velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_driver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaDriverBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions","title":"Public Functions","text":"Type Name std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; ConvertScanToPointcloud (const std::shared_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt; &amp; velodyne_scan) Convert VelodyneScan message to point cloud. Status GetStatus () Get current status of this driver. virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) overrideSetting CalibrationConfiguration (not used) VelodyneDriver () = delete VelodyneDriver (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions-inherited-from-nebuladriversnebuladriverbase","title":"Public Functions inherited from nebula::drivers::NebulaDriverBase","text":"<p>See nebula::drivers::NebulaDriverBase</p> Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-convertscantopointcloud","title":"function ConvertScanToPointcloud","text":"<p>Convert VelodyneScan message to point cloud. <pre><code>std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::VelodyneDriver::ConvertScanToPointcloud (\n    const std::shared_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt; &amp; velodyne_scan\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_scan</code> Message </li> </ul> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::VelodyneDriver::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Setting CalibrationConfiguration (not used) <pre><code>virtual Status nebula::drivers::VelodyneDriver::SetCalibrationConfiguration (\n    const CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-velodynedriver-12","title":"function VelodyneDriver [1/2]","text":"<pre><code>nebula::drivers::VelodyneDriver::VelodyneDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-velodynedriver-22","title":"function VelodyneDriver [2/2]","text":"<p>Constructor. <pre><code>nebula::drivers::VelodyneDriver::VelodyneDriver (\n    const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> <li><code>calibration_configuration</code> CalibrationConfiguration for this driver </li> </ul> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/","title":"Class nebula::drivers::VelodyneScanDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneScanDecoder</p> <p>Base class for Velodyne LiDAR decoder. </p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::vlp16::Vlp16Decoder,  nebula::drivers::vlp32::Vlp32Decoder,  nebula::drivers::vls128::Vls128Decoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#public-functions","title":"Public Functions","text":"Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow (double time_stamp) = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-13","title":"function VelodyneScanDecoder [1/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder (\n    VelodyneScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-23","title":"function VelodyneScanDecoder [2/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder (\n    const VelodyneScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-33","title":"function VelodyneScanDecoder [3/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Virtual function for getting the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::VelodyneScanDecoder::get_pointcloud () = 0\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Virtual function for getting the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::VelodyneScanDecoder::hasScanned () = 0\n</code></pre></p> <p>Returns:</p> <p>Readied </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-operator","title":"function operator=","text":"<pre><code>VelodyneScanDecoder &amp; nebula::drivers::VelodyneScanDecoder::operator= (\n    VelodyneScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-operator_1","title":"function operator=","text":"<pre><code>VelodyneScanDecoder &amp; nebula::drivers::VelodyneScanDecoder::operator= (\n    const VelodyneScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Virtual function for parsing VelodynePacket based on packet structure. <pre><code>virtual bool nebula::drivers::VelodyneScanDecoder::parsePacket (\n    const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Returns:</p> <p>Resulting flag </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::VelodyneScanDecoder::pointsPerPacket () = 0\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#of-points","title":"of points","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::VelodyneScanDecoder::reset_overflow (\n    double time_stamp\n) = 0\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::VelodyneScanDecoder::reset_pointcloud (\n    size_t n_pts,\n    double time_stamp\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-unpack","title":"function unpack","text":"<p>Virtual function for parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::VelodyneScanDecoder::unpack (\n    const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder","title":"function ~VelodyneScanDecoder","text":"<pre><code>virtual nebula::drivers::VelodyneScanDecoder::~VelodyneScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-calibration_configuration_","title":"variable calibration_configuration_","text":"<pre><code>std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; nebula::drivers::VelodyneScanDecoder::calibration_configuration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-dual_return_distance_threshold_","title":"variable dual_return_distance_threshold_","text":"<pre><code>double nebula::drivers::VelodyneScanDecoder::dual_return_distance_threshold_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-has_scanned_","title":"variable has_scanned_","text":"<pre><code>bool nebula::drivers::VelodyneScanDecoder::has_scanned_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-last_phase_","title":"variable last_phase_","text":"<pre><code>uint16_t nebula::drivers::VelodyneScanDecoder::last_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-overflow_pc_","title":"variable overflow_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::VelodyneScanDecoder::overflow_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_pc_","title":"variable scan_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::VelodyneScanDecoder::scan_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_phase_","title":"variable scan_phase_","text":"<pre><code>uint16_t nebula::drivers::VelodyneScanDecoder::scan_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_timestamp_","title":"variable scan_timestamp_","text":"<pre><code>double nebula::drivers::VelodyneScanDecoder::scan_timestamp_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-sensor_configuration_","title":"variable sensor_configuration_","text":"<pre><code>std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; nebula::drivers::VelodyneScanDecoder::sensor_configuration_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/","title":"Namespace nebula::drivers::hesai_packet","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; hesai_packet</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#namespaces","title":"Namespaces","text":"Type Name namespace return_mode"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#classes","title":"Classes","text":"Type Name struct Block &lt;typename UnitT, UnitN&gt; struct Body &lt;typename BlockT, BlockN&gt; struct DateTime &lt;YearOffset&gt;DateTime struct for Hesai packets. struct FineAzimuthBlock &lt;typename UnitT, UnitN&gt; struct FunctionalSafety struct Header12B struct Header8B struct Packet128E3X struct Packet40P struct Packet64 struct PacketAT128E2X struct PacketBase &lt;nBlocks, nChannels, maxReturns, degreeSubdivisions&gt;Base struct for all Hesai packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. struct PacketQT128C2X struct PacketQT64 struct PacketXT32 struct PacketXT32M2X struct SOBBlock &lt;typename UnitT, UnitN&gt; struct SecondsSinceEpoch struct Tail128E3X struct Tail40P struct TailAT128E2X struct TailQT128C2X struct TailQT64 struct TailXT32 struct Unit3B struct Unit4B"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#public-types","title":"Public Types","text":"Type Name typedef Packet128E3X Packet128E4X typedef Tail40P Tail64 typedef TailXT32 TailXT32M2X"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#public-functions","title":"Public Functions","text":"Type Name double get_dis_unit (const PacketT &amp; packet) Get the distance unit of the given packet type in meters. Distance values in the packet, multiplied by this value, yield the distance in meters. double get_dis_unit&lt; Packet40P &gt; (const Packet40P &amp;) Get the distance unit of the given Packet40P packet in meters. This is the only packet type without a header. int get_n_returns (uint8_t return_mode) Get the number of returns for a given return mode. uint64_t get_timestamp_ns (const PacketT &amp; packet) Get timestamp from packet in nanoseconds."},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#typedef-packet128e4x","title":"typedef Packet128E4X","text":"<pre><code>typedef Packet128E3X nebula::drivers::hesai_packet::Packet128E4X;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#typedef-tail64","title":"typedef Tail64","text":"<pre><code>typedef Tail40P nebula::drivers::hesai_packet::Tail64;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#typedef-tailxt32m2x","title":"typedef TailXT32M2X","text":"<pre><code>typedef TailXT32 nebula::drivers::hesai_packet::TailXT32M2X;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#function-get_dis_unit","title":"function get_dis_unit","text":"<p>Get the distance unit of the given packet type in meters. Distance values in the packet, multiplied by this value, yield the distance in meters. <pre><code>template&lt;typename PacketT typename PacketT&gt;\ndouble nebula::drivers::hesai_packet::get_dis_unit (\n    const PacketT &amp; packet\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type </li> </ul> <p>Parameters:</p> <ul> <li><code>packet</code> The packet to get the distance unit from </li> </ul> <p>Returns:</p> <p>The distance unit in meters </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#function-get_dis_unit-packet40p","title":"function get_dis_unit&lt; Packet40P &gt;","text":"<p>Get the distance unit of the given Packet40P packet in meters. This is the only packet type without a header. <pre><code>template&lt;&gt;\ndouble nebula::drivers::hesai_packet::get_dis_unit&lt; Packet40P &gt; (\n    const Packet40P &amp;\n) \n</code></pre></p> <p>Returns:</p> <p>0.004 (4mm) </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#function-get_n_returns","title":"function get_n_returns","text":"<p>Get the number of returns for a given return mode. <pre><code>int nebula::drivers::hesai_packet::get_n_returns (\n    uint8_t return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li>return_mode The return mode </li> </ul> <p>Returns:</p> <p>The number of returns </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet/#function-get_timestamp_ns","title":"function get_timestamp_ns","text":"<p>Get timestamp from packet in nanoseconds. <pre><code>template&lt;typename PacketT typename PacketT&gt;\nuint64_t nebula::drivers::hesai_packet::get_timestamp_ns (\n    const PacketT &amp; packet\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type </li> </ul> <p>Parameters:</p> <ul> <li><code>packet</code> The packet to get the timestamp from </li> </ul> <p>Returns:</p> <p>The timestamp in nanoseconds </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/","title":"Struct nebula::drivers::hesai_packet::Block","text":"<p>template &lt;typename UnitT typename UnitT, size_t UnitN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Block</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-types","title":"Public Types","text":"Type Name typedef UnitT unit_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth UnitT units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-functions","title":"Public Functions","text":"Type Name uint32_t get_azimuth () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#typedef-unit_t","title":"typedef unit_t","text":"<pre><code>typedef UnitT nebula::drivers::hesai_packet::Block&lt; UnitT, UnitN &gt;::unit_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Block&lt; UnitT, UnitN &gt;::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#variable-units","title":"variable units","text":"<pre><code>UnitT nebula::drivers::hesai_packet::Block&lt; UnitT, UnitN &gt;::units[UnitN];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Block/#function-get_azimuth","title":"function get_azimuth","text":"<pre><code>inline uint32_t nebula::drivers::hesai_packet::Block::get_azimuth () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/","title":"Struct nebula::drivers::hesai_packet::Body","text":"<p>template &lt;typename BlockT typename BlockT, size_t BlockN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Body</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#public-types","title":"Public Types","text":"Type Name typedef BlockT block_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#public-attributes","title":"Public Attributes","text":"Type Name BlockT blocks"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#typedef-block_t","title":"typedef block_t","text":"<pre><code>typedef BlockT nebula::drivers::hesai_packet::Body&lt; BlockT, BlockN &gt;::block_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Body/#variable-blocks","title":"variable blocks","text":"<pre><code>BlockT nebula::drivers::hesai_packet::Body&lt; BlockT, BlockN &gt;::blocks[BlockN];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/","title":"Struct nebula::drivers::hesai_packet::DateTime","text":"<p>template &lt;int YearOffset&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; DateTime</p> <p>DateTime struct for Hesai packets.More...</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t day uint8_t hour uint8_t minute uint8_t month uint8_t second uint8_t year Year - YearOffset (e.g. for YearOffset=1900 value 100 corresponds to year 2000)"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#public-functions","title":"Public Functions","text":"Type Name uint64_t get_seconds () constGet seconds since epoch."},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>YearOffset</code> like std::tm, the Hesai format has a year offset that is applied to the raw year value. For most protocol versions it is 1900 (like std::tm), for some it is 2000. </li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-day","title":"variable day","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::day;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-hour","title":"variable hour","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::hour;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-minute","title":"variable minute","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::minute;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-month","title":"variable month","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::month;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-second","title":"variable second","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#variable-year","title":"variable year","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::DateTime&lt; YearOffset &gt;::year;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1DateTime/#function-get_seconds","title":"function get_seconds","text":"<p>Get seconds since epoch. <pre><code>inline uint64_t nebula::drivers::hesai_packet::DateTime::get_seconds () const\n</code></pre></p> <p>Returns:</p> <p>Whole seconds since epoch </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/","title":"Struct nebula::drivers::hesai_packet::FineAzimuthBlock","text":"<p>template &lt;typename UnitT typename UnitT, size_t UnitN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; FineAzimuthBlock</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-types","title":"Public Types","text":"Type Name typedef UnitT unit_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth uint8_t fine_azimuth UnitT units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-functions","title":"Public Functions","text":"Type Name uint32_t get_azimuth () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#typedef-unit_t","title":"typedef unit_t","text":"<pre><code>typedef UnitT nebula::drivers::hesai_packet::FineAzimuthBlock&lt; UnitT, UnitN &gt;::unit_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::FineAzimuthBlock&lt; UnitT, UnitN &gt;::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#variable-fine_azimuth","title":"variable fine_azimuth","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::FineAzimuthBlock&lt; UnitT, UnitN &gt;::fine_azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#variable-units","title":"variable units","text":"<pre><code>UnitT nebula::drivers::hesai_packet::FineAzimuthBlock&lt; UnitT, UnitN &gt;::units[UnitN];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FineAzimuthBlock/#function-get_azimuth","title":"function get_azimuth","text":"<pre><code>inline uint32_t nebula::drivers::hesai_packet::FineAzimuthBlock::get_azimuth () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/","title":"Struct nebula::drivers::hesai_packet::FunctionalSafety","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; FunctionalSafety</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t crc_fs uint16_t fault_code uint8_t fault_code_id uint8_t fs_version uint8_t lidar_state uint8_t reserved1"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-crc_fs","title":"variable crc_fs","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::FunctionalSafety::crc_fs;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-fault_code","title":"variable fault_code","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::FunctionalSafety::fault_code;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-fault_code_id","title":"variable fault_code_id","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::FunctionalSafety::fault_code_id;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-fs_version","title":"variable fs_version","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::FunctionalSafety::fs_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-lidar_state","title":"variable lidar_state","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::FunctionalSafety::lidar_state;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1FunctionalSafety/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::FunctionalSafety::reserved1[8];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/","title":"Struct nebula::drivers::hesai_packet::Header12B","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Header12B</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t block_num uint8_t dis_unit uint8_t flags uint8_t laser_num uint8_t protocol_major uint8_t protocol_minor uint8_t reserved1 uint8_t reserved2 uint8_t return_num uint16_t sop"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-block_num","title":"variable block_num","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::block_num;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-dis_unit","title":"variable dis_unit","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::dis_unit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-flags","title":"variable flags","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::flags;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-laser_num","title":"variable laser_num","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::laser_num;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-protocol_major","title":"variable protocol_major","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::protocol_major;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-protocol_minor","title":"variable protocol_minor","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::protocol_minor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::reserved1[2];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-reserved2","title":"variable reserved2","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::reserved2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-return_num","title":"variable return_num","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header12B::return_num;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header12B/#variable-sop","title":"variable sop","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Header12B::sop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/","title":"Struct nebula::drivers::hesai_packet::Header8B","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Header8B</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t block_num uint8_t dis_unit uint8_t laser_num uint8_t reserved1 uint8_t reserved2 uint16_t sop Start of Packet, 0xEEFF."},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-block_num","title":"variable block_num","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header8B::block_num;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-dis_unit","title":"variable dis_unit","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header8B::dis_unit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-laser_num","title":"variable laser_num","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header8B::laser_num;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header8B::reserved1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-reserved2","title":"variable reserved2","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Header8B::reserved2[2];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Header8B/#variable-sop","title":"variable sop","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Header8B::sop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/","title":"Struct nebula::drivers::hesai_packet::Packet128E3X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Packet128E3X</p> <ul> <li><code>#include &lt;pandar_128e3x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit3B, Packet128E3X::N_CHANNELS &gt;, Packet128E3X::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#public-attributes","title":"Public Attributes","text":"Type Name body_t body uint32_t crc_body FunctionalSafety fs Header12B header Tail128E3X tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit3B, Packet128E3X::N_CHANNELS&gt;, Packet128E3X::N_BLOCKS&gt; nebula::drivers::hesai_packet::Packet128E3X::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::Packet128E3X::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#variable-crc_body","title":"variable crc_body","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::Packet128E3X::crc_body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#variable-fs","title":"variable fs","text":"<pre><code>FunctionalSafety nebula::drivers::hesai_packet::Packet128E3X::fs;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::Packet128E3X::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet128E3X/#variable-tail","title":"variable tail","text":"<pre><code>Tail128E3X nebula::drivers::hesai_packet::Packet128E3X::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/","title":"Struct nebula::drivers::hesai_packet::Packet40P","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Packet40P</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; SOBBlock&lt; Unit3B, Packet40P::N_CHANNELS &gt;, Packet40P::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Tail40P tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;SOBBlock&lt;Unit3B, Packet40P::N_CHANNELS&gt;, Packet40P::N_BLOCKS&gt; nebula::drivers::hesai_packet::Packet40P::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::Packet40P::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet40P/#variable-tail","title":"variable tail","text":"<pre><code>Tail40P nebula::drivers::hesai_packet::Packet40P::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/","title":"Struct nebula::drivers::hesai_packet::Packet64","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Packet64</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit3B, Packet64::N_CHANNELS &gt;, Packet64::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header8B header Tail64 tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit3B, Packet64::N_CHANNELS&gt;, Packet64::N_BLOCKS&gt; nebula::drivers::hesai_packet::Packet64::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::Packet64::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#variable-header","title":"variable header","text":"<pre><code>Header8B nebula::drivers::hesai_packet::Packet64::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Packet64/#variable-tail","title":"variable tail","text":"<pre><code>Tail64 nebula::drivers::hesai_packet::Packet64::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/","title":"Struct nebula::drivers::hesai_packet::PacketAT128E2X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketAT128E2X</p> <ul> <li><code>#include &lt;pandar_at128.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; FineAzimuthBlock&lt; Unit4B, PacketAT128E2X::N_CHANNELS &gt;, PacketAT128E2X::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#public-attributes","title":"Public Attributes","text":"Type Name body_t body uint32_t crc_body Header12B header TailAT128E2X tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;FineAzimuthBlock&lt;Unit4B, PacketAT128E2X::N_CHANNELS&gt;, PacketAT128E2X::N_BLOCKS&gt; nebula::drivers::hesai_packet::PacketAT128E2X::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::PacketAT128E2X::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#variable-crc_body","title":"variable crc_body","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::PacketAT128E2X::crc_body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::PacketAT128E2X::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketAT128E2X/#variable-tail","title":"variable tail","text":"<pre><code>TailAT128E2X nebula::drivers::hesai_packet::PacketAT128E2X::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/","title":"Struct nebula::drivers::hesai_packet::PacketBase","text":"<p>template &lt;size_t nBlocks, size_t nChannels, size_t maxReturns, size_t degreeSubdivisions&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketBase</p> <p>Base struct for all Hesai packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. More...</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>nBlocks</code> The number of blocks in the packet </li> <li><code>nChannels</code> The number of channels per block </li> <li><code>maxReturns</code> The maximum number of returns, e.g. 2 for dual return </li> <li><code>degreeSubdivisions</code> The resolution of the azimuth angle in the packet, e.g. 100 if packet azimuth is given in 1/100th of a degree </li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#variable-degree_subdivisions","title":"variable DEGREE_SUBDIVISIONS","text":"<pre><code>constexpr size_t nebula::drivers::hesai_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::DEGREE_SUBDIVISIONS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#variable-max_returns","title":"variable MAX_RETURNS","text":"<pre><code>constexpr size_t nebula::drivers::hesai_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::MAX_RETURNS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#variable-n_blocks","title":"variable N_BLOCKS","text":"<pre><code>constexpr size_t nebula::drivers::hesai_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::N_BLOCKS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketBase/#variable-n_channels","title":"variable N_CHANNELS","text":"<pre><code>constexpr size_t nebula::drivers::hesai_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::N_CHANNELS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/","title":"Struct nebula::drivers::hesai_packet::PacketQT128C2X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketQT128C2X</p> <ul> <li><code>#include &lt;pandar_qt128.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit4B, PacketQT128C2X::N_CHANNELS &gt;, PacketQT128C2X::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#public-attributes","title":"Public Attributes","text":"Type Name body_t body uint32_t crc_body FunctionalSafety fs Header12B header TailQT128C2X tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit4B, PacketQT128C2X::N_CHANNELS&gt;, PacketQT128C2X::N_BLOCKS&gt; nebula::drivers::hesai_packet::PacketQT128C2X::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::PacketQT128C2X::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#variable-crc_body","title":"variable crc_body","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::PacketQT128C2X::crc_body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#variable-fs","title":"variable fs","text":"<pre><code>FunctionalSafety nebula::drivers::hesai_packet::PacketQT128C2X::fs;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::PacketQT128C2X::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT128C2X/#variable-tail","title":"variable tail","text":"<pre><code>TailQT128C2X nebula::drivers::hesai_packet::PacketQT128C2X::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/","title":"Struct nebula::drivers::hesai_packet::PacketQT64","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketQT64</p> <ul> <li><code>#include &lt;pandar_qt64.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit4B, PacketQT64::N_CHANNELS &gt;, PacketQT64::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header12B header TailQT64 tail uint32_t udp_sequence"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit4B, PacketQT64::N_CHANNELS&gt;, PacketQT64::N_BLOCKS&gt; nebula::drivers::hesai_packet::PacketQT64::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::PacketQT64::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::PacketQT64::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#variable-tail","title":"variable tail","text":"<pre><code>TailQT64 nebula::drivers::hesai_packet::PacketQT64::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketQT64/#variable-udp_sequence","title":"variable udp_sequence","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::PacketQT64::udp_sequence;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/","title":"Struct nebula::drivers::hesai_packet::PacketXT32","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketXT32</p> <ul> <li><code>#include &lt;pandar_xt32.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit4B, PacketXT32::N_CHANNELS &gt;, PacketXT32::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header12B header TailXT32 tail uint32_t udp_sequence"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit4B, PacketXT32::N_CHANNELS&gt;, PacketXT32::N_BLOCKS&gt; nebula::drivers::hesai_packet::PacketXT32::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::PacketXT32::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::PacketXT32::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#variable-tail","title":"variable tail","text":"<pre><code>TailXT32 nebula::drivers::hesai_packet::PacketXT32::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32/#variable-udp_sequence","title":"variable udp_sequence","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::PacketXT32::udp_sequence;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/","title":"Struct nebula::drivers::hesai_packet::PacketXT32M2X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; PacketXT32M2X</p> <ul> <li><code>#include &lt;pandar_xt32m.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::hesai_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit4B, PacketXT32M2X::N_CHANNELS &gt;, PacketXT32M2X::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header12B header TailXT32M2X tail uint32_t udp_sequence"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#public-static-attributes-inherited-from-nebuladrivershesai_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::hesai_packet::PacketBase","text":"<p>See nebula::drivers::hesai_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit4B, PacketXT32M2X::N_CHANNELS&gt;, PacketXT32M2X::N_BLOCKS&gt; nebula::drivers::hesai_packet::PacketXT32M2X::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::hesai_packet::PacketXT32M2X::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#variable-header","title":"variable header","text":"<pre><code>Header12B nebula::drivers::hesai_packet::PacketXT32M2X::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#variable-tail","title":"variable tail","text":"<pre><code>TailXT32M2X nebula::drivers::hesai_packet::PacketXT32M2X::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1PacketXT32M2X/#variable-udp_sequence","title":"variable udp_sequence","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::PacketXT32M2X::udp_sequence;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32m.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/","title":"Struct nebula::drivers::hesai_packet::SOBBlock","text":"<p>template &lt;typename UnitT typename UnitT, size_t UnitN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; SOBBlock</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-types","title":"Public Types","text":"Type Name typedef UnitT unit_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth uint16_t sob Start of Block , 0xFFEE. UnitT units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-functions","title":"Public Functions","text":"Type Name uint32_t get_azimuth () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#typedef-unit_t","title":"typedef unit_t","text":"<pre><code>typedef UnitT nebula::drivers::hesai_packet::SOBBlock&lt; UnitT, UnitN &gt;::unit_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::SOBBlock&lt; UnitT, UnitN &gt;::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::SOBBlock&lt; UnitT, UnitN &gt;::sob;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#variable-units","title":"variable units","text":"<pre><code>UnitT nebula::drivers::hesai_packet::SOBBlock&lt; UnitT, UnitN &gt;::units[UnitN];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SOBBlock/#function-get_azimuth","title":"function get_azimuth","text":"<pre><code>inline uint32_t nebula::drivers::hesai_packet::SOBBlock::get_azimuth () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/","title":"Struct nebula::drivers::hesai_packet::SecondsSinceEpoch","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; SecondsSinceEpoch</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t seconds Seconds since epoch, in big-endian format. uint8_t zero"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#public-functions","title":"Public Functions","text":"Type Name uint64_t get_seconds () constGet seconds since epoch."},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#variable-seconds","title":"variable seconds","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::SecondsSinceEpoch::seconds[5];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#variable-zero","title":"variable zero","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::SecondsSinceEpoch::zero;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1SecondsSinceEpoch/#function-get_seconds","title":"function get_seconds","text":"<p>Get seconds since epoch. <pre><code>inline uint64_t nebula::drivers::hesai_packet::SecondsSinceEpoch::get_seconds () const\n</code></pre></p> <p>Returns:</p> <p>Whole seconds since epoch </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/","title":"Struct nebula::drivers::hesai_packet::Tail128E3X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Tail128E3X</p> <ul> <li><code>#include &lt;pandar_128e3x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth_state DateTime&lt; 1900 &gt; date_time uint8_t factory_information uint16_t motor_speed uint8_t operational_state uint8_t reserved1 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#public-functions","title":"Public Functions","text":"Type Name uint8_t geAzimuthState (unsigned int block_id) constGet the azimuth state of the given block in the packet."},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-azimuth_state","title":"variable azimuth_state","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Tail128E3X::azimuth_state;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime&lt;1900&gt; nebula::drivers::hesai_packet::Tail128E3X::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail128E3X::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Tail128E3X::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-operational_state","title":"variable operational_state","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail128E3X::operational_state;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail128E3X::reserved1[9];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail128E3X::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::Tail128E3X::timestamp;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail128E3X/#function-geazimuthstate","title":"function geAzimuthState","text":"<p>Get the azimuth state of the given block in the packet. <pre><code>inline uint8_t nebula::drivers::hesai_packet::Tail128E3X::geAzimuthState (\n    unsigned int block_id\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> The block ID (i.e. its index in the packet). Valid IDs are 0 and 1. </li> </ul> <p>Returns:</p> <p>The azimuth state number of the block </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/","title":"Struct nebula::drivers::hesai_packet::Tail40P","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Tail40P</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#public-attributes","title":"Public Attributes","text":"Type Name DateTime&lt; 2000 &gt; date_time uint8_t factory_information uint8_t high_temperature_shutdown_flag uint16_t motor_speed uint8_t reserved1 uint8_t reserved2 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime&lt;2000&gt; nebula::drivers::hesai_packet::Tail40P::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail40P::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-high_temperature_shutdown_flag","title":"variable high_temperature_shutdown_flag","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail40P::high_temperature_shutdown_flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Tail40P::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail40P::reserved1[5];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-reserved2","title":"variable reserved2","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail40P::reserved2[2];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Tail40P::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Tail40P/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::Tail40P::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/","title":"Struct nebula::drivers::hesai_packet::TailAT128E2X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; TailAT128E2X</p> <ul> <li><code>#include &lt;pandar_at128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#public-attributes","title":"Public Attributes","text":"Type Name SecondsSinceEpoch date_time uint8_t factory_information uint8_t high_temperature_shutdown_flag uint16_t motor_speed uint8_t reserved1 uint8_t reserved2 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-date_time","title":"variable date_time","text":"<pre><code>SecondsSinceEpoch nebula::drivers::hesai_packet::TailAT128E2X::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailAT128E2X::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-high_temperature_shutdown_flag","title":"variable high_temperature_shutdown_flag","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailAT128E2X::high_temperature_shutdown_flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::TailAT128E2X::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailAT128E2X::reserved1[6];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-reserved2","title":"variable reserved2","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailAT128E2X::reserved2[11];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailAT128E2X::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailAT128E2X/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::TailAT128E2X::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/","title":"Struct nebula::drivers::hesai_packet::TailQT128C2X","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; TailQT128C2X</p> <ul> <li><code>#include &lt;pandar_qt128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#public-attributes","title":"Public Attributes","text":"Type Name DateTime&lt; 1900 &gt; date_time uint8_t factory_information uint8_t mode_flag uint16_t motor_speed uint8_t reserved1 uint8_t reserved2 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime&lt;1900&gt; nebula::drivers::hesai_packet::TailQT128C2X::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT128C2X::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-mode_flag","title":"variable mode_flag","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT128C2X::mode_flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::TailQT128C2X::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT128C2X::reserved1[5];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-reserved2","title":"variable reserved2","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT128C2X::reserved2[6];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT128C2X::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT128C2X/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::TailQT128C2X::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/","title":"Struct nebula::drivers::hesai_packet::TailQT64","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; TailQT64</p> <ul> <li><code>#include &lt;pandar_qt64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#public-attributes","title":"Public Attributes","text":"Type Name DateTime&lt; 1900 &gt; date_time uint8_t factory_information uint16_t motor_speed uint8_t reserved1 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime&lt;1900&gt; nebula::drivers::hesai_packet::TailQT64::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT64::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::TailQT64::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT64::reserved1[10];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailQT64::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailQT64/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::TailQT64::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/","title":"Struct nebula::drivers::hesai_packet::TailXT32","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; TailXT32</p> <ul> <li><code>#include &lt;pandar_xt32.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#public-attributes","title":"Public Attributes","text":"Type Name DateTime&lt; 1900 &gt; date_time uint8_t factory_information uint16_t motor_speed uint8_t reserved1 uint8_t return_mode uint32_t timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime&lt;1900&gt; nebula::drivers::hesai_packet::TailXT32::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-factory_information","title":"variable factory_information","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailXT32::factory_information;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::TailXT32::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-reserved1","title":"variable reserved1","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailXT32::reserved1[10];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::TailXT32::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1TailXT32/#variable-timestamp","title":"variable timestamp","text":"<pre><code>uint32_t nebula::drivers::hesai_packet::TailXT32::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit3B/","title":"Struct nebula::drivers::hesai_packet::Unit3B","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Unit3B</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit3B/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t distance uint8_t reflectivity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit3B/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit3B/#variable-distance","title":"variable distance","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Unit3B::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit3B/#variable-reflectivity","title":"variable reflectivity","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Unit3B::reflectivity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/","title":"Struct nebula::drivers::hesai_packet::Unit4B","text":"<p>ClassList &gt; nebula &gt; drivers &gt; hesai_packet &gt; Unit4B</p> <ul> <li><code>#include &lt;hesai_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t confidence_or_reserved uint16_t distance uint8_t reflectivity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/#variable-confidence_or_reserved","title":"variable confidence_or_reserved","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Unit4B::confidence_or_reserved;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/#variable-distance","title":"variable distance","text":"<pre><code>uint16_t nebula::drivers::hesai_packet::Unit4B::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1hesai__packet_1_1Unit4B/#variable-reflectivity","title":"variable reflectivity","text":"<pre><code>uint8_t nebula::drivers::hesai_packet::Unit4B::reflectivity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet_1_1return__mode/","title":"Namespace nebula::drivers::hesai_packet::return_mode","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; hesai_packet &gt; return_mode</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet_1_1return__mode/#public-types","title":"Public Types","text":"Type Name enum ReturnMode"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet_1_1return__mode/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1hesai__packet_1_1return__mode/#enum-returnmode","title":"enum ReturnMode","text":"<pre><code>enum nebula::drivers::hesai_packet::return_mode::ReturnMode {\n    SINGLE_FIRST = 0x33,\n    SINGLE_SECOND = 0x34,\n    SINGLE_STRONGEST = 0x37,\n    SINGLE_LAST = 0x38,\n    DUAL_LAST_STRONGEST = 0x39,\n    DUAL_FIRST_SECOND = 0x3a,\n    DUAL_FIRST_LAST = 0x3b,\n    DUAL_FIRST_STRONGEST = 0x3c,\n    TRIPLE_FIRST_LAST_STRONGEST = 0x3d,\n    DUAL_STRONGEST_SECONDSTRONGEST = 0x3\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/","title":"Struct nebula::drivers::raw_block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; raw_block</p> <p>Raw Velodyne data block. More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data uint16_t header UPPER_BANK or LOWER_BANK. uint16_t rotation 0-35999, divide by 100 to get degrees"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#detailed-description","title":"Detailed Description","text":"<p>Each block contains data from either the upper or lower laser bank. The device returns three times as many upper bank blocks.</p> <p>use stdint.h types, so things work with both 64 and 32-bit machines </p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-data","title":"variable data","text":"<pre><code>uint8_t nebula::drivers::raw_block::data[BLOCK_DATA_SIZE];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-header","title":"variable header","text":"<pre><code>uint16_t nebula::drivers::raw_block::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-rotation","title":"variable rotation","text":"<pre><code>uint16_t nebula::drivers::raw_block::rotation;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/","title":"Struct nebula::drivers::raw_packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; raw_packet</p> <p>Raw Velodyne packet. More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#public-attributes","title":"Public Attributes","text":"Type Name raw_block_t blocks uint16_t revolution uint8_t status"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#detailed-description","title":"Detailed Description","text":"<p>revolution is described in the device manual as incrementing (mod 65536) for each physical turn of the device. Our device seems to alternate between two different values every third packet. One value increases, the other decreases.</p> <p>Todo</p> <p>figure out if revolution is only present for one of the two types of status fields</p> <p>status has either a temperature encoding or the microcode level </p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-blocks","title":"variable blocks","text":"<pre><code>raw_block_t nebula::drivers::raw_packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-revolution","title":"variable revolution","text":"<pre><code>uint16_t nebula::drivers::raw_packet::revolution;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-status","title":"variable status","text":"<pre><code>uint8_t nebula::drivers::raw_packet::status[PACKET_STATUS_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/","title":"Namespace nebula::drivers::robosense_packet","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; robosense_packet</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#namespaces","title":"Namespaces","text":"Type Name namespace bpearl_v3 namespace bpearl_v4 namespace helios"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#classes","title":"Classes","text":"Type Name struct Block &lt;typename UnitT, UnitN&gt; struct Body &lt;typename BlockT, BlockN&gt; struct ChannelAngleCorrection struct CorrectedHorizontalAngle struct CorrectedVerticalAngle struct Ethernet struct FirmwareVersion struct FovSetting struct IpAddress struct MacAddress struct PacketBase &lt;nBlocks, nChannels, maxReturns, degreeSubdivisions&gt;Base struct for all Robosense packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. struct SensorCalibration struct SerialNumber struct Timestamp struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint8_t ANGLE_SIGN_FLAG   = = 0x00"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#public-functions","title":"Public Functions","text":"Type Name double get_dis_unit (const PacketT &amp; packet) Get the distance unit of the given packet type in meters. Distance values in the packet, multiplied by this value, yield the distance in meters. double get_dis_unit&lt; bpearl_v3::Packet &gt; (const bpearl_v3::Packet &amp;) Get the distance unit of the given BpearlV3 packet in meters. double get_dis_unit&lt; bpearl_v4::Packet &gt; (const bpearl_v4::Packet &amp;) Get the distance unit of the given BpearlV3 packet in meters. std::string get_float_value (const uint16_t &amp; raw_angle) Convert raw angle value from packet to std::string. size_t get_n_returns (ReturnMode return_mode) Get the number of returns for a given return mode. uint64_t get_timestamp_ns (const PacketT &amp; packet) Get timestamp from packet in nanoseconds."},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#variable-angle_sign_flag","title":"variable ANGLE_SIGN_FLAG","text":"<pre><code>constexpr uint8_t nebula::drivers::robosense_packet::ANGLE_SIGN_FLAG;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_dis_unit","title":"function get_dis_unit","text":"<p>Get the distance unit of the given packet type in meters. Distance values in the packet, multiplied by this value, yield the distance in meters. <pre><code>template&lt;typename PacketT typename PacketT&gt;\ndouble nebula::drivers::robosense_packet::get_dis_unit (\n    const PacketT &amp; packet\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type </li> </ul> <p>Parameters:</p> <ul> <li><code>packet</code> The packet to get the distance unit from </li> </ul> <p>Returns:</p> <p>The distance unit in meters </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_dis_unit-bpearl_v3packet","title":"function get_dis_unit&lt; bpearl_v3::Packet &gt;","text":"<p>Get the distance unit of the given BpearlV3 packet in meters. <pre><code>template&lt;&gt;\ninline double nebula::drivers::robosense_packet::get_dis_unit&lt; bpearl_v3::Packet &gt; (\n    const bpearl_v3::Packet &amp;\n) \n</code></pre></p> <p>Returns:</p> <p>0.005m (0.5cm) </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_dis_unit-bpearl_v4packet","title":"function get_dis_unit&lt; bpearl_v4::Packet &gt;","text":"<p>Get the distance unit of the given BpearlV3 packet in meters. <pre><code>template&lt;&gt;\ninline double nebula::drivers::robosense_packet::get_dis_unit&lt; bpearl_v4::Packet &gt; (\n    const bpearl_v4::Packet &amp;\n) \n</code></pre></p> <p>Returns:</p> <p>0.0025m (0.25cm) </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_float_value","title":"function get_float_value","text":"<p>Convert raw angle value from packet to std::string. <pre><code>std::string nebula::drivers::robosense_packet::get_float_value (\n    const uint16_t &amp; raw_angle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>raw_angle</code> The raw angle value from the packet </li> </ul> <p>Returns:</p> <p>The angle as std::string </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_n_returns","title":"function get_n_returns","text":"<p>Get the number of returns for a given return mode. <pre><code>size_t nebula::drivers::robosense_packet::get_n_returns (\n    ReturnMode return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> The return mode </li> </ul> <p>Returns:</p> <p>The number of returns </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet/#function-get_timestamp_ns","title":"function get_timestamp_ns","text":"<p>Get timestamp from packet in nanoseconds. <pre><code>template&lt;typename PacketT typename PacketT&gt;\nuint64_t nebula::drivers::robosense_packet::get_timestamp_ns (\n    const PacketT &amp; packet\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>PacketT</code> The packet type </li> </ul> <p>Parameters:</p> <ul> <li><code>packet</code> The packet to get the timestamp from </li> </ul> <p>Returns:</p> <p>The timestamp in nanoseconds </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/","title":"Struct nebula::drivers::robosense_packet::Block","text":"<p>template &lt;typename UnitT typename UnitT, size_t UnitN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; Block</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-types","title":"Public Types","text":"Type Name typedef UnitT unit_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t azimuth big_uint16_buf_t flag UnitT units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-functions","title":"Public Functions","text":"Type Name uint16_t get_azimuth () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#typedef-unit_t","title":"typedef unit_t","text":"<pre><code>typedef UnitT nebula::drivers::robosense_packet::Block&lt; UnitT, UnitN &gt;::unit_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Block&lt; UnitT, UnitN &gt;::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#variable-flag","title":"variable flag","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Block&lt; UnitT, UnitN &gt;::flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#variable-units","title":"variable units","text":"<pre><code>UnitT nebula::drivers::robosense_packet::Block&lt; UnitT, UnitN &gt;::units[UnitN];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Block/#function-get_azimuth","title":"function get_azimuth","text":"<pre><code>inline uint16_t nebula::drivers::robosense_packet::Block::get_azimuth () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/","title":"Struct nebula::drivers::robosense_packet::Body","text":"<p>template &lt;typename BlockT typename BlockT, size_t BlockN&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; Body</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#public-types","title":"Public Types","text":"Type Name typedef BlockT block_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#public-attributes","title":"Public Attributes","text":"Type Name BlockT blocks"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#typedef-block_t","title":"typedef block_t","text":"<pre><code>typedef BlockT nebula::drivers::robosense_packet::Body&lt; BlockT, BlockN &gt;::block_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Body/#variable-blocks","title":"variable blocks","text":"<pre><code>BlockT nebula::drivers::robosense_packet::Body&lt; BlockT, BlockN &gt;::blocks[BlockN];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/","title":"Struct nebula::drivers::robosense_packet::ChannelAngleCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; ChannelAngleCorrection</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t angle big_uint8_buf_t sign"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#public-functions","title":"Public Functions","text":"Type Name float getAngle () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#variable-angle","title":"variable angle","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::ChannelAngleCorrection::angle;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#variable-sign","title":"variable sign","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::ChannelAngleCorrection::sign;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1ChannelAngleCorrection/#function-getangle","title":"function getAngle","text":"<pre><code>inline float nebula::drivers::robosense_packet::ChannelAngleCorrection::getAngle () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedHorizontalAngle/","title":"Struct nebula::drivers::robosense_packet::CorrectedHorizontalAngle","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; CorrectedHorizontalAngle</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedHorizontalAngle/#public-attributes","title":"Public Attributes","text":"Type Name ChannelAngleCorrection angles"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedHorizontalAngle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedHorizontalAngle/#variable-angles","title":"variable angles","text":"<pre><code>ChannelAngleCorrection nebula::drivers::robosense_packet::CorrectedHorizontalAngle::angles[32];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedVerticalAngle/","title":"Struct nebula::drivers::robosense_packet::CorrectedVerticalAngle","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; CorrectedVerticalAngle</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedVerticalAngle/#public-attributes","title":"Public Attributes","text":"Type Name ChannelAngleCorrection angles"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedVerticalAngle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1CorrectedVerticalAngle/#variable-angles","title":"variable angles","text":"<pre><code>ChannelAngleCorrection nebula::drivers::robosense_packet::CorrectedVerticalAngle::angles[32];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/","title":"Struct nebula::drivers::robosense_packet::Ethernet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; Ethernet</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#public-attributes","title":"Public Attributes","text":"Type Name IpAddress dest_pc_ip IpAddress lidar_ip big_uint16_buf_t lidar_out_difop_port big_uint16_buf_t lidar_out_msop_port MacAddress mac_addr big_uint16_buf_t pc_dest_difop_port big_uint16_buf_t pc_dest_msop_port"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-dest_pc_ip","title":"variable dest_pc_ip","text":"<pre><code>IpAddress nebula::drivers::robosense_packet::Ethernet::dest_pc_ip;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-lidar_ip","title":"variable lidar_ip","text":"<pre><code>IpAddress nebula::drivers::robosense_packet::Ethernet::lidar_ip;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-lidar_out_difop_port","title":"variable lidar_out_difop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Ethernet::lidar_out_difop_port;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-lidar_out_msop_port","title":"variable lidar_out_msop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Ethernet::lidar_out_msop_port;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-mac_addr","title":"variable mac_addr","text":"<pre><code>MacAddress nebula::drivers::robosense_packet::Ethernet::mac_addr;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-pc_dest_difop_port","title":"variable pc_dest_difop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Ethernet::pc_dest_difop_port;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Ethernet/#variable-pc_dest_msop_port","title":"variable pc_dest_msop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Ethernet::pc_dest_msop_port;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/","title":"Struct nebula::drivers::robosense_packet::FirmwareVersion","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; FirmwareVersion</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t fifth_octet big_uint8_buf_t first_octet big_uint8_buf_t fourth_octet big_uint8_buf_t second_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#variable-fifth_octet","title":"variable fifth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::FirmwareVersion::fifth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::FirmwareVersion::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#variable-fourth_octet","title":"variable fourth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::FirmwareVersion::fourth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::FirmwareVersion::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::FirmwareVersion::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FirmwareVersion/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::FirmwareVersion::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FovSetting/","title":"Struct nebula::drivers::robosense_packet::FovSetting","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; FovSetting</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FovSetting/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t fov_end big_uint16_buf_t fov_start"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FovSetting/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FovSetting/#variable-fov_end","title":"variable fov_end","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::FovSetting::fov_end;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1FovSetting/#variable-fov_start","title":"variable fov_start","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::FovSetting::fov_start;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/","title":"Struct nebula::drivers::robosense_packet::IpAddress","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; IpAddress</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t first_octet big_uint8_buf_t fourth_octet big_uint8_buf_t second_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::IpAddress::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#variable-fourth_octet","title":"variable fourth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::IpAddress::fourth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::IpAddress::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::IpAddress::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1IpAddress/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::IpAddress::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/","title":"Struct nebula::drivers::robosense_packet::MacAddress","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; MacAddress</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t fifth_octet big_uint8_buf_t first_octet big_uint8_buf_t fourth_octet big_uint8_buf_t second_octet big_uint8_buf_t sixth_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-fifth_octet","title":"variable fifth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::fifth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-fourth_octet","title":"variable fourth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::fourth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-sixth_octet","title":"variable sixth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::sixth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::MacAddress::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1MacAddress/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::MacAddress::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/","title":"Struct nebula::drivers::robosense_packet::PacketBase","text":"<p>template &lt;size_t nBlocks, size_t nChannels, size_t maxReturns, size_t degreeSubdivisions&gt;</p> <p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; PacketBase</p> <p>Base struct for all Robosense packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. More...</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>nBlocks</code> The number of blocks in the packet </li> <li><code>nChannels</code> The number of channels per block </li> <li><code>maxReturns</code> The maximum number of returns, e.g. 2 for dual return </li> <li><code>degreeSubdivisions</code> The resolution of the azimuth angle in the packet, e.g. 100 if packet azimuth is given in 1/100th of a degree </li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#variable-degree_subdivisions","title":"variable DEGREE_SUBDIVISIONS","text":"<pre><code>constexpr size_t nebula::drivers::robosense_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::DEGREE_SUBDIVISIONS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#variable-max_returns","title":"variable MAX_RETURNS","text":"<pre><code>constexpr size_t nebula::drivers::robosense_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::MAX_RETURNS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#variable-n_blocks","title":"variable N_BLOCKS","text":"<pre><code>constexpr size_t nebula::drivers::robosense_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::N_BLOCKS;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1PacketBase/#variable-n_channels","title":"variable N_CHANNELS","text":"<pre><code>constexpr size_t nebula::drivers::robosense_packet::PacketBase&lt; nBlocks, nChannels, maxReturns, degreeSubdivisions &gt;::N_CHANNELS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/","title":"Struct nebula::drivers::robosense_packet::SensorCalibration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; SensorCalibration</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#public-attributes","title":"Public Attributes","text":"Type Name CorrectedHorizontalAngle corrected_horizontal_angle CorrectedVerticalAngle corrected_vertical_angle"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#public-functions","title":"Public Functions","text":"Type Name RobosenseCalibrationConfiguration getCalibration () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#variable-corrected_horizontal_angle","title":"variable corrected_horizontal_angle","text":"<pre><code>CorrectedHorizontalAngle nebula::drivers::robosense_packet::SensorCalibration::corrected_horizontal_angle;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#variable-corrected_vertical_angle","title":"variable corrected_vertical_angle","text":"<pre><code>CorrectedVerticalAngle nebula::drivers::robosense_packet::SensorCalibration::corrected_vertical_angle;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SensorCalibration/#function-getcalibration","title":"function getCalibration","text":"<pre><code>inline RobosenseCalibrationConfiguration nebula::drivers::robosense_packet::SensorCalibration::getCalibration () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/","title":"Struct nebula::drivers::robosense_packet::SerialNumber","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; SerialNumber</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t fifth_octet big_uint8_buf_t first_octet big_uint8_buf_t fourth_octet big_uint8_buf_t second_octet big_uint8_buf_t sixth_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-fifth_octet","title":"variable fifth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::fifth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-fourth_octet","title":"variable fourth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::fourth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-sixth_octet","title":"variable sixth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::sixth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::SerialNumber::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1SerialNumber/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::SerialNumber::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/","title":"Struct nebula::drivers::robosense_packet::Timestamp","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; Timestamp</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#public-attributes","title":"Public Attributes","text":"Type Name big_uint32_buf_t microseconds big_uint48_buf_t seconds"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#public-functions","title":"Public Functions","text":"Type Name uint64_t get_time_in_ns () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#variable-microseconds","title":"variable microseconds","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::Timestamp::microseconds;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#variable-seconds","title":"variable seconds","text":"<pre><code>big_uint48_buf_t nebula::drivers::robosense_packet::Timestamp::seconds;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Timestamp/#function-get_time_in_ns","title":"function get_time_in_ns","text":"<pre><code>inline uint64_t nebula::drivers::robosense_packet::Timestamp::get_time_in_ns () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Unit/","title":"Struct nebula::drivers::robosense_packet::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; Unit</p> <ul> <li><code>#include &lt;robosense_packet.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t distance big_uint8_buf_t reflectivity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1Unit/#variable-reflectivity","title":"variable reflectivity","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::Unit::reflectivity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3/","title":"Namespace nebula::drivers::robosense_packet::bpearl_v3","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3/#classes","title":"Classes","text":"Type Name struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet struct Timestamp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; FaultDiagnosis</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t gps_st big_uint16_buf_t manc_err1 big_uint16_buf_t manc_err2 big_uint8_buf_t r_rpm1 big_uint8_buf_t r_rpm2 uint8_t reserved_first uint8_t reserved_fourth uint8_t reserved_second uint8_t reserved_third big_uint8_buf_t temperature1 big_uint8_buf_t temperature2 big_uint8_buf_t temperature3 big_uint8_buf_t temperature4 big_uint8_buf_t temperature5 big_uint8_buf_t temperature6"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-gps_st","title":"variable gps_st","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::gps_st;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-manc_err1","title":"variable manc_err1","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::manc_err1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-manc_err2","title":"variable manc_err2","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::manc_err2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-r_rpm1","title":"variable r_rpm1","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::r_rpm1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-r_rpm2","title":"variable r_rpm2","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::r_rpm2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::reserved_first[11];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::reserved_fourth[7];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::reserved_second[2];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::reserved_third[7];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature1","title":"variable temperature1","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature2","title":"variable temperature2","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature3","title":"variable temperature3","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature3;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature4","title":"variable temperature4","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature4;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature5","title":"variable temperature5","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature5;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1FaultDiagnosis/#variable-temperature6","title":"variable temperature6","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis::temperature6;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; Header</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name big_uint32_buf_t checksum big_uint64_buf_t header_id big_uint8_buf_t lidar_model big_uint32_buf_t packet_count big_uint32_buf_t reserved_first uint8_t reserved_second big_uint16_buf_t temperature Timestamp timestamp big_uint16_buf_t top_board_temperature"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-checksum","title":"variable checksum","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::checksum;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-header_id","title":"variable header_id","text":"<pre><code>big_uint64_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::header_id;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-lidar_model","title":"variable lidar_model","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::lidar_model;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-packet_count","title":"variable packet_count","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::packet_count;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::reserved_first;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::Header::reserved_second[7];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-temperature","title":"variable temperature","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::temperature;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-timestamp","title":"variable timestamp","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::bpearl_v3::Header::timestamp;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Header/#variable-top_board_temperature","title":"variable top_board_temperature","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::Header::top_board_temperature;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::InfoPacket","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; InfoPacket</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#public-attributes","title":"Public Attributes","text":"Type Name FirmwareVersion bottom_firmware_version FirmwareVersion bottom_software_version big_uint32_buf_t elapsed_time_flag Ethernet ethernet FaultDiagnosis fault_diagnosis FovSetting fov_setting big_uint8_buf_t gprmc big_uint64_buf_t header FirmwareVersion motor_firmware_version big_uint16_buf_t motor_speed OperatingStatus operating_status big_uint16_buf_t phase_lock uint8_t reserved_first uint8_t reserved_fourth uint8_t reserved_second big_uint8_buf_t return_mode big_uint16_buf_t reverse_zero_angle_offset big_uint8_buf_t rotation_direction SensorCalibration sensor_calibration SerialNumber serial_number big_uint8_buf_t sync_status big_uint16_buf_t tail big_uint16_buf_t tcp_msop_port Timestamp time big_uint8_buf_t time_sync_mode FirmwareVersion top_firmware_version big_uint16_buf_t zero_angle_offset"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-bottom_firmware_version","title":"variable bottom_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::bottom_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-bottom_software_version","title":"variable bottom_software_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::bottom_software_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-elapsed_time_flag","title":"variable elapsed_time_flag","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::elapsed_time_flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-ethernet","title":"variable ethernet","text":"<pre><code>Ethernet nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::ethernet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-fault_diagnosis","title":"variable fault_diagnosis","text":"<pre><code>FaultDiagnosis nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::fault_diagnosis;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-fov_setting","title":"variable fov_setting","text":"<pre><code>FovSetting nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::fov_setting;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-gprmc","title":"variable gprmc","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::gprmc[86];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-header","title":"variable header","text":"<pre><code>big_uint64_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-motor_firmware_version","title":"variable motor_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::motor_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-operating_status","title":"variable operating_status","text":"<pre><code>OperatingStatus nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::operating_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-phase_lock","title":"variable phase_lock","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::phase_lock;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::reserved_first[230];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::reserved_fourth[586];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::reserved_second[6];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-return_mode","title":"variable return_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-reverse_zero_angle_offset","title":"variable reverse_zero_angle_offset","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::reverse_zero_angle_offset;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-rotation_direction","title":"variable rotation_direction","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::rotation_direction;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-sensor_calibration","title":"variable sensor_calibration","text":"<pre><code>SensorCalibration nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::sensor_calibration;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-serial_number","title":"variable serial_number","text":"<pre><code>SerialNumber nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::serial_number;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-sync_status","title":"variable sync_status","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::sync_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-tail","title":"variable tail","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-tcp_msop_port","title":"variable tcp_msop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::tcp_msop_port;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-time","title":"variable time","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-time_sync_mode","title":"variable time_sync_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::time_sync_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-top_firmware_version","title":"variable top_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::top_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1InfoPacket/#variable-zero_angle_offset","title":"variable zero_angle_offset","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::InfoPacket::zero_angle_offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; OperatingStatus</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#public-attributes","title":"Public Attributes","text":"Type Name big_uint48_buf_t reserved big_uint16_buf_t v_dat_0v big_uint16_buf_t v_dat_0v5 big_uint16_buf_t v_dat_12v big_uint16_buf_t v_dat_1v big_uint16_buf_t v_dat_1v25 big_uint16_buf_t v_dat_5v"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-reserved","title":"variable reserved","text":"<pre><code>big_uint48_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::reserved;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_0v","title":"variable v_dat_0v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_0v;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_0v5","title":"variable v_dat_0v5","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_0v5;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_12v","title":"variable v_dat_12v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_12v;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_1v","title":"variable v_dat_1v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_1v;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_1v25","title":"variable v_dat_1v25","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_1v25;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1OperatingStatus/#variable-v_dat_5v","title":"variable v_dat_5v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus::v_dat_5v;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; Packet</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::robosense_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit, Packet::N_CHANNELS &gt;, Packet::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header header big_uint48_buf_t tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#public-static-attributes-inherited-from-nebuladriversrobosense_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::robosense_packet::PacketBase","text":"<p>See nebula::drivers::robosense_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; nebula::drivers::robosense_packet::bpearl_v3::Packet::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::robosense_packet::bpearl_v3::Packet::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::robosense_packet::bpearl_v3::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Packet/#variable-tail","title":"variable tail","text":"<pre><code>big_uint48_buf_t nebula::drivers::robosense_packet::bpearl_v3::Packet::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/","title":"Struct nebula::drivers::robosense_packet::bpearl_v3::Timestamp","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v3 &gt; Timestamp</p> <ul> <li><code>#include &lt;bpearl_v3.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t day big_uint8_buf_t hour big_uint16_buf_t microsecond big_uint16_buf_t millisecond big_uint8_buf_t minute big_uint8_buf_t month big_uint8_buf_t second big_uint8_buf_t year"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#public-functions","title":"Public Functions","text":"Type Name uint64_t get_time_in_ns () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-day","title":"variable day","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::day;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-hour","title":"variable hour","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::hour;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-microsecond","title":"variable microsecond","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::microsecond;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-millisecond","title":"variable millisecond","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::millisecond;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-minute","title":"variable minute","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::minute;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-month","title":"variable month","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::month;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-second","title":"variable second","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#variable-year","title":"variable year","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::year;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v3_1_1Timestamp/#function-get_time_in_ns","title":"function get_time_in_ns","text":"<pre><code>inline uint64_t nebula::drivers::robosense_packet::bpearl_v3::Timestamp::get_time_in_ns () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4/","title":"Namespace nebula::drivers::robosense_packet::bpearl_v4","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4/#classes","title":"Classes","text":"Type Name struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/","title":"Struct nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4 &gt; FaultDiagnosis</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t gps_status big_uint16_buf_t machine_temp big_uint16_buf_t phase big_uint32_buf_t reserved uint8_t reserved_first big_uint16_buf_t rotation_speed big_uint16_buf_t startup_times"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-gps_status","title":"variable gps_status","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::gps_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-machine_temp","title":"variable machine_temp","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::machine_temp;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-phase","title":"variable phase","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::phase;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-reserved","title":"variable reserved","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::reserved;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::reserved_first[11];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::rotation_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1FaultDiagnosis/#variable-startup_times","title":"variable startup_times","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis::startup_times;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/","title":"Struct nebula::drivers::robosense_packet::bpearl_v4::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4 &gt; Header</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name big_uint64_buf_t header_id big_uint8_buf_t lidar_model big_uint8_buf_t lidar_type big_uint32_buf_t packet_count uint8_t reserved_first uint8_t reserved_fourth uint8_t reserved_second uint8_t reserved_third Timestamp timestamp"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-header_id","title":"variable header_id","text":"<pre><code>big_uint64_buf_t nebula::drivers::robosense_packet::bpearl_v4::Header::header_id;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-lidar_model","title":"variable lidar_model","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::Header::lidar_model;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-lidar_type","title":"variable lidar_type","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::Header::lidar_type;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-packet_count","title":"variable packet_count","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v4::Header::packet_count;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::Header::reserved_first[4];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::Header::reserved_fourth[9];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::Header::reserved_second[4];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::Header::reserved_third[1];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Header/#variable-timestamp","title":"variable timestamp","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::bpearl_v4::Header::timestamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/","title":"Struct nebula::drivers::robosense_packet::bpearl_v4::InfoPacket","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4 &gt; InfoPacket</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#public-attributes","title":"Public Attributes","text":"Type Name FirmwareVersion app_software_version big_uint8_buf_t baud_rate FirmwareVersion bottom_firmware_version Ethernet ethernet FaultDiagnosis fault_diagnosis FovSetting fov_setting big_uint8_buf_t gprmc big_uint64_buf_t header FirmwareVersion mainboard_firmware_version FirmwareVersion motor_firmware_version big_uint16_buf_t motor_speed_setting OperatingStatus operating_status big_uint16_buf_t phase_lock uint8_t reserved_fifth uint8_t reserved_first uint8_t reserved_fourth uint8_t reserved_second uint8_t reserved_sixth uint8_t reserved_third big_uint8_buf_t return_mode big_uint8_buf_t rotation_direction big_uint32_buf_t running_time SensorCalibration sensor_calibration SerialNumber serial_number big_uint16_buf_t tail big_uint16_buf_t tcp_msop_port Timestamp time big_uint8_buf_t time_sync_mode big_uint8_buf_t time_sync_state"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-app_software_version","title":"variable app_software_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::app_software_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-baud_rate","title":"variable baud_rate","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::baud_rate;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-bottom_firmware_version","title":"variable bottom_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::bottom_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-ethernet","title":"variable ethernet","text":"<pre><code>Ethernet nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::ethernet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-fault_diagnosis","title":"variable fault_diagnosis","text":"<pre><code>FaultDiagnosis nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::fault_diagnosis;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-fov_setting","title":"variable fov_setting","text":"<pre><code>FovSetting nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::fov_setting;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-gprmc","title":"variable gprmc","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::gprmc[86];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-header","title":"variable header","text":"<pre><code>big_uint64_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-mainboard_firmware_version","title":"variable mainboard_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::mainboard_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-motor_firmware_version","title":"variable motor_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::motor_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-motor_speed_setting","title":"variable motor_speed_setting","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::motor_speed_setting;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-operating_status","title":"variable operating_status","text":"<pre><code>OperatingStatus nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::operating_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-phase_lock","title":"variable phase_lock","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::phase_lock;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_fifth","title":"variable reserved_fifth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_fifth[7];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_first[228];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_fourth[9];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_second[3];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_sixth","title":"variable reserved_sixth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_sixth[586];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::reserved_third[2];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-return_mode","title":"variable return_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-rotation_direction","title":"variable rotation_direction","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::rotation_direction;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-running_time","title":"variable running_time","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::running_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-sensor_calibration","title":"variable sensor_calibration","text":"<pre><code>SensorCalibration nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::sensor_calibration;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-serial_number","title":"variable serial_number","text":"<pre><code>SerialNumber nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::serial_number;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-tail","title":"variable tail","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-tcp_msop_port","title":"variable tcp_msop_port","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::tcp_msop_port;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-time","title":"variable time","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-time_sync_mode","title":"variable time_sync_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::time_sync_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1InfoPacket/#variable-time_sync_state","title":"variable time_sync_state","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::InfoPacket::time_sync_state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/","title":"Struct nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4 &gt; OperatingStatus</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t machine_current big_uint16_buf_t machine_voltage big_uint8_buf_t reserved_first big_uint24_buf_t reserved_second uint8_t reserved_third"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#variable-machine_current","title":"variable machine_current","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus::machine_current;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#variable-machine_voltage","title":"variable machine_voltage","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus::machine_voltage;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus::reserved_first;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>big_uint24_buf_t nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus::reserved_second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1OperatingStatus/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus::reserved_third[16];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/","title":"Struct nebula::drivers::robosense_packet::bpearl_v4::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; bpearl_v4 &gt; Packet</p> <ul> <li><code>#include &lt;bpearl_v4.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::robosense_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit, Packet::N_CHANNELS &gt;, Packet::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header header big_uint48_buf_t tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#public-static-attributes-inherited-from-nebuladriversrobosense_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::robosense_packet::PacketBase","text":"<p>See nebula::drivers::robosense_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; nebula::drivers::robosense_packet::bpearl_v4::Packet::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::robosense_packet::bpearl_v4::Packet::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::robosense_packet::bpearl_v4::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1bpearl__v4_1_1Packet/#variable-tail","title":"variable tail","text":"<pre><code>big_uint48_buf_t nebula::drivers::robosense_packet::bpearl_v4::Packet::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1helios/","title":"Namespace nebula::drivers::robosense_packet::helios","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1robosense__packet_1_1helios/#classes","title":"Classes","text":"Type Name struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet struct SensorHwVersion struct WebPageVersion <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/","title":"Struct nebula::drivers::robosense_packet::helios::FaultDiagnosis","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; FaultDiagnosis</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t gps_status big_uint8_buf_t lane_up big_uint16_buf_t lane_up_cnt big_uint16_buf_t r_rpm big_uint16_buf_t temperature1 big_uint16_buf_t temperature2 big_uint16_buf_t temperature3 big_uint16_buf_t temperature4 big_uint16_buf_t temperature5 big_uint16_buf_t top_status"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-gps_status","title":"variable gps_status","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::gps_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-lane_up","title":"variable lane_up","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::lane_up;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-lane_up_cnt","title":"variable lane_up_cnt","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::lane_up_cnt;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-r_rpm","title":"variable r_rpm","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::r_rpm;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-temperature1","title":"variable temperature1","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::temperature1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-temperature2","title":"variable temperature2","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::temperature2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-temperature3","title":"variable temperature3","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::temperature3;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-temperature4","title":"variable temperature4","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::temperature4;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-temperature5","title":"variable temperature5","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::temperature5;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1FaultDiagnosis/#variable-top_status","title":"variable top_status","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::FaultDiagnosis::top_status;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/","title":"Struct nebula::drivers::robosense_packet::helios::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; Header</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t angle_interval_count big_uint32_buf_t bottom_packet_count big_uint32_buf_t header_id big_uint8_buf_t lidar_model big_uint8_buf_t lidar_type big_uint16_buf_t protocol_version big_uint8_buf_t range_resolution big_uint16_buf_t reserved_first big_uint8_buf_t reserved_fourth big_uint8_buf_t reserved_second big_uint8_buf_t reserved_third Timestamp timestamp big_uint32_buf_t top_packet_count"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-angle_interval_count","title":"variable angle_interval_count","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::Header::angle_interval_count;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-bottom_packet_count","title":"variable bottom_packet_count","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::Header::bottom_packet_count;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-header_id","title":"variable header_id","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::Header::header_id;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-lidar_model","title":"variable lidar_model","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::lidar_model;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-lidar_type","title":"variable lidar_type","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::lidar_type;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-protocol_version","title":"variable protocol_version","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::Header::protocol_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-range_resolution","title":"variable range_resolution","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::range_resolution;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::Header::reserved_first;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::reserved_fourth[9];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::reserved_second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::Header::reserved_third;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-timestamp","title":"variable timestamp","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::helios::Header::timestamp;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Header/#variable-top_packet_count","title":"variable top_packet_count","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::Header::top_packet_count;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/","title":"Struct nebula::drivers::robosense_packet::helios::InfoPacket","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; InfoPacket</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#public-attributes","title":"Public Attributes","text":"Type Name big_uint32_buf_t bottom_backup_crc FirmwareVersion bottom_firmware_version FirmwareVersion bottom_software_version big_uint8_buf_t code_wheel_status Ethernet ethernet IpAddress ethernet_gateway FaultDiagnosis fault_diagnosis FovSetting fov_setting big_uint8_buf_t gprmc big_uint64_buf_t header FirmwareVersion motor_firmware_version big_uint16_buf_t motor_speed OperatingStatus operating_status big_uint16_buf_t phase_lock big_uint8_buf_t pps_trigger_mode uint8_t reserved_fifth big_uint16_buf_t reserved_first uint8_t reserved_fourth uint8_t reserved_second uint8_t reserved_third big_uint8_buf_t return_mode SensorCalibration sensor_calibration SensorHwVersion sensor_hw_version SerialNumber serial_number big_uint32_buf_t software_backup_crc IpAddress subnet_mask big_uint8_buf_t sync_status big_uint16_buf_t tail Timestamp time big_uint8_buf_t time_sync_mode big_uint32_buf_t top_backup_crc FirmwareVersion top_firmware_version WebPageVersion web_page_version big_uint32_buf_t webpage_backup_crc big_uint16_buf_t zero_angle_offset"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-bottom_backup_crc","title":"variable bottom_backup_crc","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::bottom_backup_crc;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-bottom_firmware_version","title":"variable bottom_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::helios::InfoPacket::bottom_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-bottom_software_version","title":"variable bottom_software_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::helios::InfoPacket::bottom_software_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-code_wheel_status","title":"variable code_wheel_status","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::code_wheel_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-ethernet","title":"variable ethernet","text":"<pre><code>Ethernet nebula::drivers::robosense_packet::helios::InfoPacket::ethernet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-ethernet_gateway","title":"variable ethernet_gateway","text":"<pre><code>IpAddress nebula::drivers::robosense_packet::helios::InfoPacket::ethernet_gateway;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-fault_diagnosis","title":"variable fault_diagnosis","text":"<pre><code>FaultDiagnosis nebula::drivers::robosense_packet::helios::InfoPacket::fault_diagnosis;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-fov_setting","title":"variable fov_setting","text":"<pre><code>FovSetting nebula::drivers::robosense_packet::helios::InfoPacket::fov_setting;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-gprmc","title":"variable gprmc","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::gprmc[86];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-header","title":"variable header","text":"<pre><code>big_uint64_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-motor_firmware_version","title":"variable motor_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::helios::InfoPacket::motor_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-operating_status","title":"variable operating_status","text":"<pre><code>OperatingStatus nebula::drivers::robosense_packet::helios::InfoPacket::operating_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-phase_lock","title":"variable phase_lock","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::phase_lock;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-pps_trigger_mode","title":"variable pps_trigger_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::pps_trigger_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-reserved_fifth","title":"variable reserved_fifth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::helios::InfoPacket::reserved_fifth[586];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-reserved_first","title":"variable reserved_first","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::reserved_first;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-reserved_fourth","title":"variable reserved_fourth","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::helios::InfoPacket::reserved_fourth[20];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-reserved_second","title":"variable reserved_second","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::helios::InfoPacket::reserved_second[201];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-reserved_third","title":"variable reserved_third","text":"<pre><code>uint8_t nebula::drivers::robosense_packet::helios::InfoPacket::reserved_third[17];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-return_mode","title":"variable return_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-sensor_calibration","title":"variable sensor_calibration","text":"<pre><code>SensorCalibration nebula::drivers::robosense_packet::helios::InfoPacket::sensor_calibration;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-sensor_hw_version","title":"variable sensor_hw_version","text":"<pre><code>SensorHwVersion nebula::drivers::robosense_packet::helios::InfoPacket::sensor_hw_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-serial_number","title":"variable serial_number","text":"<pre><code>SerialNumber nebula::drivers::robosense_packet::helios::InfoPacket::serial_number;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-software_backup_crc","title":"variable software_backup_crc","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::software_backup_crc;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-subnet_mask","title":"variable subnet_mask","text":"<pre><code>IpAddress nebula::drivers::robosense_packet::helios::InfoPacket::subnet_mask;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-sync_status","title":"variable sync_status","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::sync_status;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-tail","title":"variable tail","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::tail;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-time","title":"variable time","text":"<pre><code>Timestamp nebula::drivers::robosense_packet::helios::InfoPacket::time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-time_sync_mode","title":"variable time_sync_mode","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::time_sync_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-top_backup_crc","title":"variable top_backup_crc","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::top_backup_crc;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-top_firmware_version","title":"variable top_firmware_version","text":"<pre><code>FirmwareVersion nebula::drivers::robosense_packet::helios::InfoPacket::top_firmware_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-web_page_version","title":"variable web_page_version","text":"<pre><code>WebPageVersion nebula::drivers::robosense_packet::helios::InfoPacket::web_page_version;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-webpage_backup_crc","title":"variable webpage_backup_crc","text":"<pre><code>big_uint32_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::webpage_backup_crc;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1InfoPacket/#variable-zero_angle_offset","title":"variable zero_angle_offset","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::InfoPacket::zero_angle_offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/","title":"Struct nebula::drivers::robosense_packet::helios::OperatingStatus","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; OperatingStatus</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#public-attributes","title":"Public Attributes","text":"Type Name big_uint16_buf_t i_dat big_uint16_buf_t v_dat big_uint16_buf_t v_dat_12v big_uint16_buf_t v_dat_2v5 big_uint16_buf_t v_dat_5v big_uint16_buf_t v_dat_apd"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-i_dat","title":"variable i_dat","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::i_dat;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-v_dat","title":"variable v_dat","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::v_dat;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-v_dat_12v","title":"variable v_dat_12v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::v_dat_12v;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-v_dat_2v5","title":"variable v_dat_2v5","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::v_dat_2v5;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-v_dat_5v","title":"variable v_dat_5v","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::v_dat_5v;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1OperatingStatus/#variable-v_dat_apd","title":"variable v_dat_apd","text":"<pre><code>big_uint16_buf_t nebula::drivers::robosense_packet::helios::OperatingStatus::v_dat_apd;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/","title":"Struct nebula::drivers::robosense_packet::helios::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; Packet</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::robosense_packet::PacketBase</p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#public-types","title":"Public Types","text":"Type Name typedef Body&lt; Block&lt; Unit, Packet::N_CHANNELS &gt;, Packet::N_BLOCKS &gt; body_t"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name body_t body Header header big_uint48_buf_t tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#public-static-attributes-inherited-from-nebuladriversrobosense_packetpacketbase","title":"Public Static Attributes inherited from nebula::drivers::robosense_packet::PacketBase","text":"<p>See nebula::drivers::robosense_packet::PacketBase</p> Type Name constexpr size_t DEGREE_SUBDIVISIONS   = = degreeSubdivisions constexpr size_t MAX_RETURNS   = = maxReturns constexpr size_t N_BLOCKS   = = nBlocks constexpr size_t N_CHANNELS   = = nChannels"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#typedef-body_t","title":"typedef body_t","text":"<pre><code>typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; nebula::drivers::robosense_packet::helios::Packet::body_t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#variable-body","title":"variable body","text":"<pre><code>body_t nebula::drivers::robosense_packet::helios::Packet::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::robosense_packet::helios::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1Packet/#variable-tail","title":"variable tail","text":"<pre><code>big_uint48_buf_t nebula::drivers::robosense_packet::helios::Packet::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/","title":"Struct nebula::drivers::robosense_packet::helios::SensorHwVersion","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; SensorHwVersion</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t first_octet big_uint8_buf_t second_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::SensorHwVersion::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::SensorHwVersion::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::SensorHwVersion::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1SensorHwVersion/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::helios::SensorHwVersion::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/","title":"Struct nebula::drivers::robosense_packet::helios::WebPageVersion","text":"<p>ClassList &gt; nebula &gt; drivers &gt; robosense_packet &gt; helios &gt; WebPageVersion</p> <ul> <li><code>#include &lt;helios.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#public-attributes","title":"Public Attributes","text":"Type Name big_uint8_buf_t first_octet big_uint8_buf_t fourth_octet big_uint8_buf_t second_octet big_uint8_buf_t third_octet"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#public-functions","title":"Public Functions","text":"Type Name std::string to_string () const"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#variable-first_octet","title":"variable first_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::WebPageVersion::first_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#variable-fourth_octet","title":"variable fourth_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::WebPageVersion::fourth_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#variable-second_octet","title":"variable second_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::WebPageVersion::second_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#variable-third_octet","title":"variable third_octet","text":"<pre><code>big_uint8_buf_t nebula::drivers::robosense_packet::helios::WebPageVersion::third_octet;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1robosense__packet_1_1helios_1_1WebPageVersion/#function-to_string","title":"function to_string","text":"<pre><code>inline std::string nebula::drivers::robosense_packet::helios::WebPageVersion::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/","title":"Union nebula::drivers::two_bytes","text":"<p>ClassList &gt; nebula &gt; drivers &gt; two_bytes</p> <p>More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bytes uint16_t uint"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#detailed-description","title":"Detailed Description","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#variable-bytes","title":"variable bytes","text":"<pre><code>uint8_t nebula::drivers::two_bytes::bytes[2];\n</code></pre>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#variable-uint","title":"variable uint","text":"<pre><code>uint16_t nebula::drivers::two_bytes::uint;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/","title":"Namespace nebula::drivers::vlp16","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vlp16</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#classes","title":"Classes","text":"Type Name class Vlp16Decoder Velodyne LiDAR decoder (VLP16)"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t MAX_POINTS   = = 300000"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#variable-max_points","title":"variable MAX_POINTS","text":"<pre><code>constexpr uint32_t nebula::drivers::vlp16::MAX_POINTS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/","title":"Class nebula::drivers::vlp16::Vlp16Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vlp16 &gt; Vlp16Decoder</p> <p>Velodyne LiDAR decoder (VLP16) </p> <ul> <li><code>#include &lt;vlp16_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions","title":"Public Functions","text":"Type Name Vlp16Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow (double time_stamp) overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow (double time_stamp) = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-vlp16decoder","title":"function Vlp16Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vlp16::Vlp16Decoder::Vlp16Decoder (\n    const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vlp16::Vlp16Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vlp16::Vlp16Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vlp16::Vlp16Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::reset_overflow (\n    double time_stamp\n) override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::reset_pointcloud (\n    size_t n_pts,\n    double time_stamp\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::unpack (\n    const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp32/","title":"Namespace nebula::drivers::vlp32","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vlp32</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp32/#classes","title":"Classes","text":"Type Name class Vlp32Decoder Velodyne LiDAR decoder (VLP32) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/","title":"Class nebula::drivers::vlp32::Vlp32Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vlp32 &gt; Vlp32Decoder</p> <p>Velodyne LiDAR decoder (VLP32) </p> <ul> <li><code>#include &lt;vlp32_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions","title":"Public Functions","text":"Type Name Vlp32Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow (double time_stamp) overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow (double time_stamp) = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-vlp32decoder","title":"function Vlp32Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vlp32::Vlp32Decoder::Vlp32Decoder (\n    const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vlp32::Vlp32Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vlp32::Vlp32Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vlp32::Vlp32Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::reset_overflow (\n    double time_stamp\n) override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::reset_pointcloud (\n    size_t n_pts,\n    double time_stamp\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::unpack (\n    const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vls128/","title":"Namespace nebula::drivers::vls128","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vls128</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vls128/#classes","title":"Classes","text":"Type Name class Vls128Decoder Velodyne LiDAR decoder (VLS128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/","title":"Class nebula::drivers::vls128::Vls128Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vls128 &gt; Vls128Decoder</p> <p>Velodyne LiDAR decoder (VLS128) </p> <ul> <li><code>#include &lt;vls128_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions","title":"Public Functions","text":"Type Name Vls128Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow (double time_stamp) overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow (double time_stamp) = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts, double time_stamp) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-vls128decoder","title":"function Vls128Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vls128::Vls128Decoder::Vls128Decoder (\n    const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vls128::Vls128Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vls128::Vls128Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vls128::Vls128Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::reset_overflow (\n    double time_stamp\n) override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::reset_pointcloud (\n    size_t n_pts,\n    double time_stamp\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::unpack (\n    const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/dir_092e1212e2f122a1b02d21090e0bc2ae/","title":"Dir nebula_decoders","text":"<p>FileList &gt; nebula_decoders</p>"},{"location":"nebula_decoders/dir_092e1212e2f122a1b02d21090e0bc2ae/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_decoders/</code></p>"},{"location":"nebula_decoders/dir_ad7c7fa181818f82243609476539152a/","title":"Dir nebula_decoders/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_decoders/dir_ad7c7fa181818f82243609476539152a/#directories","title":"Directories","text":"Type Name dir nebula_decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/</code></p>"},{"location":"nebula_decoders/dir_2debd97622a84cc0aad22cb768ccd4f1/","title":"Dir nebula_decoders/include/nebula_decoders","text":"<p>FileList &gt; include &gt; nebula_decoders</p>"},{"location":"nebula_decoders/dir_2debd97622a84cc0aad22cb768ccd4f1/#directories","title":"Directories","text":"Type Name dir nebula_decoders_common dir nebula_decoders_hesai dir nebula_decoders_robosense dir nebula_decoders_velodyne <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/</code></p>"},{"location":"nebula_decoders/dir_e9f39979da8d18d6cbf99a488b9210ec/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_common","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_common</p>"},{"location":"nebula_decoders/dir_e9f39979da8d18d6cbf99a488b9210ec/#files","title":"Files","text":"Type Name file nebula_driver_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/</code></p>"},{"location":"nebula_decoders/nebula__driver__base_8hpp/","title":"File nebula_driver_base.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_common &gt; nebula_driver_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__driver__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__driver__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaDriverBase Base class for each sensor driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/nebula__driver__base_8hpp_source/","title":"File nebula_driver_base.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_common &gt; nebula_driver_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_DRIVER_BASE_H\n#define NEBULA_DRIVER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass NebulaDriverBase\n{\npublic:\n  NebulaDriverBase(NebulaDriverBase &amp;&amp; c) = delete;\n  NebulaDriverBase &amp; operator=(NebulaDriverBase &amp;&amp; c) = delete;\n  NebulaDriverBase(const NebulaDriverBase &amp; c) = delete;\n  NebulaDriverBase &amp; operator=(const NebulaDriverBase &amp; c) = delete;\n\n  NebulaDriverBase() = default;\n\n  virtual Status SetCalibrationConfiguration(\n    const CalibrationConfigurationBase &amp; calibration_configuration) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n#endif  // NEBULA_DRIVER_BASE_H\n</code></pre>"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_hesai","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai</p>"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/#files","title":"Files","text":"Type Name file hesai_driver.hpp"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/#directories","title":"Directories","text":"Type Name dir decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/</code></p>"},{"location":"nebula_decoders/hesai__driver_8hpp/","title":"File hesai_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai &gt; hesai_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_decoder.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__driver_8hpp/#classes","title":"Classes","text":"Type Name class HesaiDriver Hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp</code></p>"},{"location":"nebula_decoders/hesai__driver_8hpp_source/","title":"File hesai_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai &gt; hesai_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_DRIVER_H\n#define NEBULA_HESAI_DRIVER_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_decoder.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass HesaiDriver : NebulaDriverBase\n{\nprivate:\n  Status driver_status_;\n  std::shared_ptr&lt;HesaiScanDecoder&gt; scan_decoder_;\n\npublic:\n  HesaiDriver() = delete;\n  explicit HesaiDriver(\n    const std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration,\n    const std::shared_ptr&lt;drivers::HesaiCorrection&gt; &amp; correction_configuration = nullptr);\n\n  Status GetStatus();\n\n  Status SetCalibrationConfiguration(\n    const CalibrationConfigurationBase &amp; calibration_configuration) override;\n\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; ConvertScanToPointcloud(\n    const std::shared_ptr&lt;pandar_msgs::msg::PandarScan&gt; &amp; pandar_scan);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_DRIVER_H\n</code></pre>"},{"location":"nebula_decoders/dir_2bf573d84977ebd5e34295c1efb6f907/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders","text":"<p>FileList &gt; decoders</p>"},{"location":"nebula_decoders/dir_2bf573d84977ebd5e34295c1efb6f907/#files","title":"Files","text":"Type Name file angle_corrector.hpp file angle_corrector_calibration_based.hpp file angle_corrector_correction_based.hpp file hesai_decoder.hpp file hesai_packet.hpp file hesai_scan_decoder.hpp file hesai_sensor.hpp file pandar_128e3x.hpp file pandar_128e4x.hpp file pandar_40.hpp file pandar_64.hpp file pandar_at128.hpp file pandar_qt128.hpp file pandar_qt64.hpp file pandar_xt32.hpp file pandar_xt32m.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/</code></p>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector_8hpp/","title":"File angle_corrector.hpp","text":"<p>FileList &gt; decoders &gt; angle_corrector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector_8hpp/#classes","title":"Classes","text":"Type Name class AngleCorrector Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. struct CorrectedAngleData <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp</code></p>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector_8hpp_source/","title":"File angle_corrector.hpp","text":"<p>File List &gt; decoders &gt; angle_corrector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;cstdint&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nstruct CorrectedAngleData\n{\n  float azimuth_rad;\n  float elevation_rad;\n  float sin_azimuth;\n  float cos_azimuth;\n  float sin_elevation;\n  float cos_elevation;\n};\n\nclass AngleCorrector\n{\nprotected:\n  const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; sensor_calibration_;\n  const std::shared_ptr&lt;HesaiCorrection&gt; sensor_correction_;\n\npublic:\n  AngleCorrector(\n    const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt;HesaiCorrection&gt; &amp; sensor_correction)\n  : sensor_calibration_(sensor_calibration), sensor_correction_(sensor_correction)\n  {\n  }\n\n  virtual CorrectedAngleData getCorrectedAngleData(uint32_t block_azimuth, uint32_t channel_id) = 0;\n\n  virtual bool hasScanned(uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector__calibration__based_8hpp/","title":"File angle_corrector_calibration_based.hpp","text":"<p>FileList &gt; decoders &gt; angle_corrector_calibration_based.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector__calibration__based_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector__calibration__based_8hpp/#classes","title":"Classes","text":"Type Name class AngleCorrectorCalibrationBased &lt;ChannelN, AngleUnit&gt; <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_calibration_based.hpp</code></p>"},{"location":"nebula_decoders/nebula__decoders__hesai_2decoders_2angle__corrector__calibration__based_8hpp_source/","title":"File angle_corrector_calibration_based.hpp","text":"<p>File List &gt; decoders &gt; angle_corrector_calibration_based.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;size_t ChannelN, size_t AngleUnit&gt;\nclass AngleCorrectorCalibrationBased : public AngleCorrector\n{\nprivate:\n  static constexpr size_t MAX_AZIMUTH_LEN = 360 * AngleUnit;\n\n  std::array&lt;float, ChannelN&gt; elevation_angle_rad_{};\n  std::array&lt;float, ChannelN&gt; azimuth_offset_rad_{};\n  std::array&lt;float, MAX_AZIMUTH_LEN&gt; block_azimuth_rad_{};\n\n  std::array&lt;float, ChannelN&gt; elevation_cos_{};\n  std::array&lt;float, ChannelN&gt; elevation_sin_{};\n  std::array&lt;std::array&lt;float, ChannelN&gt;, MAX_AZIMUTH_LEN&gt; azimuth_cos_{};\n  std::array&lt;std::array&lt;float, ChannelN&gt;, MAX_AZIMUTH_LEN&gt; azimuth_sin_{};\n\npublic:\n  AngleCorrectorCalibrationBased(\n    const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt;HesaiCorrection&gt; &amp; sensor_correction)\n  : AngleCorrector(sensor_calibration, sensor_correction)\n  {\n    if (sensor_calibration == nullptr) {\n      throw std::runtime_error(\n        \"Cannot instantiate AngleCorrectorCalibrationBased without calibration data\");\n    }\n\n    for (size_t channel_id = 0; channel_id &lt; ChannelN; ++channel_id) {\n      float elevation_angle_deg = sensor_calibration-&gt;elev_angle_map[channel_id];\n      float azimuth_offset_deg = sensor_calibration-&gt;azimuth_offset_map[channel_id];\n\n      elevation_angle_rad_[channel_id] = deg2rad(elevation_angle_deg);\n      azimuth_offset_rad_[channel_id] = deg2rad(azimuth_offset_deg);\n\n      elevation_cos_[channel_id] = cosf(elevation_angle_rad_[channel_id]);\n      elevation_sin_[channel_id] = sinf(elevation_angle_rad_[channel_id]);\n    }\n\n    for (size_t block_azimuth = 0; block_azimuth &lt; MAX_AZIMUTH_LEN; block_azimuth++) {\n      block_azimuth_rad_[block_azimuth] = deg2rad(block_azimuth / static_cast&lt;double&gt;(AngleUnit));\n\n      for (size_t channel_id = 0; channel_id &lt; ChannelN; ++channel_id) {\n        float precision_azimuth =\n          block_azimuth_rad_[block_azimuth] + azimuth_offset_rad_[channel_id];\n\n        azimuth_cos_[block_azimuth][channel_id] = cosf(precision_azimuth);\n        azimuth_sin_[block_azimuth][channel_id] = sinf(precision_azimuth);\n      }\n    }\n  }\n\n  CorrectedAngleData getCorrectedAngleData(uint32_t block_azimuth, uint32_t channel_id) override\n  {\n    float azimuth_rad = block_azimuth_rad_[block_azimuth] + azimuth_offset_rad_[channel_id];\n    float elevation_rad = elevation_angle_rad_[channel_id];\n\n    return {\n      azimuth_rad,\n      elevation_rad,\n      azimuth_sin_[block_azimuth][channel_id],\n      azimuth_cos_[block_azimuth][channel_id],\n      elevation_sin_[channel_id],\n      elevation_cos_[channel_id]};\n  }\n\n  bool hasScanned(uint32_t current_azimuth, uint32_t last_azimuth, uint32_t sync_azimuth) override\n  {\n    // Cut the scan when the azimuth passes over the sync_azimuth\n    uint32_t current_diff_from_sync =\n      (MAX_AZIMUTH_LEN + current_azimuth - sync_azimuth) % MAX_AZIMUTH_LEN;\n    uint32_t last_diff_from_sync =\n      (MAX_AZIMUTH_LEN + last_azimuth - sync_azimuth) % MAX_AZIMUTH_LEN;\n\n    return current_diff_from_sync &lt; last_diff_from_sync;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/","title":"File angle_corrector_correction_based.hpp","text":"<p>FileList &gt; decoders &gt; angle_corrector_correction_based.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/#classes","title":"Classes","text":"Type Name class AngleCorrectorCorrectionBased &lt;ChannelN, AngleUnit&gt;"},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/#macros","title":"Macros","text":"Type Name define _ (x) '\"' &lt;&lt; #x &lt;&lt; \"\\\": \" &lt;&lt; x &lt;&lt; \", \""},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp/#define-_","title":"define _","text":"<pre><code>#define _ (\n    x\n) '\"' &lt;&lt; #x &lt;&lt; \"\\\": \" &lt;&lt; x &lt;&lt; \", \"\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_correction_based.hpp</code></p>"},{"location":"nebula_decoders/angle__corrector__correction__based_8hpp_source/","title":"File angle_corrector_correction_based.hpp","text":"<p>File List &gt; decoders &gt; angle_corrector_correction_based.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector.hpp\"\n\n#include &lt;cstdint&gt;\n\n#define _(x) '\"' &lt;&lt; #x &lt;&lt; \"\\\": \" &lt;&lt; x &lt;&lt; \", \"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;size_t ChannelN, size_t AngleUnit&gt;\nclass AngleCorrectorCorrectionBased : public AngleCorrector\n{\nprivate:\n  static constexpr size_t MAX_AZIMUTH_LENGTH = 360 * AngleUnit;\n  rclcpp::Logger logger_;\n\n  std::array&lt;float, MAX_AZIMUTH_LENGTH&gt; cos_{};\n  std::array&lt;float, MAX_AZIMUTH_LENGTH&gt; sin_{};\n\n  int findField(uint32_t azimuth)\n  {\n    // Assumes that:\n    // * none of the startFrames are defined as &gt; 360 deg (&lt; 0 not possible since they are unsigned)\n    // * the fields are arranged in ascending order (e.g. field 1: 20-140deg, field 2: 140-260deg etc.)\n    // These assumptions hold for AT128E2X.\n    int field = sensor_correction_-&gt;frameNumber - 1;\n    for (size_t i = 0; i &lt; sensor_correction_-&gt;frameNumber; ++i) {\n      if (azimuth &lt; sensor_correction_-&gt;startFrame[i]) return field;\n      field = i;\n    }\n\n    // This is never reached if sensor_correction_ is correct\n    return field;\n  }\n\npublic:\n  AngleCorrectorCorrectionBased(\n    const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; &amp; sensor_calibration,\n    const std::shared_ptr&lt;HesaiCorrection&gt; &amp; sensor_correction)\n  : AngleCorrector(sensor_calibration, sensor_correction),\n    logger_(rclcpp::get_logger(\"AngleCorrectorCorrectionBased\"))\n  {\n    if (sensor_correction == nullptr) {\n      throw std::runtime_error(\n        \"Cannot instantiate AngleCorrectorCalibrationBased without calibration data\");\n    }\n\n    logger_.set_level(rclcpp::Logger::Level::Debug);\n\n    for (size_t i = 0; i &lt; MAX_AZIMUTH_LENGTH; ++i) {\n      float rad = 2.f * i * M_PI / MAX_AZIMUTH_LENGTH;\n      cos_[i] = cosf(rad);\n      sin_[i] = sinf(rad);\n    }\n  }\n\n  CorrectedAngleData getCorrectedAngleData(uint32_t block_azimuth, uint32_t channel_id) override\n  {\n    const auto &amp; correction = AngleCorrector::sensor_correction_;\n    int field = findField(block_azimuth);\n\n    auto elevation =\n      correction-&gt;elevation[channel_id] +\n      correction-&gt;getElevationAdjustV3(channel_id, block_azimuth) * (AngleUnit / 100);\n    elevation = (MAX_AZIMUTH_LENGTH + elevation) % MAX_AZIMUTH_LENGTH;\n\n    auto azimuth = (block_azimuth + MAX_AZIMUTH_LENGTH - correction-&gt;startFrame[field]) * 2 -\n                   correction-&gt;azimuth[channel_id] +\n                   correction-&gt;getAzimuthAdjustV3(channel_id, block_azimuth) * (AngleUnit / 100);\n    azimuth = (MAX_AZIMUTH_LENGTH + azimuth) % MAX_AZIMUTH_LENGTH;\n\n    float azimuth_rad = 2.f * azimuth * M_PI / MAX_AZIMUTH_LENGTH;\n    float elevation_rad = 2.f * elevation * M_PI / MAX_AZIMUTH_LENGTH;\n\n    return {azimuth_rad,   elevation_rad,   sin_[azimuth],\n            cos_[azimuth], sin_[elevation], cos_[elevation]};\n  }\n\n  bool hasScanned(uint32_t current_azimuth, uint32_t last_azimuth, uint32_t /*sync_azimuth*/) override\n  {\n    // For AT128, the scan is always cut at the beginning of the field:\n    // If we would cut at `sync_azimuth`, the points left of it would be\n    // from the previous field and therefore significantly older than the\n    // points right of it.\n    // This also means that the pointcloud timestamp is only at top of second\n    // if the `sync_azimuth` aligns with the beginning of the field (e.g. 30deg for AT128).\n    // The absolute point time for points at `sync_azimuth` is still at top of second.\n    return findField(current_azimuth) != findField(last_azimuth);\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/hesai__decoder_8hpp/","title":"File hesai_decoder.hpp","text":"<p>FileList &gt; decoders &gt; hesai_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/hesai__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__decoder_8hpp/#classes","title":"Classes","text":"Type Name class HesaiDecoder &lt;typename SensorT&gt; <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_decoder.hpp</code></p>"},{"location":"nebula_decoders/hesai__decoder_8hpp_source/","title":"File hesai_decoder.hpp","text":"<p>File List &gt; decoders &gt; hesai_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;typename SensorT&gt;\nclass HesaiDecoder : public HesaiScanDecoder\n{\nprotected:\n  const std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; sensor_configuration_;\n\n  SensorT sensor_{};\n\n  typename SensorT::angle_corrector_t angle_corrector_;\n\n  NebulaPointCloudPtr decode_pc_;\n  NebulaPointCloudPtr output_pc_;\n\n  typename SensorT::packet_t packet_;\n  int last_phase_;\n  uint64_t output_scan_timestamp_ns_;\n  uint64_t decode_scan_timestamp_ns_;\n  bool has_scanned_;\n\n  rclcpp::Logger logger_;\n\n  std::array&lt;int, SensorT::packet_t::N_CHANNELS&gt; channel_firing_offset_ns_;\n  std::array&lt;std::array&lt;int, SensorT::packet_t::N_BLOCKS&gt;, SensorT::packet_t::MAX_RETURNS&gt;\n    block_firing_offset_ns_;\n\n  bool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet)\n  {\n    if (pandar_packet.size &lt; sizeof(typename SensorT::packet_t)) {\n      RCLCPP_ERROR_STREAM(\n        logger_, \"Packet size mismatch:\" &lt;&lt; pandar_packet.size &lt;&lt; \" | Expected at least:\"\n                                         &lt;&lt; sizeof(typename SensorT::packet_t));\n      return false;\n    }\n    if (std::memcpy(&amp;packet_, pandar_packet.data.data(), sizeof(typename SensorT::packet_t))) {\n      // FIXME(mojomex) do validation?\n      // RCLCPP_DEBUG(logger_, \"Packet parsed successfully\");\n      return true;\n    }\n\n    RCLCPP_ERROR(logger_, \"Packet memcopy failed\");\n    return false;\n  }\n\n  void convertReturns(size_t start_block_id, size_t n_blocks)\n  {\n    uint64_t packet_timestamp_ns = hesai_packet::get_timestamp_ns(packet_);\n    uint32_t raw_azimuth = packet_.body.blocks[start_block_id].get_azimuth();\n\n    std::vector&lt;const typename SensorT::packet_t::body_t::block_t::unit_t *&gt; return_units;\n\n    for (size_t channel_id = 0; channel_id &lt; SensorT::packet_t::N_CHANNELS; ++channel_id) {\n      // Find the units corresponding to the same return group as the current one.\n      // These are used to find duplicates in multi-return mode.\n      return_units.clear();\n      for (size_t block_offset = 0; block_offset &lt; n_blocks; ++block_offset) {\n        return_units.push_back(\n          &amp;packet_.body.blocks[block_offset + start_block_id].units[channel_id]);\n      }\n\n      for (size_t block_offset = 0; block_offset &lt; n_blocks; ++block_offset) {\n        auto &amp; unit = *return_units[block_offset];\n\n        if (unit.distance == 0) {\n          continue;\n        }\n\n        auto distance = getDistance(unit);\n\n        if (\n          distance &lt; SensorT::MIN_RANGE || SensorT::MAX_RANGE &lt; distance ||\n          distance &lt; sensor_configuration_-&gt;min_range ||\n          sensor_configuration_-&gt;max_range &lt; distance) {\n          continue;\n        }\n\n        auto return_type = sensor_.getReturnType(\n          static_cast&lt;hesai_packet::return_mode::ReturnMode&gt;(packet_.tail.return_mode),\n          block_offset, return_units);\n\n        // Keep only last of multiple identical points\n        if (return_type == ReturnType::IDENTICAL &amp;&amp; block_offset != n_blocks - 1) {\n          continue;\n        }\n\n        // Keep only last (if any) of multiple points that are too close\n        if (block_offset != n_blocks - 1) {\n          bool is_below_multi_return_threshold = false;\n\n          for (size_t return_idx = 0; return_idx &lt; n_blocks; ++return_idx) {\n            if (return_idx == block_offset) {\n              continue;\n            }\n\n            if (\n              fabsf(getDistance(*return_units[return_idx]) - distance) &lt;\n              sensor_configuration_-&gt;dual_return_distance_threshold) {\n              is_below_multi_return_threshold = true;\n              break;\n            }\n          }\n\n          if (is_below_multi_return_threshold) {\n            continue;\n          }\n        }\n\n        NebulaPoint point;\n        point.distance = distance;\n        point.intensity = unit.reflectivity;\n        point.time_stamp =\n          getPointTimeRelative(packet_timestamp_ns, block_offset + start_block_id, channel_id);\n\n        point.return_type = static_cast&lt;uint8_t&gt;(return_type);\n        point.channel = channel_id;\n\n        auto corrected_angle_data = angle_corrector_.getCorrectedAngleData(raw_azimuth, channel_id);\n\n        // The raw_azimuth and channel are only used as indices, sin/cos functions use the precise\n        // corrected angles\n        float xyDistance = distance * corrected_angle_data.cos_elevation;\n        point.x = xyDistance * corrected_angle_data.sin_azimuth;\n        point.y = xyDistance * corrected_angle_data.cos_azimuth;\n        point.z = distance * corrected_angle_data.sin_elevation;\n\n        // The driver wrapper converts to degrees, expects radians\n        point.azimuth = corrected_angle_data.azimuth_rad;\n        point.elevation = corrected_angle_data.elevation_rad;\n\n        decode_pc_-&gt;emplace_back(point);\n      }\n    }\n  }\n\n  bool checkScanCompleted(uint32_t current_phase, uint32_t sync_phase)\n  {\n    return angle_corrector_.hasScanned(current_phase, last_phase_, sync_phase);\n  }\n\n  float getDistance(const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit)\n  {\n    return unit.distance * hesai_packet::get_dis_unit(packet_);\n  }\n\n  uint32_t getPointTimeRelative(uint64_t packet_timestamp_ns, size_t block_id, size_t channel_id)\n  {\n    auto point_to_packet_offset_ns =\n      sensor_.getPacketRelativePointTimeOffset(block_id, channel_id, packet_);\n    auto packet_to_scan_offset_ns =\n      static_cast&lt;uint32_t&gt;(packet_timestamp_ns - decode_scan_timestamp_ns_);\n    return packet_to_scan_offset_ns + point_to_packet_offset_ns;\n  }\n\npublic:\n  explicit HesaiDecoder(\n    const std::shared_ptr&lt;HesaiSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; &amp; calibration_configuration,\n    const std::shared_ptr&lt;HesaiCorrection&gt; &amp; correction_configuration)\n  : sensor_configuration_(sensor_configuration),\n    angle_corrector_(calibration_configuration, correction_configuration),\n    logger_(rclcpp::get_logger(\"HesaiDecoder\"))\n  {\n    logger_.set_level(rclcpp::Logger::Level::Debug);\n    RCLCPP_INFO_STREAM(logger_, sensor_configuration_);\n\n    decode_pc_.reset(new NebulaPointCloud);\n    output_pc_.reset(new NebulaPointCloud);\n\n    decode_pc_-&gt;reserve(SensorT::MAX_SCAN_BUFFER_POINTS);\n    output_pc_-&gt;reserve(SensorT::MAX_SCAN_BUFFER_POINTS);\n  }\n\n  int unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override\n  {\n    if (!parsePacket(pandar_packet)) {\n      return -1;\n    }\n\n    if (decode_scan_timestamp_ns_ == 0) {\n      decode_scan_timestamp_ns_ = hesai_packet::get_timestamp_ns(packet_);\n    }\n\n    if (has_scanned_) {\n      has_scanned_ = false;\n    }\n\n    const size_t n_returns = hesai_packet::get_n_returns(packet_.tail.return_mode);\n    uint32_t current_azimuth;\n\n    for (size_t block_id = 0; block_id &lt; SensorT::packet_t::N_BLOCKS; block_id += n_returns) {\n      current_azimuth = packet_.body.blocks[block_id].get_azimuth();\n\n      bool scan_completed = checkScanCompleted(\n        current_azimuth,\n        sensor_configuration_-&gt;scan_phase * SensorT::packet_t::DEGREE_SUBDIVISIONS);\n\n      if (scan_completed) {\n        std::swap(decode_pc_, output_pc_);\n        decode_pc_-&gt;clear();\n        has_scanned_ = true;\n        output_scan_timestamp_ns_ = decode_scan_timestamp_ns_;\n\n        // A new scan starts within the current packet, so the new scan's timestamp must be\n        // calculated as the packet timestamp plus the lowest time offset of any point in the\n        // remainder of the packet\n        decode_scan_timestamp_ns_ = hesai_packet::get_timestamp_ns(packet_) +\n                                    sensor_.getEarliestPointTimeOffsetForBlock(block_id, packet_);\n      }\n\n      convertReturns(block_id, n_returns);\n      last_phase_ = current_azimuth;\n    }\n\n    return last_phase_;\n  }\n\n  bool hasScanned() override { return has_scanned_; }\n\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; getPointcloud() override\n  {\n    double scan_timestamp_s = static_cast&lt;double&gt;(output_scan_timestamp_ns_) * 1e-9;\n    return std::make_pair(output_pc_, scan_timestamp_s);\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/hesai__packet_8hpp/","title":"File hesai_packet.hpp","text":"<p>FileList &gt; decoders &gt; hesai_packet.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__packet_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet namespace return_mode"},{"location":"nebula_decoders/hesai__packet_8hpp/#classes","title":"Classes","text":"Type Name struct Block &lt;typename UnitT, UnitN&gt; struct Body &lt;typename BlockT, BlockN&gt; struct DateTime &lt;YearOffset&gt;DateTime struct for Hesai packets. struct FineAzimuthBlock &lt;typename UnitT, UnitN&gt; struct FunctionalSafety struct Header12B struct Header8B struct PacketBase &lt;nBlocks, nChannels, maxReturns, degreeSubdivisions&gt;Base struct for all Hesai packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. struct SOBBlock &lt;typename UnitT, UnitN&gt; struct SecondsSinceEpoch struct Unit3B struct Unit4B <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp</code></p>"},{"location":"nebula_decoders/hesai__packet_8hpp_source/","title":"File hesai_packet.hpp","text":"<p>File List &gt; decoders &gt; hesai_packet.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace hesai_packet\n{\n\n// FIXME(mojomex) This is a workaround for the compiler being pedantic about casting `enum class`s\n// to their underlying type\nnamespace return_mode\n{\nenum ReturnMode {\n  SINGLE_FIRST = 0x33,\n  SINGLE_SECOND = 0x34,\n  SINGLE_STRONGEST = 0x37,\n  SINGLE_LAST = 0x38,\n  DUAL_LAST_STRONGEST = 0x39,\n  DUAL_FIRST_SECOND = 0x3a,\n  DUAL_FIRST_LAST = 0x3b,\n  DUAL_FIRST_STRONGEST = 0x3c,\n  TRIPLE_FIRST_LAST_STRONGEST = 0x3d,\n  DUAL_STRONGEST_SECONDSTRONGEST = 0x3,\n};\n}  // namespace return_mode\n\n#pragma pack(push, 1)\n\ntemplate &lt;int YearOffset&gt;\nstruct DateTime\n{\n  uint8_t year;\n  uint8_t month;\n  uint8_t day;\n  uint8_t hour;\n  uint8_t minute;\n  uint8_t second;\n\n  uint64_t get_seconds() const\n  {\n    std::tm tm{};\n    tm.tm_year = year - 1900 + YearOffset;\n    tm.tm_mon = month - 1;  // starts from 0 in C\n    tm.tm_mday = day;\n    tm.tm_hour = hour;\n    tm.tm_min = minute;\n    tm.tm_sec = second;\n    return timegm(&amp;tm);\n  }\n};\n\nstruct SecondsSinceEpoch\n{\n  uint8_t zero;\n  uint8_t seconds[5];\n\n  uint64_t get_seconds() const\n  {\n    uint64_t seconds = 0;\n    for (int i = 0; i &lt; 5; ++i) {\n      seconds = (seconds &lt;&lt; 8) | this-&gt;seconds[i];\n    }\n    return seconds;\n  }\n};\n\nstruct FunctionalSafety\n{\n  uint8_t fs_version;\n  uint8_t lidar_state;\n  uint8_t fault_code_id;\n  uint16_t fault_code;\n  uint8_t reserved1[8];\n  uint32_t crc_fs;\n};\n\nstruct Header12B\n{\n  uint16_t sop;\n  uint8_t protocol_major;\n  uint8_t protocol_minor;\n  uint8_t reserved1[2];\n\n  uint8_t laser_num;\n  uint8_t block_num;\n  uint8_t reserved2;\n  uint8_t dis_unit;\n  uint8_t return_num;\n  uint8_t flags;\n};\n\nstruct Header8B\n{\n  uint16_t sop;\n\n  uint8_t laser_num;\n  uint8_t block_num;\n  uint8_t reserved1;\n  uint8_t dis_unit;\n  uint8_t reserved2[2];\n};\n\nstruct Unit3B\n{\n  uint16_t distance;\n  uint8_t reflectivity;\n};\n\nstruct Unit4B\n{\n  uint16_t distance;\n  uint8_t reflectivity;\n  uint8_t confidence_or_reserved;\n};\n\ntemplate &lt;typename UnitT, size_t UnitN&gt;\nstruct Block\n{\n  uint16_t azimuth;\n  UnitT units[UnitN];\n  typedef UnitT unit_t;\n\n  uint32_t get_azimuth() const { return azimuth; }\n};\n\ntemplate &lt;typename UnitT, size_t UnitN&gt;\nstruct FineAzimuthBlock\n{\n  typedef UnitT unit_t;\n  uint16_t azimuth;\n  uint8_t fine_azimuth;\n  UnitT units[UnitN];\n\n  uint32_t get_azimuth() const { return (azimuth &lt;&lt; 8) + fine_azimuth; }\n};\n\ntemplate &lt;typename UnitT, size_t UnitN&gt;\nstruct SOBBlock\n{\n  typedef UnitT unit_t;\n\n  uint16_t sob;\n  uint16_t azimuth;\n  UnitT units[UnitN];\n\n  uint32_t get_azimuth() const { return azimuth; }\n};\n\ntemplate &lt;typename BlockT, size_t BlockN&gt;\nstruct Body\n{\n  typedef BlockT block_t;\n  BlockT blocks[BlockN];\n};\n\ntemplate &lt;size_t nBlocks, size_t nChannels, size_t maxReturns, size_t degreeSubdivisions&gt;\nstruct PacketBase\n{\n  static constexpr size_t N_BLOCKS = nBlocks;\n  static constexpr size_t N_CHANNELS = nChannels;\n  static constexpr size_t MAX_RETURNS = maxReturns;\n  static constexpr size_t DEGREE_SUBDIVISIONS = degreeSubdivisions;\n};\n\n#pragma pack(pop)\n\nint get_n_returns(uint8_t return_mode)\n{\n  switch (return_mode) {\n    case return_mode::SINGLE_FIRST:\n    case return_mode::SINGLE_SECOND:\n    case return_mode::SINGLE_STRONGEST:\n    case return_mode::SINGLE_LAST:\n      return 1;\n    case return_mode::DUAL_LAST_STRONGEST:\n    case return_mode::DUAL_FIRST_SECOND:\n    case return_mode::DUAL_FIRST_LAST:\n    case return_mode::DUAL_FIRST_STRONGEST:\n    case return_mode::DUAL_STRONGEST_SECONDSTRONGEST:\n      return 2;\n    case return_mode::TRIPLE_FIRST_LAST_STRONGEST:\n      return 3;\n    default:\n      throw std::runtime_error(\"Unknown return mode\");\n  }\n}\n\ntemplate &lt;typename PacketT&gt;\nuint64_t get_timestamp_ns(const PacketT &amp; packet)\n{\n  return packet.tail.date_time.get_seconds() * 1000000000 + packet.tail.timestamp * 1000;\n}\n\ntemplate &lt;typename PacketT&gt;\ndouble get_dis_unit(const PacketT &amp; packet)\n{\n  // Packets define distance unit in millimeters, convert to meters here\n  return packet.header.dis_unit / 1000.;\n}\n\n}  // namespace hesai_packet\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/","title":"File hesai_scan_decoder.hpp","text":"<p>FileList &gt; decoders &gt; hesai_scan_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;tuple&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/#classes","title":"Classes","text":"Type Name class HesaiScanDecoder Base class for Hesai LiDAR decoder. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp_source/","title":"File hesai_scan_decoder.hpp","text":"<p>File List &gt; decoders &gt; hesai_scan_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_WS_HESAI_SCAN_DECODER_HPP\n#define NEBULA_WS_HESAI_SCAN_DECODER_HPP\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/point_types.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;tuple&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass HesaiScanDecoder\n{\npublic:\n  HesaiScanDecoder(HesaiScanDecoder &amp;&amp; c) = delete;\n  HesaiScanDecoder &amp; operator=(HesaiScanDecoder &amp;&amp; c) = delete;\n  HesaiScanDecoder(const HesaiScanDecoder &amp; c) = delete;\n  HesaiScanDecoder &amp; operator=(const HesaiScanDecoder &amp; c) = delete;\n\n  virtual ~HesaiScanDecoder() = default;\n  HesaiScanDecoder() = default;\n\n  virtual int unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0;\n\n  virtual bool hasScanned() = 0;\n\n  virtual std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; getPointcloud() = 0;\n};\n}  // namespace drivers\n}  // namespace nebula\n#endif  // NEBULA_WS_HESAI_SCAN_DECODER_HPP\n</code></pre>"},{"location":"nebula_decoders/hesai__sensor_8hpp/","title":"File hesai_sensor.hpp","text":"<p>FileList &gt; decoders &gt; hesai_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_calibration_based.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_correction_based.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__sensor_8hpp/#classes","title":"Classes","text":"Type Name class HesaiSensor &lt;typename PacketT, AngleCorrection&gt;Base class for all sensor definitions. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp</code></p>"},{"location":"nebula_decoders/hesai__sensor_8hpp_source/","title":"File hesai_sensor.hpp","text":"<p>File List &gt; decoders &gt; hesai_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_calibration_based.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/angle_corrector_correction_based.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n\n#include &lt;type_traits&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nenum class AngleCorrectionType { CALIBRATION, CORRECTION };\n\ntemplate &lt;typename PacketT, AngleCorrectionType AngleCorrection = AngleCorrectionType::CALIBRATION&gt;\nclass HesaiSensor\n{\nprivate:\n  static bool is_strongest(\n    uint32_t return_idx,\n    const std::vector&lt;const typename PacketT::body_t::block_t::unit_t *&gt; &amp; return_units)\n  {\n    for (unsigned int i = 0; i &lt; return_units.size(); ++i) {\n      if (i == return_idx) {\n        continue;\n      }\n\n      if (return_units[return_idx]-&gt;reflectivity &lt; return_units[i]-&gt;reflectivity) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  static bool is_duplicate(\n    uint32_t return_idx,\n    const std::vector&lt;const typename PacketT::body_t::block_t::unit_t *&gt; &amp; return_units)\n  {\n    for (unsigned int i = 0; i &lt; return_units.size(); ++i) {\n      if (i == return_idx) {\n        continue;\n      }\n\n      if (\n        return_units[return_idx]-&gt;distance == return_units[i]-&gt;distance &amp;&amp;\n        return_units[return_idx]-&gt;reflectivity == return_units[i]-&gt;reflectivity) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\npublic:\n  typedef PacketT packet_t;\n  typedef typename std::conditional&lt;\n    (AngleCorrection == AngleCorrectionType::CALIBRATION),\n    AngleCorrectorCalibrationBased&lt;PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS&gt;,\n    AngleCorrectorCorrectionBased&lt;PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS&gt;&gt;::type\n    angle_corrector_t;\n\n  HesaiSensor() = default;\n  virtual ~HesaiSensor() = default;\n\n  virtual int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const PacketT &amp; packet) = 0;\n\n  int getEarliestPointTimeOffsetForBlock(uint32_t start_block_id, const PacketT &amp; packet)\n  {\n    unsigned int n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int min_offset_ns = 0xFFFFFFFF;  // MAXINT\n\n    for (uint32_t block_id = start_block_id; block_id &lt; start_block_id + n_returns; ++block_id) {\n      for (uint32_t channel_id = 0; channel_id &lt; PacketT::N_CHANNELS; ++channel_id) {\n        min_offset_ns =\n          std::min(min_offset_ns, getPacketRelativePointTimeOffset(block_id, channel_id, packet));\n      }\n    }\n\n    return min_offset_ns;\n  }\n\n  virtual ReturnType getReturnType(\n    hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx,\n    const std::vector&lt;const typename PacketT::body_t::block_t::unit_t *&gt; &amp; return_units)\n  {\n    if (is_duplicate(return_idx, return_units)) {\n      return ReturnType::IDENTICAL;\n    }\n\n    switch (return_mode) {\n      case hesai_packet::return_mode::SINGLE_FIRST:\n        return ReturnType::FIRST;\n      case hesai_packet::return_mode::SINGLE_SECOND:\n        return ReturnType::SECOND;\n      case hesai_packet::return_mode::SINGLE_STRONGEST:\n        return ReturnType::STRONGEST;\n      case hesai_packet::return_mode::SINGLE_LAST:\n        return ReturnType::LAST;\n      case hesai_packet::return_mode::DUAL_LAST_STRONGEST:\n        if (is_strongest(return_idx, return_units)) {\n          return return_idx == 0 ? ReturnType::LAST_STRONGEST : ReturnType::STRONGEST;\n        } else {\n          return return_idx == 0 ? ReturnType::LAST : ReturnType::SECONDSTRONGEST;\n        }\n      case hesai_packet::return_mode::DUAL_FIRST_SECOND:\n        return return_idx == 0 ? ReturnType::FIRST : ReturnType::SECOND;\n      case hesai_packet::return_mode::DUAL_FIRST_LAST:\n        return return_idx == 0 ? ReturnType::FIRST : ReturnType::LAST;\n      case hesai_packet::return_mode::DUAL_FIRST_STRONGEST:\n        if (is_strongest(return_idx, return_units)) {\n          return return_idx == 0 ? ReturnType::FIRST_STRONGEST : ReturnType::STRONGEST;\n        } else {\n          return return_idx == 0 ? ReturnType::FIRST : ReturnType::SECONDSTRONGEST;\n        }\n      case hesai_packet::return_mode::DUAL_STRONGEST_SECONDSTRONGEST:\n        return return_idx == 0 ? ReturnType::STRONGEST : ReturnType::SECONDSTRONGEST;\n      case hesai_packet::return_mode::TRIPLE_FIRST_LAST_STRONGEST:\n        switch (return_idx) {\n          case 0:\n            return ReturnType::FIRST;\n          case 1:\n            return ReturnType::LAST;\n          case 2:\n            return ReturnType::STRONGEST;\n          default:\n            return ReturnType::UNKNOWN;\n        }\n      default:\n        return ReturnType::UNKNOWN;\n    }\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__128e3x_8hpp/","title":"File pandar_128e3x.hpp","text":"<p>FileList &gt; decoders &gt; pandar_128e3x.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__128e3x_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__128e3x_8hpp/#classes","title":"Classes","text":"Type Name class Pandar128E3X struct Packet128E3X struct Tail128E3X <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp</code></p>"},{"location":"nebula_decoders/pandar__128e3x_8hpp_source/","title":"File pandar_128e3x.hpp","text":"<p>File List &gt; decoders &gt; pandar_128e3x.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct Tail128E3X\n{\n  uint8_t reserved1[9];\n  uint16_t azimuth_state;\n  uint8_t operational_state;\n  uint8_t return_mode;\n  uint16_t motor_speed;\n  DateTime&lt;1900&gt; date_time;\n  uint32_t timestamp;\n  uint8_t factory_information;\n\n  /* Ignored optional fields */\n\n  // uint32_t udp_sequence;\n\n  // uint16_t imu_temperature;\n  // uint16_t imu_acceleration_unit;\n  // uint16_t imu_angular_velocity_unit;\n  // uint32_t imu_timestamp;\n  // uint16_t imu_x_axis_acceleration;\n  // uint16_t imu_y_axis_acceleration;\n  // uint16_t imu_z_axis_acceleration;\n  // uint16_t imu_x_axis_angular_velocity;\n  // uint16_t imu_y_axis_angular_velocity;\n  // uint16_t imu_z_axis_angular_velocity;\n\n  // uint32_t crc_tail;\n\n  uint8_t geAzimuthState(unsigned int block_id) const\n  {\n    return (azimuth_state &gt;&gt; (14 - block_id * 2)) &amp; 0b11;\n  }\n};\n\nstruct Packet128E3X : public PacketBase&lt;2, 128, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit3B, Packet128E3X::N_CHANNELS&gt;, Packet128E3X::N_BLOCKS&gt; body_t;\n  Header12B header;\n  body_t body;\n  uint32_t crc_body;\n  FunctionalSafety fs;\n  Tail128E3X tail;\n\n  /* Ignored optional fields */\n\n  // uint8_t cyber_security[32];\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\n// FIXME(mojomex) support high resolution mode\nclass Pandar128E3X : public HesaiSensor&lt;hesai_packet::Packet128E3X&gt;\n{\nprivate:\n  enum OperationalState { HIGH_RESOLUTION = 0, SHUTDOWN = 1, STANDARD = 2, ENERGY_SAVING = 3 };\n\n  static constexpr int hires_as0_far_offset_ns_[128] = {\n    4436,  -1,    776,   2431,  4436,  -1,    6441,  -1,    -1,    776,   2431,  6441,  -1,\n    -1,    -1,    -1,    -1,    6441,  -1,    776,   2431,  -1,    -1,    -1,    4436,  10381,\n    14951, 12666, 14951, 19521, 19521, 8096,  12666, 12666, 10381, 24091, 17236, 24091, 14951,\n    14951, 19521, 17236, 12666, 21806, 8096,  21806, 10381, 10381, 21806, 8096,  8096,  19521,\n    12666, 12666, 24091, 24091, 17236, 21806, 17236, 14951, 10381, 14951, 17236, 17236, 8096,\n    19521, 19521, 10381, 24091, 10381, 21806, 12666, 10381, 14951, 21806, 8096,  19521, 17236,\n    8096,  19521, 24091, 24091, 24091, 17236, 21806, 8096,  12666, 21806, 14951, 2431,  776,\n    4436,  6441,  -1,    -1,    776,   -1,    2431,  2431,  4436,  -1,    -1,    -1,    6441,\n    4436,  -1,    -1,    -1,    6441,  -1,    -1,    -1,    776,   4436,  -1,    2431,  -1,\n    -1,    776,   -1,    4436,  6441,  -1,    -1,    2431,  776,   6441,  -1};\n\n  static constexpr int hires_as0_near_offset_ns_[128] = {\n    5201, -1,    1541, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1,   -1, -1, -1, 7206,  -1,\n    -1,   3196,  -1,   -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1,   -1, -1, -1, -1,    -1,\n    -1,   27056, -1,   -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1,   -1, -1, -1, -1,    -1,\n    -1,   -1,    -1,   -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1,   -1, -1, -1, 23201, -1,\n    -1,   -1,    -1,   -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, 3676, -1, -1, -1, -1,    -1,\n    -1,   -1,    -1,   -1, -1, -1, -1, -1, -1, 5681, -1, -1, -1, -1,   -1, -1, -1, -1,    -1,\n    -1,   -1,    -1,   -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1};\n\n  static constexpr int hires_as1_far_offset_ns_[128] = {\n    -1,    776,   -1,    -1,    -1,    2781,  -1,    4786,  6441,  -1,    -1,    -1,    776,\n    6441,  2781,  776,   4786,  -1,    4786,  -1,    -1,    2781,  6441,  4786,  -1,    10731,\n    15301, 13016, 15301, 19871, 19871, 8446,  13016, 13016, 10731, 24441, 17586, 24441, 15301,\n    15301, 19871, 17586, 13016, 22156, 8446,  22156, 10731, 10731, 22156, 8446,  8446,  19871,\n    13016, 13016, 24441, 24441, 17586, 22156, 17586, 15301, 10731, 15301, 17586, 17586, 8446,\n    19871, 19871, 10731, 24441, 10731, 22156, 13016, 10731, 15301, 22156, 8446,  19871, 17586,\n    8446,  19871, 24441, 24441, 24441, 17586, 22156, 8446,  13016, 22156, 15301, -1,    -1,\n    -1,    -1,    6441,  2781,  -1,    776,   -1,    -1,    -1,    4786,  776,   2781,  -1,\n    -1,    2781,  776,   4786,  -1,    6441,  6441,  4786,  -1,    -1,    4786,  -1,    2781,\n    6441,  -1,    776,   -1,    -1,    6441,  2781,  -1,    -1,    -1,    776};\n\n  static constexpr int hires_as1_near_offset_ns_[128] = {\n    -1, -1, -1, -1, -1, 4026, -1,    -1, 7206,  -1, -1, -1, -1, -1, 3546, -1,   -1, -1, -1,\n    -1, -1, -1, -1, -1, -1,   12126, -1, -1,    -1, -1, -1, -1, -1, -1,   -1,   -1, -1, -1,\n    -1, -1, -1, -1, -1, -1,   -1,    -1, 27406, -1, -1, -1, -1, -1, -1,   -1,   -1, -1, -1,\n    -1, -1, -1, -1, -1, -1,   -1,    -1, -1,    -1, -1, -1, -1, -1, -1,   -1,   -1, -1, -1,\n    -1, -1, -1, -1, -1, -1,   -1,    -1, -1,    -1, -1, -1, -1, -1, -1,   -1,   -1, -1, -1,\n    -1, -1, -1, -1, -1, -1,   2021,  -1, -1,    -1, -1, -1, -1, -1, -1,   7686, -1, -1, -1,\n    -1, -1, -1, -1, -1, 1541, -1,    -1, -1,    -1, -1, -1, -1, -1};\n\n  static constexpr int hires_as2_far_offset_ns_[128] = {\n    4436,  -1,    776,   2781,  4436,  -1,    6 - 191, -1,    -1,    776,   2781,  6091,  -1,\n    -1,    -1,    -1,    -1,    6091,  -1,    776,     2781,  -1,    -1,    -1,    4436,  10381,\n    14951, 12666, 14951, 19521, 19521, 8096,  12666,   12666, 10381, 24091, 17236, 24091, 14951,\n    14951, 19521, 17236, 12666, 21806, 8096,  21806,   10381, 10381, 21806, 8096,  8096,  19521,\n    12666, 12666, 24091, 24091, 17236, 21806, 17236,   14951, 10381, 14951, 17236, 17236, 8096,\n    19521, 19521, 10381, 24091, 10381, 21806, 12666,   10381, 14951, 21806, 8096,  19521, 17236,\n    8096,  19521, 24091, 24091, 24091, 17236, 21806,   8096,  12666, 21806, 14951, 2781,  776,\n    4436,  6091,  -1,    -1,    776,   -1,    2781,    2781,  4436,  -1,    -1,    -1,    6091,\n    4436,  -1,    -1,    -1,    6091,  -1,    -1,      -1,    776,   4436,  -1,    2781,  -1,\n    -1,    776,   -1,    4436,  6091,  -1,    -1,      2781,  776,   6091,  -1};\n\n  static constexpr int hires_as2_near_offset_ns_[128] = {\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, 7336, -1, -1,    -1, -1,    -1,   -1, -1,\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,   -1, 14061, -1, -1,    -1,   -1, -1,\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1,    -1, 27056, -1,   -1, -1,\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1,    -1, -1,    -1,   -1, -1,\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1,    -1, -1,    6856, -1, -1,\n    2021, -1, -1, 3546, -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1,    -1, -1,    -1,   -1, 5201,\n    -1,   -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, 1541, -1, -1};\n\n  static constexpr int hires_as3_far_offset_ns_[128] = {\n    -1,    776,   -1,    -1,    -1,    2431,  -1,    4086,  6091,  -1,    -1,    -1,    776,\n    6091,  2431,  776,   4086,  -1,    4086,  -1,    -1,    2431,  6091,  4086,  -1,    10031,\n    14601, 12316, 14601, 19171, 19171, 7746,  12316, 12316, 10031, 23741, 16886, 23741, 14601,\n    14601, 19171, 16886, 12316, 21456, 7746,  21456, 10031, 10031, 21456, 7746,  7746,  19171,\n    12316, 12316, 23741, 23741, 16886, 21456, 16886, 14601, 10031, 14601, 16886, 16886, 7746,\n    19171, 19171, 10031, 23741, 10031, 21456, 12316, 10031, 14601, 21456, 7746,  19171, 16886,\n    7746,  19171, 23741, 23741, 23741, 16886, 21456, 7746,  12316, 21456, 14601, -1,    -1,\n    -1,    -1,    6091,  2431,  -1,    776,   -1,    -1,    -1,    4086,  776,   2431,  -1,\n    -1,    2431,  776,   4086,  -1,    6091,  6091,  4086,  -1,    -1,    4086,  -1,    2431,\n    6091,  -1,    776,   -1,    -1,    6091,  2431,  -1,    -1,    -1,    776};\n\n  static constexpr int hires_as3_near_offset_ns_[128] = {\n    -1, -1, -1,   -1,    -1,   -1,    -1, -1, -1,   -1, -1,    -1, -1,   -1,  -1, -1, -1, -1, -1,\n    -1, -1, -1,   -1,    4851, -1,    -1, -1, -1,   -1, -1,    -1, -1,   -1,  -1, -1, -1, -1, -1,\n    -1, -1, -1,   -1,    -1,   -1,    -1, -1, -1,   -1, -1,    -1, -1,   -1,  -1, -1, -1, -1, -1,\n    -1, -1, -1,   26706, -1,   -1,    -1, -1, -1,   -1, 11426, -1, -1,   -1,  -1, -1, -1, -1, -1,\n    -1, -1, -1,   -1,    -1,   25136, -1, -1, -1,   -1, -1,    -1, -1,   -1,  -1, -1, -1, -1, -1,\n    -1, -1, -1,   -1,    -1,   -1,    -1, -1, -1,   -1, -1,    -1, 5331, -1,  -1, -1, -1, -1, -1,\n    -1, -1, 3196, -1,    -1,   -1,    -1, -1, 6856, -1, -1,    -1, -1,   1541};\n\n  static constexpr int standard_as0_far_offset_ns_[128] = {\n    4436,  28554, 776,   2431,  4436,  30559, 6441,  32564, 34219, 776,   2431,  6441,  28554,\n    34219, 30559, 28554, 32564, 6441,  32564, 776,   2431,  30559, 34219, 32564, 4436,  38509,\n    43079, 12666, 43079, 19521, 19521, 36224, 12666, 12666, 38509, 52219, 17236, 52219, 43079,\n    43079, 19521, 17236, 12666, 21806, 36224, 21806, 38509, 38509, 21806, 36224, 36224, 19521,\n    12666, 12666, 52219, 52219, 17236, 21806, 17236, 43079, 38509, 43079, 17236, 17236, 36224,\n    19521, 19521, 38509, 52219, 38509, 21806, 12666, 38509, 43079, 21806, 36224, 19521, 17236,\n    36224, 19521, 52219, 52219, 52219, 17236, 21806, 36224, 12666, 21806, 43079, 2431,  776,\n    4436,  6441,  34219, 30559, 776,   28554, 2431,  2431,  4436,  32564, 28554, 30559, 6441,\n    4436,  30559, 28554, 32564, 6441,  34219, 34219, 32564, 776,   4436,  32564, 2431,  30559,\n    34219, 776,   28554, 4436,  6441,  34219, 30559, 2431,  776,   6441,  28554};\n\n  static constexpr int standard_as0_near_offset_ns_[128] = {\n    5201, -1,   1541, -1, -1,   31804, -1, -1,    34984, -1,    -1,    -1, -1, -1, 31324, -1,\n    -1,   7206, -1,   -1, 3196, -1,    -1, -1,    -1,    39904, -1,    -1, -1, -1, -1,    -1,\n    -1,   -1,   -1,   -1, -1,   -1,    -1, 27056, -1,    -1,    -1,    -1, -1, -1, 55184, -1,\n    -1,   -1,   -1,   -1, -1,   -1,    -1, -1,    -1,    -1,    -1,    -1, -1, -1, -1,    -1,\n    -1,   -1,   -1,   -1, -1,   -1,    -1, -1,    -1,    -1,    23201, -1, -1, -1, -1,    -1,\n    -1,   -1,   -1,   -1, -1,   -1,    -1, -1,    -1,    3676,  -1,    -1, -1, -1, -1,    -1,\n    -1,   -1,   -1,   -1, -1,   29799, -1, -1,    5681,  -1,    -1,    -1, -1, -1, 35464, -1,\n    -1,   -1,   -1,   -1, -1,   -1,    -1, 29319, -1,    -1,    -1,    -1, -1, -1, -1,    -1};\n\n  static constexpr int standard_as1_far_offset_ns_[128] = {\n    4436,  28554, 776,   2781,  4436,  30209, 6091,  31864, 33869, 776,   2781,  6091,  28554,\n    33869, 30209, 28554, 31864, 6091,  31864, 776,   2781,  30209, 33869, 31864, 4436,  37809,\n    42379, 12666, 42379, 19521, 19521, 35524, 12666, 12666, 37809, 51519, 17236, 51519, 42379,\n    42379, 19521, 17236, 12666, 21806, 35524, 21806, 37809, 37809, 21806, 35524, 35524, 19521,\n    12666, 12666, 51519, 51519, 17236, 21806, 17236, 42379, 37809, 42379, 17236, 17236, 35524,\n    19521, 19521, 37809, 51519, 37809, 21806, 12666, 37809, 42379, 21806, 35524, 19521, 17236,\n    35524, 19521, 51519, 51519, 51519, 17236, 21806, 35524, 12666, 21806, 42379, 2781,  776,\n    4436,  6091,  33869, 30209, 776,   28554, 2781,  2781,  4436,  31864, 28554, 30209, 6091,\n    4436,  30209, 28554, 31864, 6091,  33869, 33869, 31864, 776,   4436,  31864, 2781,  30209,\n    33869, 776,   28554, 4436,  6091,  33869, 30209, 2781,  776,   6091,  28554};\n\n  static constexpr int standard_as1_near_offset_ns_[128] = {\n    -1,    -1, -1,    -1, -1, -1,   -1,    -1,    -1,    -1, -1, 7336,  -1, -1, -1,\n    -1,    -1, -1,    -1, -1, -1,   -1,    -1,    32629, -1, -1, -1,    -1, -1, -1,\n    -1,    -1, 14061, -1, -1, -1,   -1,    -1,    -1,    -1, -1, -1,    -1, -1, -1,\n    -1,    -1, -1,    -1, -1, -1,   -1,    -1,    27056, -1, -1, -1,    -1, -1, -1,\n    54484, -1, -1,    -1, -1, -1,   -1,    39204, -1,    -1, -1, -1,    -1, -1, -1,\n    -1,    -1, -1,    -1, -1, -1,   52914, -1,    -1,    -1, -1, -1,    -1, -1, -1,\n    -1,    -1, 6856,  -1, -1, 2021, -1,    -1,    3546,  -1, -1, -1,    -1, -1, -1,\n    -1,    -1, 33109, -1, -1, -1,   -1,    -1,    5201,  -1, -1, 30974, -1, -1, -1,\n    -1,    -1, 34634, -1, -1, 1541, -1,    29319};\n\npublic:\n  static constexpr float MIN_RANGE = 0.1;\n  static constexpr float MAX_RANGE = 230.0;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 691200;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet)\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = 3148 - 27778 * 2 * (2 - block_id - 1) / n_returns;\n\n    int channel_offset_ns;\n    bool is_hires_mode = packet.tail.operational_state == OperationalState::HIGH_RESOLUTION;\n    bool is_nearfield = (hesai_packet::get_dis_unit(packet) *\n                         packet.body.blocks[block_id].units[channel_id].distance) &lt;= 2.85f;\n    auto azimuth_state = packet.tail.geAzimuthState(block_id);\n\n    if (is_hires_mode &amp;&amp; azimuth_state == 0 &amp;&amp; !is_nearfield)\n      channel_offset_ns = hires_as0_far_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 0 &amp;&amp; is_nearfield)\n      channel_offset_ns = hires_as0_near_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 1 &amp;&amp; !is_nearfield)\n      channel_offset_ns = hires_as1_far_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 1 &amp;&amp; is_nearfield)\n      channel_offset_ns = hires_as1_near_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 2 &amp;&amp; !is_nearfield)\n      channel_offset_ns = hires_as2_far_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 2 &amp;&amp; is_nearfield)\n      channel_offset_ns = hires_as2_near_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 3 &amp;&amp; !is_nearfield)\n      channel_offset_ns = hires_as3_far_offset_ns_[channel_id];\n    else if (is_hires_mode &amp;&amp; azimuth_state == 3 &amp;&amp; is_nearfield)\n      channel_offset_ns = hires_as3_near_offset_ns_[channel_id];\n    else if (!is_hires_mode &amp;&amp; azimuth_state == 0 &amp;&amp; !is_nearfield)\n      channel_offset_ns = standard_as0_far_offset_ns_[channel_id];\n    else if (!is_hires_mode &amp;&amp; azimuth_state == 0 &amp;&amp; is_nearfield)\n      channel_offset_ns = standard_as0_near_offset_ns_[channel_id];\n    else if (!is_hires_mode &amp;&amp; azimuth_state == 1 &amp;&amp; !is_nearfield)\n      channel_offset_ns = standard_as1_far_offset_ns_[channel_id];\n    else if (!is_hires_mode &amp;&amp; azimuth_state == 1 &amp;&amp; is_nearfield)\n      channel_offset_ns = standard_as1_near_offset_ns_[channel_id];\n    else\n      throw std::runtime_error(\n        \"Invalid combination of operational state and azimuth state and nearfield firing\");\n\n    return block_offset_ns + channel_offset_ns;\n  }\n\n  ReturnType getReturnType(\n    hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx,\n    const std::vector&lt;const typename packet_t::body_t::block_t::unit_t *&gt; &amp; return_units) override\n  {\n    auto return_type = HesaiSensor&lt;packet_t&gt;::getReturnType(return_mode, return_idx, return_units);\n    if (return_type == ReturnType::IDENTICAL) {\n      return return_type;\n    }\n\n    // This sensor orders returns in the opposite order, so the return_type needs to be flipped too\n    if (return_mode == hesai_packet::return_mode::DUAL_FIRST_LAST) {\n      if (return_type == ReturnType::FIRST)\n        return_type = ReturnType::LAST;\n      else if (return_type == ReturnType::LAST)\n        return_type = ReturnType::FIRST;\n    }\n\n    return return_type;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__128e4x_8hpp/","title":"File pandar_128e4x.hpp","text":"<p>FileList &gt; decoders &gt; pandar_128e4x.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__128e4x_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__128e4x_8hpp/#classes","title":"Classes","text":"Type Name class Pandar128E4X <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e4x.hpp</code></p>"},{"location":"nebula_decoders/pandar__128e4x_8hpp_source/","title":"File pandar_128e4x.hpp","text":"<p>File List &gt; decoders &gt; pandar_128e4x.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_128e3x.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\ntypedef Packet128E3X Packet128E4X;\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\n// FIXME(mojomex) support high resolution mode\nclass Pandar128E4X : public HesaiSensor&lt;hesai_packet::Packet128E4X&gt;\n{\nprivate:\n  enum OperationalState { HIGH_RESOLUTION = 0, STANDARD = 1 };\n\n  static constexpr int firing_time_offset_static_ns_[128] = {\n    49758, 43224, 36690, 30156, 21980, 15446, 8912,  2378,  49758, 43224, 36690, 30156, 2378,\n    15446, 8912,  21980, 43224, 30156, 49758, 15446, 36690, 2378,  21980, 8912,  34312, 45002,\n    38468, 40846, 40846, 34312, 51536, 47380, 31934, 47380, 31934, 51536, 38468, 27778, 27778,\n    45002, 38468, 40846, 51536, 45002, 31934, 47380, 34312, 27778, 38468, 40846, 51536, 45002,\n    31934, 34312, 27778, 38468, 40846, 51536, 45002, 31934, 47380, 34312, 27778, 45002, 45002,\n    51536, 38468, 40846, 47380, 40846, 31934, 45002, 27778, 38468, 40846, 31934, 27778, 38468,\n    34312, 34312, 34312, 47380, 51536, 31934, 51536, 47380, 27778, 49758, 21980, 43224, 15446,\n    43224, 36690, 8912,  30156, 2378,  49758, 21980, 36690, 15446, 8912,  30156, 2378,  49758,\n    43224, 36690, 30156, 21980, 15446, 8912,  2378,  43224, 49758, 30156, 36690, 21980, 15446,\n    2378,  8912,  49758, 43224, 36690, 30156, 21980, 15446, 8912,  2378,  30156};\n\n  static constexpr int firing_time_offset_as0_ns_[128] = {\n    -1,    -1,    -1,    -1,    21980, 15446, 8912,  2378,  -1,    -1,    -1,    -1,    2378,\n    15446, 8912,  21980, -1,    2378,  21980, 8912,  6534,  17224, 10690, 13068, 13068, 6534,\n    23758, 19602, 4156,  19602, 4156,  23758, 13068, 13068, 23758, 10690, 4156,  19602, 19602,\n    0,     10690, 6534,  23758, 17224, 23758, 19602, 6534,  17224, 4156,  0,     6534,  0,\n    17224, 10690, 17224, 17224, 23758, 23758, 10690, 13068, 13068, 13068, 19602, 19602, 6534,\n    13068, 4156,  4156,  17224, 17224, 17224, 0,     10690, 10690, 13068, 13068, 4156,  0,\n    10690, 6534,  6534,  6534,  19602, 23758, 4156,  23758, 19602, 0,     -1,    21980, -1,\n    15446, -1,    8912,  -1,    2378,  -1,    -1,    21980, -1,    15446, 8912,  -1,    2378,\n    -1,    -1,    -1,    -1,    21980, 15446, 8912,  2378,  -1,    -1,    -1,    -1,    21980,\n    15446, 2378,  8912,  -1,    -1,    -1,    -1,    21980, 15446, 8912,  2378};\n\n  static constexpr int firing_time_offset_as1_ns_[128] = {\n    21980, 15446, 8912,  2378,  -1,    -1,    -1,    -1,    21980, 15446, 8912,  2378,  -1,\n    -1,    -1,    -1,    8912,  -1,    -1,    -1,    6534,  17224, 10690, 13068, 13068, 6534,\n    23758, 19602, 4156,  19602, 4156,  23758, 13068, 13068, 23758, 10690, 4156,  19602, 19602,\n    0,     10690, 6534,  23758, 17224, 23758, 19602, 6534,  17224, 4156,  0,     6534,  0,\n    17224, 10690, 17224, 17224, 23758, 23758, 10690, 13068, 13068, 13068, 19602, 19602, 6534,\n    13068, 4156,  4156,  17224, 17224, 17224, 0,     10690, 10690, 13068, 13068, 4156,  0,\n    10690, 6534,  6534,  6534,  19602, 23758, 4156,  23758, 19602, 0,     21980, -1,    15446,\n    -1,    8912,  -1,    2378,  -1,    21980, 15446, -1,    8912,  -1,    -1,    2378,  -1,\n    21980, 15446, 8912,  2378,  -1,    -1,    -1,    -1,    15446, 21980, 2378,  8912,  -1,\n    -1,    -1,    -1,    21980, 15446, 8912,  2378,  -1,    -1,    -1,    -1};\n\npublic:\n  static constexpr float MIN_RANGE = 0.1;\n  static constexpr float MAX_RANGE = 230.0;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 691200;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet)\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns;\n    if (n_returns == 1) {\n      block_offset_ns = -27778 * 2 * (2 - block_id - 1);\n    } else {\n      block_offset_ns = 0;\n    }\n\n    int channel_offset_ns;\n    bool is_hires_mode = packet.tail.operational_state == OperationalState::HIGH_RESOLUTION;\n    auto azimuth_state = packet.tail.geAzimuthState(block_id);\n\n    if (!is_hires_mode) {\n      channel_offset_ns = firing_time_offset_static_ns_[channel_id];\n    } else {\n      if (azimuth_state == 0) {\n        channel_offset_ns = firing_time_offset_as0_ns_[channel_id];\n      } else /* azimuth_state == 1 */ {\n        channel_offset_ns = firing_time_offset_as1_ns_[channel_id];\n      }\n    }\n\n    return block_offset_ns + 43346 + channel_offset_ns;\n  }\n\n  ReturnType getReturnType(\n    hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx,\n    const std::vector&lt;const typename packet_t::body_t::block_t::unit_t *&gt; &amp; return_units) override\n  {\n    auto return_type = HesaiSensor&lt;packet_t&gt;::getReturnType(return_mode, return_idx, return_units);\n    if (return_type == ReturnType::IDENTICAL) {\n      return return_type;\n    }\n\n    // This sensor orders returns in the opposite order, so the return_type needs to be flipped too\n    if (return_mode == hesai_packet::return_mode::DUAL_FIRST_LAST) {\n      if (return_type == ReturnType::FIRST)\n        return_type = ReturnType::LAST;\n      else if (return_type == ReturnType::LAST)\n        return_type = ReturnType::FIRST;\n    }\n\n    return return_type;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__40_8hpp/","title":"File pandar_40.hpp","text":"<p>FileList &gt; decoders &gt; pandar_40.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__40_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__40_8hpp/#classes","title":"Classes","text":"Type Name class Pandar40 struct Packet40P struct Tail40P <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/pandar__40_8hpp_source/","title":"File pandar_40.hpp","text":"<p>File List &gt; decoders &gt; pandar_40.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct Tail40P\n{\n  uint8_t reserved1[5];\n  uint8_t high_temperature_shutdown_flag;\n  uint8_t reserved2[2];\n  uint16_t motor_speed;\n  uint32_t timestamp;\n  uint8_t return_mode;\n  uint8_t factory_information;\n  DateTime&lt;2000&gt; date_time;\n\n  /* Ignored optional fields */\n\n  // uint32_t udp_sequence;\n};\n\nstruct Packet40P : public PacketBase&lt;10, 40, 2, 100&gt;\n{\n  typedef Body&lt;SOBBlock&lt;Unit3B, Packet40P::N_CHANNELS&gt;, Packet40P::N_BLOCKS&gt; body_t;\n  body_t body;\n  Tail40P tail;\n};\n\n#pragma pack(pop)\n\ntemplate &lt;&gt;\ndouble get_dis_unit&lt;Packet40P&gt;(const Packet40P &amp; /* packet */)\n{\n  return 4 / 1000.;\n}\n\n}  // namespace hesai_packet\n\nclass Pandar40 : public HesaiSensor&lt;hesai_packet::Packet40P&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_[40] = {\n    -42220, -28470, -16040, -3620,  -45490, -31740, -47460, -54670, -20620, -33710,\n    -40910, -8190,  -20620, -27160, -50730, -8190,  -14740, -36980, -45490, -52700,\n    -23890, -31740, -38950, -11470, -18650, -25190, -48760, -6230,  -12770, -35010,\n    -21920, -9500,  -43520, -29770, -17350, -4920,  -42220, -28470, -16040, -3620};\n\npublic:\n  static constexpr float MIN_RANGE = 0.3f;\n  static constexpr float MAX_RANGE = 200.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 144000;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = -28580 - 55560 * ((10 - block_id - 1) / n_returns);\n    return block_offset_ns + firing_time_offset_ns_[channel_id];\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__64_8hpp/","title":"File pandar_64.hpp","text":"<p>FileList &gt; decoders &gt; pandar_64.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__64_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__64_8hpp/#classes","title":"Classes","text":"Type Name class Pandar64 struct Packet64 <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/pandar__64_8hpp_source/","title":"File pandar_64.hpp","text":"<p>File List &gt; decoders &gt; pandar_64.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\ntypedef Tail40P Tail64;\nstruct Packet64 : public PacketBase&lt;6, 64, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit3B, Packet64::N_CHANNELS&gt;, Packet64::N_BLOCKS&gt; body_t;\n  Header8B header;\n  body_t body;\n  Tail64 tail;\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass Pandar64 : public HesaiSensor&lt;hesai_packet::Packet64&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_[64] = {\n    -23180, -21876, -20572, -19268, -17964, -16660, -11444, -46796, -7532,  -36956, -50732,\n    -54668, -40892, -44828, -31052, -34988, -48764, -52700, -38924, -42860, -29084, -33020,\n    -46796, -25148, -36956, -50732, -27116, -40892, -44828, -31052, -34988, -48764, -25148,\n    -38924, -42860, -29084, -33020, -52700, -6228,  -54668, -15356, -27116, -10140, -23180,\n    -4924,  -21876, -14052, -17964, -8836,  -19268, -3620,  -20572, -12748, -16660, -7532,\n    -11444, -6228,  -15356, -10140, -4924,  -3620,  -14052, -8836,  -12748};\n\npublic:\n  static constexpr float MIN_RANGE = 0.3f;\n  static constexpr float MAX_RANGE = 200.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 230400;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = -42580 - 55560 * ((6 - block_id - 1) / n_returns);\n    return block_offset_ns + firing_time_offset_ns_[channel_id];\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__at128_8hpp/","title":"File pandar_at128.hpp","text":"<p>FileList &gt; decoders &gt; pandar_at128.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__at128_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__at128_8hpp/#classes","title":"Classes","text":"Type Name class PandarAT128 struct PacketAT128E2X struct TailAT128E2X <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at128.hpp</code></p>"},{"location":"nebula_decoders/pandar__at128_8hpp_source/","title":"File pandar_at128.hpp","text":"<p>File List &gt; decoders &gt; pandar_at128.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct TailAT128E2X\n{\n  uint8_t reserved1[6];\n  uint8_t high_temperature_shutdown_flag;\n  uint8_t reserved2[11];\n  uint16_t motor_speed;\n  uint32_t timestamp;\n  uint8_t return_mode;\n  uint8_t factory_information;\n  SecondsSinceEpoch date_time;\n\n  /* Ignored optional fields */\n\n  // uint32_t udp_sequence;\n  // uint32_t crc_tail;\n};\n\nstruct PacketAT128E2X : public PacketBase&lt;2, 128, 2, 100 * 256&gt;\n{\n  typedef Body&lt;FineAzimuthBlock&lt;Unit4B, PacketAT128E2X::N_CHANNELS&gt;, PacketAT128E2X::N_BLOCKS&gt;\n    body_t;\n  Header12B header;\n  body_t body;\n  uint32_t crc_body;\n  TailAT128E2X tail;\n\n  /* Ignored optional fields */\n\n  // uint8_t cyber_security[32];\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass PandarAT128\n: public HesaiSensor&lt;hesai_packet::PacketAT128E2X, AngleCorrectionType::CORRECTION&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_[128] = {\n    0,     0,     8240,  4112,  4144,  8240,  0,     0,     12424, 4144,  4112,  8264,  12376,\n    12376, 8264,  12424, 0,     0,     4112,  8240,  4144,  0,     0,     4144,  12424, 8264,\n    4112,  12376, 12376, 12424, 8264,  848,   2504,  4976,  6616,  6616,  9112,  2504,  848,\n    10768, 13280, 13280, 4976,  9112,  14928, 14928, 10768, 2504,  848,   6616,  4976,  9112,\n    6616,  848,   2504,  13280, 10768, 4976,  13280, 14928, 9112,  10768, 14928, 13280, 848,\n    9112,  13280, 2504,  4976,  848,   2504,  14928, 10768, 10768, 14928, 4976,  6616,  6616,\n    9112,  848,   13280, 13280, 9112,  4976,  2504,  2504,  848,   10768, 14928, 14928, 10768,\n    6616,  4976,  9112,  6616,  4112,  12424, 0,     4144,  0,     0,     12424, 0,     8264,\n    4112,  4144,  8240,  8240,  8264,  12376, 12376, 12424, 4112,  4144,  0,     0,     0,\n    0,     0,     12424, 8264,  8240,  4144,  8264,  8240,  12376, 12376, 8264};\n\npublic:\n  static constexpr float MIN_RANGE = 1.f;\n  static constexpr float MAX_RANGE = 180.0f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 307200;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns;\n    if (n_returns == 1) {\n      block_offset_ns = -9249 - 41666 * (2 - block_id);\n    } else {\n      block_offset_ns = -9249 - 41666;\n    }\n\n    return block_offset_ns + firing_time_offset_ns_[channel_id];\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt128_8hpp/","title":"File pandar_qt128.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt128.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt128_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__qt128_8hpp/#classes","title":"Classes","text":"Type Name class PandarQT128 struct PacketQT128C2X struct TailQT128C2X <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt128.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt128_8hpp_source/","title":"File pandar_qt128.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt128.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct TailQT128C2X\n{\n  uint8_t reserved1[5];\n  uint8_t mode_flag;\n  uint8_t reserved2[6];\n  uint8_t return_mode;\n  uint16_t motor_speed;\n  DateTime&lt;1900&gt; date_time;\n  uint32_t timestamp;\n  uint8_t factory_information;\n\n  /* Ignored optional fields */\n\n  // uint32_t udp_sequence;\n  // uint32_t crc_tail;\n};\n\nstruct PacketQT128C2X : public PacketBase&lt;2, 128, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit4B, PacketQT128C2X::N_CHANNELS&gt;, PacketQT128C2X::N_BLOCKS&gt; body_t;\n  Header12B header;\n  body_t body;\n  uint32_t crc_body;\n  FunctionalSafety fs;\n  TailQT128C2X tail;\n\n  /* Ignored optional fields */\n\n  // uint8_t cyber_security[32];\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass PandarQT128 : public HesaiSensor&lt;hesai_packet::PacketQT128C2X&gt;\n{\nprivate:\n  // Channels 0-31 (starting at 0) do not fire, delay set to 0\n  static constexpr int loop1[128] = {\n    0,     0,     0,     0,     0,     0,     0,     0,     0,      0,     0,     0,     0,\n    0,     0,     0,     0,     0,     0,     0,     0,     0,      0,     0,     0,     0,\n    0,     0,     0,     0,     0,     0,     27656, 53000, 2312,   78344, 81512, 5480,  56168,\n    30824, 33992, 59336, 8648,  84680, 87848, 11816, 62504, 37160,  40328, 65672, 14984, 91016,\n    94184, 18152, 68840, 43496, 46664, 72008, 21320, 97352, 100520, 24488, 75176, 49832, 1456,\n    77488, 26800, 52144, 55312, 29968, 80656, 4624,  7792,  83824,  33136, 58480, 61648, 36304,\n    86992, 10960, 14128, 90160, 39472, 64816, 67984, 42640, 93328,  17296, 20464, 96496, 45808,\n    71152, 74320, 48976, 99664, 23632, 25944, 51288, 600,   76632,  79800, 3768,  54456, 29112,\n    32280, 57624, 6936,  82968, 86136, 10104, 60792, 35448, 38616,  63960, 13272, 89304, 92472,\n    16440, 67128, 41784, 44952, 70296, 19608, 95640, 98808, 22776,  73464, 48120};\n\n  // Channels 32-63 (starting at 0) do not fire, delay set to 0\n  static constexpr int loop2[128] = {\n    2312,  78344, 27656, 53000, 56168,  30824, 81512, 5480,  8648,  84680, 33992, 59336, 62504,\n    37160, 87848, 11816, 14984, 91016,  40328, 65672, 68840, 43496, 94184, 18152, 21320, 97352,\n    46664, 72008, 75176, 49832, 100520, 24488, 0,     0,     0,     0,     0,     0,     0,\n    0,     0,     0,     0,     0,      0,     0,     0,     0,     0,     0,     0,     0,\n    0,     0,     0,     0,     0,      0,     0,     0,     0,     0,     0,     0,     600,\n    76632, 25944, 51288, 54456, 29112,  79800, 3768,  6936,  82968, 32280, 57624, 60792, 35448,\n    86136, 10104, 13272, 89304, 38616,  63960, 67128, 41784, 92472, 16440, 19608, 95640, 44952,\n    70296, 73464, 48120, 98808, 22776,  26800, 52144, 1456,  77488, 80656, 4624,  55312, 29968,\n    33136, 58480, 7792,  83824, 86992,  10960, 61648, 36304, 39472, 64816, 14128, 90160, 93328,\n    17296, 67984, 42640, 45808, 71152,  20464, 96496, 99664, 23632, 74320, 48976};\n\npublic:\n  static constexpr float MIN_RANGE = 0.05;\n  static constexpr float MAX_RANGE = 50.0;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 172800;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = 9000 + 111110 * (2 - block_id - 1) / n_returns;\n\n    int channel_offset_ns;\n    if (n_returns == 1) {\n      channel_offset_ns = block_id % 2 == 0 ? loop1[channel_id] : loop2[channel_id];\n    } else {\n      channel_offset_ns = packet.tail.mode_flag &amp; 0x01 ? loop1[channel_id] : loop2[channel_id];\n    }\n\n    return block_offset_ns + channel_offset_ns;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt64_8hpp/","title":"File pandar_qt64.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt64.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt64_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__qt64_8hpp/#classes","title":"Classes","text":"Type Name class PandarQT64 struct PacketQT64 struct TailQT64 <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt64.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt64_8hpp_source/","title":"File pandar_qt64.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt64.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct TailQT64\n{\n  uint8_t reserved1[10];\n  uint16_t motor_speed;\n  uint32_t timestamp;\n  uint8_t return_mode;\n  uint8_t factory_information;\n  DateTime&lt;1900&gt; date_time;\n};\n\nstruct PacketQT64 : public PacketBase&lt;4, 64, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit4B, PacketQT64::N_CHANNELS&gt;, PacketQT64::N_BLOCKS&gt; body_t;\n  Header12B header;\n  body_t body;\n  TailQT64 tail;\n  uint32_t udp_sequence;\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass PandarQT64 : public HesaiSensor&lt;hesai_packet::PacketQT64&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_[64] = {\n    12310,  14370,  16430,  18490,  20540,  22600,  24660,  26710,  29160,  31220,  33280,\n    35340,  37390,  39450,  41500,  43560,  46610,  48670,  50730,  52780,  54840,  56900,\n    58950,  61010,  63450,  65520,  67580,  69630,  71690,  73740,  75800,  77860,  80900,\n    82970,  85020,  87080,  89140,  91190,  93250,  95300,  97750,  99820,  101870, 103930,\n    105980, 108040, 110100, 112150, 115200, 117260, 119320, 121380, 123430, 125490, 127540,\n    12960,  132050, 134110, 136170, 138220, 140280, 142340, 144390, 146450};\n\npublic:\n  static constexpr float MIN_RANGE = 0.1f;\n  static constexpr float MAX_RANGE = 60.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 76800;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = 25710 + (500000 * (block_id / n_returns)) / 3;\n    return block_offset_ns + firing_time_offset_ns_[channel_id];\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xt32_8hpp/","title":"File pandar_xt32.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xt32.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__xt32_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__xt32_8hpp/#classes","title":"Classes","text":"Type Name class PandarXT32 struct PacketXT32 struct TailXT32 <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp</code></p>"},{"location":"nebula_decoders/pandar__xt32_8hpp_source/","title":"File pandar_xt32.hpp","text":"<p>File List &gt; decoders &gt; pandar_xt32.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\nstruct TailXT32\n{\n  uint8_t reserved1[10];\n  uint8_t return_mode;\n  uint16_t motor_speed;\n  DateTime&lt;1900&gt; date_time;\n  uint32_t timestamp;\n  uint8_t factory_information;\n};\n\nstruct PacketXT32 : public PacketBase&lt;8, 32, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit4B, PacketXT32::N_CHANNELS&gt;, PacketXT32::N_BLOCKS&gt; body_t;\n  Header12B header;\n  body_t body;\n  TailXT32 tail;\n  uint32_t udp_sequence;\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass PandarXT32 : public HesaiSensor&lt;hesai_packet::PacketXT32&gt;\n{\npublic:\n  static constexpr float MIN_RANGE = 0.05f;\n  static constexpr float MAX_RANGE = 120.0f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 256000;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns = 5632 - 50000 * ((8 - block_id - 1) / n_returns);\n    int channel_offset_ns = 368 + 1512 * channel_id;\n    return block_offset_ns + channel_offset_ns;\n  }\n\n  ReturnType getReturnType(\n    hesai_packet::return_mode::ReturnMode return_mode, unsigned int return_idx,\n    const std::vector&lt;const typename packet_t::body_t::block_t::unit_t *&gt; &amp; return_units) override\n  {\n    auto return_type = HesaiSensor&lt;packet_t&gt;::getReturnType(return_mode, return_idx, return_units);\n    if (return_type == ReturnType::IDENTICAL) {\n      return return_type;\n    }\n\n    // This sensor orders returns in the opposite order, so the return_type needs to be flipped too\n    if (return_mode == hesai_packet::return_mode::DUAL_FIRST_LAST) {\n      if (return_type == ReturnType::FIRST)\n        return_type = ReturnType::LAST;\n      else if (return_type == ReturnType::LAST)\n        return_type = ReturnType::FIRST;\n    }\n\n    return return_type;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xt32m_8hpp/","title":"File pandar_xt32m.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xt32m.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/pandar__xt32m_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace hesai_packet"},{"location":"nebula_decoders/pandar__xt32m_8hpp/#classes","title":"Classes","text":"Type Name class PandarXT32M struct PacketXT32M2X <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32m.hpp</code></p>"},{"location":"nebula_decoders/pandar__xt32m_8hpp_source/","title":"File pandar_xt32m.hpp","text":"<p>File List &gt; decoders &gt; pandar_xt32m.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_sensor.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt32.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nnamespace hesai_packet\n{\n\n#pragma pack(push, 1)\n\ntypedef TailXT32 TailXT32M2X;\nstruct PacketXT32M2X : public PacketBase&lt;6, 32, 3, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit4B, PacketXT32M2X::N_CHANNELS&gt;, PacketXT32M2X::N_BLOCKS&gt; body_t;\n  Header12B header;\n  body_t body;\n  TailXT32M2X tail;\n  uint32_t udp_sequence;\n};\n\n#pragma pack(pop)\n\n}  // namespace hesai_packet\n\nclass PandarXT32M : public HesaiSensor&lt;hesai_packet::PacketXT32M2X&gt;\n{\npublic:\n  static constexpr float MIN_RANGE = 0.5f;\n  static constexpr float MAX_RANGE = 300.0f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 384000;\n\n  int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id, const packet_t &amp; packet) override\n  {\n    auto n_returns = hesai_packet::get_n_returns(packet.tail.return_mode);\n    int block_offset_ns;\n    if (n_returns &lt; 3) {\n      block_offset_ns = 5632 - 50000 * ((8 - block_id - 1) / n_returns);\n    } else /* n_returns == 3 */ {\n      block_offset_ns = 5632 - 50000 * ((6 - block_id - 1) / 3);\n    }\n\n    if (channel_id &gt;= 16) {\n      channel_id -= 16;\n    }\n    int channel_offset_ns = 368 + 2888 * channel_id;\n\n    return block_offset_ns + channel_offset_ns;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/dir_30f0f1e3f13639e488282486ac0b4643/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_robosense","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_robosense</p>"},{"location":"nebula_decoders/dir_30f0f1e3f13639e488282486ac0b4643/#files","title":"Files","text":"Type Name file robosense_driver.hpp file robosense_info_driver.hpp"},{"location":"nebula_decoders/dir_30f0f1e3f13639e488282486ac0b4643/#directories","title":"Directories","text":"Type Name dir decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/</code></p>"},{"location":"nebula_decoders/dir_b9ae2cd6a12bf8be72dcc60db21285fd/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders","text":"<p>FileList &gt; decoders</p>"},{"location":"nebula_decoders/dir_b9ae2cd6a12bf8be72dcc60db21285fd/#files","title":"Files","text":"Type Name file angle_corrector.hpp file angle_corrector_calibration_based.hpp file bpearl_v3.hpp file bpearl_v4.hpp file helios.hpp file robosense_decoder.hpp file robosense_info_decoder.hpp file robosense_info_decoder_base.hpp file robosense_packet.hpp file robosense_scan_decoder.hpp file robosense_sensor.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/</code></p>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector_8hpp/","title":"File angle_corrector.hpp","text":"<p>FileList &gt; decoders &gt; angle_corrector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector_8hpp/#classes","title":"Classes","text":"Type Name class AngleCorrector Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. struct CorrectedAngleData <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector.hpp</code></p>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector_8hpp_source/","title":"File angle_corrector.hpp","text":"<p>File List &gt; decoders &gt; angle_corrector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/robosense/robosense_common.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nstruct CorrectedAngleData\n{\n  float azimuth_rad;\n  float elevation_rad;\n  float sin_azimuth;\n  float cos_azimuth;\n  float sin_elevation;\n  float cos_elevation;\n  uint16_t corrected_channel_id;\n};\n\nclass AngleCorrector\n{\nprotected:\n  const std::shared_ptr&lt;RobosenseCalibrationConfiguration&gt; sensor_calibration_;\n\npublic:\n  explicit AngleCorrector(\n    const std::shared_ptr&lt;RobosenseCalibrationConfiguration&gt; &amp; sensor_calibration)\n  : sensor_calibration_(sensor_calibration)\n  {\n  }\n\n  virtual CorrectedAngleData getCorrectedAngleData(uint32_t block_azimuth, uint32_t channel_id) = 0;\n\n  virtual bool hasScanned(int current_azimuth, int last_azimuth) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector__calibration__based_8hpp/","title":"File angle_corrector_calibration_based.hpp","text":"<p>FileList &gt; decoders &gt; angle_corrector_calibration_based.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector__calibration__based_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector__calibration__based_8hpp/#classes","title":"Classes","text":"Type Name class AngleCorrectorCalibrationBased &lt;ChannelN, AngleUnit&gt; <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector_calibration_based.hpp</code></p>"},{"location":"nebula_decoders/nebula__decoders__robosense_2decoders_2angle__corrector__calibration__based_8hpp_source/","title":"File angle_corrector_calibration_based.hpp","text":"<p>File List &gt; decoders &gt; angle_corrector_calibration_based.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;size_t ChannelN, size_t AngleUnit&gt;\nclass AngleCorrectorCalibrationBased : public AngleCorrector\n{\nprivate:\n  static constexpr size_t MAX_AZIMUTH_LEN = 360 * AngleUnit;\n\n  std::array&lt;float, ChannelN&gt; elevation_angle_rad_{};\n  std::array&lt;float, ChannelN&gt; azimuth_offset_rad_{};\n  std::array&lt;float, MAX_AZIMUTH_LEN&gt; block_azimuth_rad_{};\n\n  std::array&lt;float, ChannelN&gt; elevation_cos_{};\n  std::array&lt;float, ChannelN&gt; elevation_sin_{};\n  std::array&lt;std::array&lt;float, ChannelN&gt;, MAX_AZIMUTH_LEN&gt; azimuth_cos_{};\n  std::array&lt;std::array&lt;float, ChannelN&gt;, MAX_AZIMUTH_LEN&gt; azimuth_sin_{};\n\npublic:\n  explicit AngleCorrectorCalibrationBased(\n    const std::shared_ptr&lt;RobosenseCalibrationConfiguration&gt; &amp; sensor_calibration)\n  : AngleCorrector(sensor_calibration)\n  {\n    if (sensor_calibration == nullptr) {\n      throw std::runtime_error(\n        \"Cannot instantiate AngleCorrectorCalibrationBased without calibration data\");\n    }\n\n    for (size_t channel_id = 0; channel_id &lt; ChannelN; ++channel_id) {\n      const auto correction = sensor_calibration-&gt;GetCorrection(channel_id);\n      float elevation_angle_deg = correction.elevation;\n      float azimuth_offset_deg = correction.azimuth;\n\n      elevation_angle_rad_[channel_id] = deg2rad(elevation_angle_deg);\n      azimuth_offset_rad_[channel_id] = deg2rad(azimuth_offset_deg);\n\n      elevation_cos_[channel_id] = cosf(elevation_angle_rad_[channel_id]);\n      elevation_sin_[channel_id] = sinf(elevation_angle_rad_[channel_id]);\n    }\n\n    for (size_t block_azimuth = 0; block_azimuth &lt; MAX_AZIMUTH_LEN; block_azimuth++) {\n      block_azimuth_rad_[block_azimuth] = deg2rad(block_azimuth / static_cast&lt;double&gt;(AngleUnit));\n\n      for (size_t channel_id = 0; channel_id &lt; ChannelN; ++channel_id) {\n        float precision_azimuth =\n          block_azimuth_rad_[block_azimuth] + azimuth_offset_rad_[channel_id];\n\n        azimuth_cos_[block_azimuth][channel_id] = cosf(precision_azimuth);\n        azimuth_sin_[block_azimuth][channel_id] = sinf(precision_azimuth);\n      }\n    }\n  }\n\n  CorrectedAngleData getCorrectedAngleData(uint32_t block_azimuth, uint32_t channel_id) override\n  {\n    float azimuth_rad = block_azimuth_rad_[block_azimuth] + azimuth_offset_rad_[channel_id];\n    float elevation_rad = elevation_angle_rad_[channel_id];\n\n    return {\n      azimuth_rad,\n      elevation_rad,\n      azimuth_sin_[block_azimuth][channel_id],\n      azimuth_cos_[block_azimuth][channel_id],\n      elevation_sin_[channel_id],\n      elevation_cos_[channel_id],\n      sensor_calibration_-&gt;calibration[channel_id].channel};\n  }\n\n  bool hasScanned(int current_azimuth, int last_azimuth) override\n  {\n    return current_azimuth &lt; last_azimuth;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/bpearl__v3_8hpp/","title":"File bpearl_v3.hpp","text":"<p>FileList &gt; decoders &gt; bpearl_v3.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"</code></li> <li><code>#include \"boost/endian/buffers.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/bpearl__v3_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace endian namespace nebula namespace drivers namespace robosense_packet namespace bpearl_v3"},{"location":"nebula_decoders/bpearl__v3_8hpp/#classes","title":"Classes","text":"Type Name class BpearlV3 struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet struct Timestamp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp</code></p>"},{"location":"nebula_decoders/bpearl__v3_8hpp_source/","title":"File bpearl_v3.hpp","text":"<p>File List &gt; decoders &gt; bpearl_v3.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"\n\n#include \"boost/endian/buffers.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n\nusing namespace boost::endian;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace robosense_packet\n{\nnamespace bpearl_v3\n{\n#pragma pack(push, 1)\n\nstruct Timestamp\n{\n  big_uint8_buf_t year;\n  big_uint8_buf_t month;\n  big_uint8_buf_t day;\n  big_uint8_buf_t hour;\n  big_uint8_buf_t minute;\n  big_uint8_buf_t second;\n  big_uint16_buf_t millisecond;\n  big_uint16_buf_t microsecond;\n\n  [[nodiscard]] uint64_t get_time_in_ns() const\n  {\n    std::tm tm{};\n    tm.tm_year = year.value() + 100;\n    tm.tm_mon = month.value() - 1;  // starts from 0 in C\n    tm.tm_mday = day.value();\n    tm.tm_hour = hour.value();\n    tm.tm_min = minute.value();\n    tm.tm_sec = second.value();\n    const uint64_t time = timegm(&amp;tm) * 1000000000ULL + millisecond.value() * 1000000ULL +\n                          microsecond.value() * 1000ULL;\n    return time;\n  }\n};\n\nstruct Header\n{\n  big_uint64_buf_t header_id;\n  big_uint32_buf_t checksum;\n  big_uint32_buf_t packet_count;\n  big_uint32_buf_t reserved_first;\n  Timestamp timestamp;\n  big_uint8_buf_t lidar_model;\n  uint8_t reserved_second[7];\n  big_uint16_buf_t temperature;\n  big_uint16_buf_t top_board_temperature;\n};\n\nstruct Packet : public PacketBase&lt;12, 32, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; body_t;\n  Header header;\n  body_t body;\n  big_uint48_buf_t tail;\n};\n\nstruct OperatingStatus\n{\n  big_uint48_buf_t reserved;\n  big_uint16_buf_t v_dat_0v5;\n  big_uint16_buf_t v_dat_12v;\n  big_uint16_buf_t v_dat_5v;\n  big_uint16_buf_t v_dat_1v25;\n  big_uint16_buf_t v_dat_0v;\n  big_uint16_buf_t v_dat_1v;\n};\n\nstruct FaultDiagnosis\n{\n  uint8_t reserved_first[11];\n  big_uint16_buf_t manc_err1;\n  big_uint16_buf_t manc_err2;\n  big_uint8_buf_t gps_st;\n  big_uint8_buf_t temperature1;\n  big_uint8_buf_t temperature2;\n  uint8_t reserved_second[2];\n  big_uint8_buf_t temperature3;\n  big_uint8_buf_t temperature4;\n  big_uint8_buf_t temperature5;\n  big_uint8_buf_t temperature6;\n  uint8_t reserved_third[7];\n  big_uint8_buf_t r_rpm1;\n  big_uint8_buf_t r_rpm2;\n  uint8_t reserved_fourth[7];\n};\n\nstruct InfoPacket\n{\n  big_uint64_buf_t header;\n  big_uint16_buf_t motor_speed;\n  Ethernet ethernet;\n  FovSetting fov_setting;\n  big_uint16_buf_t tcp_msop_port;\n  big_uint16_buf_t phase_lock;\n  FirmwareVersion top_firmware_version;\n  FirmwareVersion bottom_firmware_version;\n  FirmwareVersion bottom_software_version;\n  FirmwareVersion motor_firmware_version;\n  uint8_t reserved_first[230];\n  big_uint16_buf_t reverse_zero_angle_offset;\n  SerialNumber serial_number;\n  big_uint16_buf_t zero_angle_offset;\n  big_uint8_buf_t return_mode;\n  big_uint8_buf_t time_sync_mode;\n  big_uint8_buf_t sync_status;\n  Timestamp time;\n  OperatingStatus operating_status;\n  uint8_t reserved_second[6];\n  big_uint8_buf_t rotation_direction;\n  big_uint32_buf_t elapsed_time_flag;\n  FaultDiagnosis fault_diagnosis;\n  big_uint8_buf_t gprmc[86];\n  SensorCalibration sensor_calibration;\n  uint8_t reserved_fourth[586];\n  big_uint16_buf_t tail;\n};\n\n#pragma pack(pop)\n}  // namespace bpearl_v3\n\ntemplate &lt;&gt;\ninline double get_dis_unit&lt;bpearl_v3::Packet&gt;(const bpearl_v3::Packet &amp; /* packet */)\n{\n  return 0.005;\n}\n\n}  // namespace robosense_packet\n\nclass BpearlV3 : public RobosenseSensor&lt;\n                   robosense_packet::bpearl_v3::Packet, robosense_packet::bpearl_v3::InfoPacket&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_single_[12][32]{\n    {0,   256, 512, 768, 1024, 1280, 1536, 1792, 2568, 2824, 3080, 3336, 3592, 3848, 4104, 4360,\n     128, 384, 640, 896, 1152, 1408, 1664, 1920, 2696, 2952, 3208, 3464, 3720, 3976, 4232, 4488},\n    {5552, 5808, 6064, 6320, 6576, 6832, 7088, 7344, 8120, 8376, 8632,\n     8888, 9144, 9400, 9656, 9912, 5680, 5936, 6192, 6448, 6704, 6960,\n     7216, 7472, 8248, 8504, 8760, 9016, 9272, 9528, 9784, 10040},\n    {11104, 11360, 11616, 11872, 12128, 12384, 12640, 12896, 13672, 13928, 14184,\n     14440, 14696, 14952, 15208, 15464, 11232, 11488, 11744, 12000, 12256, 12512,\n     12768, 13024, 13800, 14056, 14312, 14568, 14824, 15080, 15336, 15592},\n    {16656, 16912, 17168, 17424, 17680, 17936, 18192, 18448, 19224, 19480, 19736,\n     19992, 20248, 20504, 20760, 21016, 16784, 17040, 17296, 17552, 17808, 18064,\n     18320, 18576, 19352, 19608, 19864, 20120, 20376, 20632, 20888, 21144},\n    {22208, 22464, 22720, 22976, 23232, 23488, 23744, 24000, 24776, 25032, 25288,\n     25544, 25800, 26056, 26312, 26568, 22336, 22592, 22848, 23104, 23360, 23616,\n     23872, 24128, 24904, 25160, 25416, 25672, 25928, 26184, 26440, 26696},\n    {27760, 28016, 28272, 28528, 28784, 29040, 29296, 29552, 30328, 30584, 30840,\n     31096, 31352, 31608, 31864, 32120, 27888, 28144, 28400, 28656, 28912, 29168,\n     29424, 29680, 30456, 30712, 30968, 31224, 31480, 31736, 31992, 32248},\n    {33312, 33568, 33824, 34080, 34336, 34592, 34848, 35104, 35880, 36136, 36392,\n     36648, 36904, 37160, 37416, 37672, 33440, 33696, 33952, 34208, 34464, 34720,\n     34976, 35232, 36008, 36264, 36520, 36776, 37032, 37288, 37544, 37800},\n    {38864, 39120, 39376, 39632, 39888, 40144, 40400, 40656, 41432, 41688, 41944,\n     42200, 42456, 42712, 42968, 43224, 38992, 39248, 39504, 39760, 40016, 40272,\n     40528, 40784, 41560, 41816, 42072, 42328, 42584, 42840, 43096, 43352},\n    {44416, 44672, 44928, 45184, 45440, 45696, 45952, 46208, 46984, 47240, 47496,\n     47752, 48008, 48264, 48520, 48776, 44544, 44800, 45056, 45312, 45568, 45824,\n     46080, 46336, 47112, 47368, 47624, 47880, 48136, 48392, 48648, 48904},\n    {49968, 50224, 50480, 50736, 50992, 51248, 51504, 51760, 52536, 52792, 53048,\n     53304, 53560, 53816, 54072, 54328, 50096, 50352, 50608, 50864, 51120, 51376,\n     51632, 51888, 52664, 52920, 53176, 53432, 53688, 53944, 54200, 54456},\n    {55520, 55776, 56032, 56288, 56544, 56800, 57056, 57312, 58088, 58344, 58600,\n     58856, 59112, 59368, 59624, 59880, 55648, 55904, 56160, 56416, 56672, 56928,\n     57184, 57440, 58216, 58472, 58728, 58984, 59240, 59496, 59752, 60008},\n    {61072, 61328, 61584, 61840, 62096, 62352, 62608, 62864, 63640, 63896, 64152,\n     64408, 64664, 64920, 65176, 65432, 61200, 61456, 61712, 61968, 62224, 62480,\n     62736, 62992, 63768, 64024, 64280, 64536, 64792, 65048, 65304, 65560}};\n\n  static constexpr int firing_time_offset_ns_dual_[12][32]{\n    {0,   256, 512, 768, 1024, 1280, 1536, 1792, 2568, 2824, 3080, 3336, 3592, 3848, 4104, 4360,\n     128, 384, 640, 896, 1152, 1408, 1664, 1920, 2696, 2952, 3208, 3464, 3720, 3976, 4232, 4488},\n    {0,   256, 512, 768, 1024, 1280, 1536, 1792, 2568, 2824, 3080, 3336, 3592, 3848, 4104, 4360,\n     128, 384, 640, 896, 1152, 1408, 1664, 1920, 2696, 2952, 3208, 3464, 3720, 3976, 4232, 4488},\n    {5552, 5808, 6064, 6320, 6576, 6832, 7088, 7344, 8120, 8376, 8632,\n     8888, 9144, 9400, 9656, 9912, 5680, 5936, 6192, 6448, 6704, 6960,\n     7216, 7472, 8248, 8504, 8760, 9016, 9272, 9528, 9784, 10040},\n    {5552, 5808, 6064, 6320, 6576, 6832, 7088, 7344, 8120, 8376, 8632,\n     8888, 9144, 9400, 9656, 9912, 5680, 5936, 6192, 6448, 6704, 6960,\n     7216, 7472, 8248, 8504, 8760, 9016, 9272, 9528, 9784, 10040},\n    {11104, 11360, 11616, 11872, 12128, 12384, 12640, 12896, 13672, 13928, 14184,\n     14440, 14696, 14952, 15208, 15464, 11232, 11488, 11744, 12000, 12256, 12512,\n     12768, 13024, 13800, 14056, 14312, 14568, 14824, 15080, 15336, 15592},\n    {11104, 11360, 11616, 11872, 12128, 12384, 12640, 12896, 13672, 13928, 14184,\n     14440, 14696, 14952, 15208, 15464, 11232, 11488, 11744, 12000, 12256, 12512,\n     12768, 13024, 13800, 14056, 14312, 14568, 14824, 15080, 15336, 15592},\n    {16656, 16912, 17168, 17424, 17680, 17936, 18192, 18448, 19224, 19480, 19736,\n     19992, 20248, 20504, 20760, 21016, 16784, 17040, 17296, 17552, 17808, 18064,\n     18320, 18576, 19352, 19608, 19864, 20120, 20376, 20632, 20888, 21144},\n    {16656, 16912, 17168, 17424, 17680, 17936, 18192, 18448, 19224, 19480, 19736,\n     19992, 20248, 20504, 20760, 21016, 16784, 17040, 17296, 17552, 17808, 18064,\n     18320, 18576, 19352, 19608, 19864, 20120, 20376, 20632, 20888, 21144},\n    {22208, 22464, 22720, 22976, 23232, 23488, 23744, 24000, 24776, 25032, 25288,\n     25544, 25800, 26056, 26312, 26568, 22336, 22592, 22848, 23104, 23360, 23616,\n     23872, 24128, 24904, 25160, 25416, 25672, 25928, 26184, 26440, 26696},\n    {22208, 22464, 22720, 22976, 23232, 23488, 23744, 24000, 24776, 25032, 25288,\n     25544, 25800, 26056, 26312, 26568, 22336, 22592, 22848, 23104, 23360, 23616,\n     23872, 24128, 24904, 25160, 25416, 25672, 25928, 26184, 26440, 26696},\n    {27760, 28016, 28272, 28528, 28784, 29040, 29296, 29552, 30328, 30584, 30840,\n     31096, 31352, 31608, 31864, 32120, 27888, 28144, 28400, 28656, 28912, 29168,\n     29424, 29680, 30456, 30712, 30968, 31224, 31480, 31736, 31992, 32248},\n    {27760, 28016, 28272, 28528, 28784, 29040, 29296, 29552, 30328, 30584, 30840,\n     31096, 31352, 31608, 31864, 32120, 27888, 28144, 28400, 28656, 28912, 29168,\n     29424, 29680, 30456, 30712, 30968, 31224, 31480, 31736, 31992, 32248}};\n\n  static constexpr uint8_t DUAL_RETURN_FLAG = 0x00;\n  static constexpr uint8_t STRONGEST_RETURN_FLAG = 0x01;\n  static constexpr uint8_t LAST_RETURN_FLAG = 0x02;\n\n  static constexpr uint8_t SYNC_MODE_GPS_FLAG = 0x00;\n  static constexpr uint8_t SYNC_MODE_E2E_FLAG = 0x01;\n  static constexpr uint8_t SYNC_MODE_P2P_FLAG = 0x02;\n  static constexpr uint8_t SYNC_MODE_GPTP_FLAG = 0x03;\n\n  static constexpr uint8_t SYNC_STATUS_INVALID_FLAG = 0x00;\n  static constexpr uint8_t SYNC_STATUS_GPS_SUCCESS_FLAG = 0x01;\n  static constexpr uint8_t SYNC_STATUS_PTP_SUCCESS_FLAG = 0x02;\n\npublic:\n  static constexpr float MIN_RANGE = 0.1f;\n  static constexpr float MAX_RANGE = 30.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 1152000;\n\n  int getPacketRelativePointTimeOffset(\n    const uint32_t block_id, const uint32_t channel_id,\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration) override\n  {\n    if (sensor_configuration-&gt;return_mode == ReturnMode::DUAL)\n      return firing_time_offset_ns_dual_[block_id][channel_id];\n    else\n      return firing_time_offset_ns_single_[block_id][channel_id];\n  }\n\n  ReturnMode getReturnMode(const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        return ReturnMode::DUAL;\n      case STRONGEST_RETURN_FLAG:\n        return ReturnMode::SINGLE_STRONGEST;\n      case LAST_RETURN_FLAG:\n        return ReturnMode::SINGLE_LAST;\n      default:\n        return ReturnMode::UNKNOWN;\n    }\n  }\n\n  RobosenseCalibrationConfiguration getSensorCalibration(\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)\n  {\n    return info_packet.sensor_calibration.getCalibration();\n  }\n\n  bool getSyncStatus(const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.sync_status.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        return false;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        return true;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  std::map&lt;std::string, std::string&gt; getSensorInfo(\n    const robosense_packet::bpearl_v3::InfoPacket &amp; info_packet)\n  {\n    std::map&lt;std::string, std::string&gt; sensor_info;\n    sensor_info[\"motor_speed\"] = std::to_string(info_packet.motor_speed.value());\n    sensor_info[\"lidar_ip\"] = info_packet.ethernet.lidar_ip.to_string();\n    sensor_info[\"dest_pc_ip\"] = info_packet.ethernet.dest_pc_ip.to_string();\n    sensor_info[\"mac_addr\"] = info_packet.ethernet.mac_addr.to_string();\n    sensor_info[\"lidar_out_msop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_msop_port.value());\n    sensor_info[\"lidar_out_difop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_difop_port.value());\n    sensor_info[\"fov_start\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_start.value());\n    sensor_info[\"fov_end\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_end.value());\n    sensor_info[\"tcp_msop_port\"] = std::to_string(info_packet.tcp_msop_port.value());\n    sensor_info[\"phase_lock\"] = std::to_string(info_packet.phase_lock.value());\n    sensor_info[\"top_firmware_version\"] = info_packet.top_firmware_version.to_string();\n    sensor_info[\"bottom_firmware_version\"] = info_packet.bottom_firmware_version.to_string();\n    sensor_info[\"bottom_software_version\"] = info_packet.bottom_software_version.to_string();\n    sensor_info[\"motor_firmware_version\"] = info_packet.motor_firmware_version.to_string();\n    sensor_info[\"reverse_zero_angle_offset\"] =\n      std::to_string(info_packet.reverse_zero_angle_offset.value());\n    sensor_info[\"serial_number\"] = info_packet.serial_number.to_string();\n    sensor_info[\"zero_angle_offset\"] = std::to_string(info_packet.zero_angle_offset.value());\n\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"dual\";\n        break;\n      case STRONGEST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"strongest\";\n        break;\n      case LAST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"last\";\n        break;\n      default:\n        sensor_info[\"return_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.time_sync_mode.value()) {\n      case SYNC_MODE_GPS_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gps\";\n        break;\n      case SYNC_MODE_E2E_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"e2e\";\n        break;\n      case SYNC_MODE_P2P_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"p2p\";\n        break;\n      case SYNC_MODE_GPTP_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gptp\";\n        break;\n      default:\n        sensor_info[\"time_sync_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.sync_status.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        sensor_info[\"sync_status\"] = \"time_sync_invalid\";\n        break;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        sensor_info[\"sync_status\"] = \"gps_time_sync_successful\";\n        break;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        sensor_info[\"sync_status\"] = \"ptp_time_sync_successful\";\n        break;\n      default:\n        sensor_info[\"sync_status\"] = \"n/a\";\n    }\n\n    sensor_info[\"time\"] = std::to_string(info_packet.time.get_time_in_ns());\n    sensor_info[\"v_dat_0v5\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_0v5.value());\n    sensor_info[\"v_dat_12v\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_12v.value());\n    sensor_info[\"v_dat_5v\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_5v.value());\n    sensor_info[\"v_dat_1v25\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_1v25.value());\n    sensor_info[\"v_dat_0v\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_0v.value());\n    sensor_info[\"v_dat_1v\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.v_dat_1v.value());\n    sensor_info[\"rotation_direction\"] = std::to_string(info_packet.rotation_direction.value());\n    sensor_info[\"elapsed_time_flag\"] = std::to_string(info_packet.elapsed_time_flag.value());\n\n    sensor_info[\"manc_err1\"] = std::to_string(info_packet.fault_diagnosis.manc_err1.value());\n    sensor_info[\"manc_err2\"] = std::to_string(info_packet.fault_diagnosis.manc_err2.value());\n\n    const std::bitset&lt;8&gt; gps_st_bits{info_packet.fault_diagnosis.gps_st.value()};\n    if (gps_st_bits[0])\n      sensor_info[\"pps_lock\"] = \"valid\";\n    else\n      sensor_info[\"pps_lock\"] = \"invalid\";\n    if (gps_st_bits[1])\n      sensor_info[\"gprmc_lock\"] = \"valid\";\n    else\n      sensor_info[\"gprmc_lock\"] = \"invalid\";\n    if (gps_st_bits[2])\n      sensor_info[\"utc_lock\"] = \"synchronized\";\n    else\n      sensor_info[\"utc_lock\"] = \"not_synchronized\";\n    if (gps_st_bits[3])\n      sensor_info[\"gprmc_input_status\"] = \"received_gprmc\";\n    else\n      sensor_info[\"gprmc_input_status\"] = \"no_gprmc\";\n    if (gps_st_bits[4])\n      sensor_info[\"pps_input_status\"] = \"received_pps\";\n    else\n      sensor_info[\"pps_input_status\"] = \"no_pps\";\n\n    /*\n     * From the manual, here is the formula for calculating bottom board temperature:\n     * Temp =\uff08Value\uff08temp1\uff09* 256 + Value\uff08temp2\uff09&amp; 0Xffff\uff09* 503.975 / 4096.0 - 273.15\n     */\n    sensor_info[\"bottom_board_temp\"] = std::to_string(\n      (static_cast&lt;float&gt;(info_packet.fault_diagnosis.temperature1.value()) * 256 +\n       static_cast&lt;float&gt;(info_packet.fault_diagnosis.temperature2.value())) *\n        503.975 / 4096.0 -\n      273.15);\n\n    /*\n     * From the manual, here is the formula for calculating APD temperature:\n     * When Value \u2264 32768, the temperature value is positive; otherwise negative.\n     * Temp = ( (value(362) * 256 + value(363) ) &amp; 0x7FF8 ) / 128.0\n     */\n    double apd_temp = ((info_packet.fault_diagnosis.temperature3.value() * 256 +\n                        info_packet.fault_diagnosis.temperature4.value()) &amp;\n                       0x7FF8) /\n                      128.0;\n    if (\n      ((info_packet.fault_diagnosis.temperature3.value() &lt;&lt; 8)) +\n        info_packet.fault_diagnosis.temperature4.value() &gt;\n      32768)\n      apd_temp = -apd_temp;\n    sensor_info[\"apd_temp\"] = std::to_string(apd_temp);\n\n    /*\n     * From the manual, here is the formula for calculating top board temperature:\n     * When Value \u2264 32768, the temperature value is positive; otherwise negative.\n     * Temp= ( (value(362) * 256 + value(363) ) &amp; 0x7FF8 ) / 128.0\n     */\n    double top_board_temp = ((info_packet.fault_diagnosis.temperature5.value() * 256 +\n                              info_packet.fault_diagnosis.temperature6.value()) &amp;\n                             0x7FF8) /\n                            128.0;\n    if (\n      ((info_packet.fault_diagnosis.temperature5.value() &lt;&lt; 8)) +\n        info_packet.fault_diagnosis.temperature6.value() &gt;\n      32768)\n      top_board_temp = -top_board_temp;\n    sensor_info[\"top_board_temp\"] = std::to_string(top_board_temp);\n\n    /*\n     * From the manual, here is the formula for calculating real time rotation speed:\n     * Speed = (256 * r_rpm1 + r_rpm2) / 6\n     */\n    sensor_info[\"real_time_rot_speed\"] = std::to_string(\n      (info_packet.fault_diagnosis.r_rpm1.value() * 256 +\n       info_packet.fault_diagnosis.r_rpm2.value()) /\n      6);\n\n    std::string gprmc_string;\n    for (auto i : info_packet.gprmc) {\n      gprmc_string += static_cast&lt;char&gt;(i.value());\n    }\n    sensor_info[\"gprmc_string\"] = gprmc_string;\n\n    return sensor_info;\n  }\n};\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/bpearl__v4_8hpp/","title":"File bpearl_v4.hpp","text":"<p>FileList &gt; decoders &gt; bpearl_v4.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"</code></li> <li><code>#include \"boost/endian/buffers.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/bpearl__v4_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace robosense_packet namespace bpearl_v4"},{"location":"nebula_decoders/bpearl__v4_8hpp/#classes","title":"Classes","text":"Type Name class BpearlV4 struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp</code></p>"},{"location":"nebula_decoders/bpearl__v4_8hpp_source/","title":"File bpearl_v4.hpp","text":"<p>File List &gt; decoders &gt; bpearl_v4.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"\n\n#include \"boost/endian/buffers.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n\nusing namespace boost::endian;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace robosense_packet\n{\nnamespace bpearl_v4\n{\n#pragma pack(push, 1)\n\nstruct Header\n{\n  big_uint64_buf_t header_id;\n  uint8_t reserved_first[4];\n  big_uint32_buf_t packet_count;\n  uint8_t reserved_second[4];\n  Timestamp timestamp;\n  uint8_t reserved_third[1];\n  big_uint8_buf_t lidar_type;\n  big_uint8_buf_t lidar_model;\n  uint8_t reserved_fourth[9];\n};\n\nstruct Packet : public PacketBase&lt;12, 32, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; body_t;\n  Header header;\n  body_t body;\n  big_uint48_buf_t tail;\n};\n\nstruct OperatingStatus\n{\n  big_uint8_buf_t reserved_first;\n  big_uint16_buf_t machine_current;\n  big_uint24_buf_t reserved_second;\n  big_uint16_buf_t machine_voltage;\n  uint8_t reserved_third[16];\n};\n\nstruct FaultDiagnosis\n{\n  big_uint16_buf_t startup_times;\n  big_uint32_buf_t reserved;\n  big_uint8_buf_t gps_status;\n  big_uint16_buf_t machine_temp;\n  uint8_t reserved_first[11];\n  big_uint16_buf_t phase;\n  big_uint16_buf_t rotation_speed;\n};\n\nstruct InfoPacket\n{\n  big_uint64_buf_t header;\n  big_uint16_buf_t motor_speed_setting;\n  Ethernet ethernet;\n  FovSetting fov_setting;\n  big_uint16_buf_t tcp_msop_port;\n  big_uint16_buf_t phase_lock;\n  FirmwareVersion mainboard_firmware_version;\n  FirmwareVersion bottom_firmware_version;\n  FirmwareVersion app_software_version;\n  FirmwareVersion motor_firmware_version;\n  uint8_t reserved_first[228];\n  big_uint8_buf_t baud_rate;\n  uint8_t reserved_second[3];\n  SerialNumber serial_number;\n  uint8_t reserved_third[2];\n  big_uint8_buf_t return_mode;\n  big_uint8_buf_t time_sync_mode;\n  big_uint8_buf_t time_sync_state;\n  Timestamp time;\n  OperatingStatus operating_status;\n  big_uint8_buf_t rotation_direction;\n  big_uint32_buf_t running_time;\n  uint8_t reserved_fourth[9];\n  FaultDiagnosis fault_diagnosis;\n  uint8_t reserved_fifth[7];\n  big_uint8_buf_t gprmc[86];\n  SensorCalibration sensor_calibration;\n  uint8_t reserved_sixth[586];\n  big_uint16_buf_t tail;\n};\n\n#pragma pack(pop)\n}  // namespace bpearl_v4\n\ntemplate &lt;&gt;\ninline double get_dis_unit&lt;bpearl_v4::Packet&gt;(const bpearl_v4::Packet &amp; /* packet */)\n{\n  return 0.0025;\n}\n\n}  // namespace robosense_packet\n\nclass BpearlV4 : public RobosenseSensor&lt;\n                   robosense_packet::bpearl_v4::Packet, robosense_packet::bpearl_v4::InfoPacket&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_single_[12][32] = {\n    {0,    167,  334,  500,  667,  834,  1001, 1168, 1334, 1501, 1668,\n     1835, 2002, 2168, 2335, 2502, 2669, 2836, 3002, 3169, 3336, 3503,\n     3670, 3836, 4003, 4170, 4337, 4504, 4670, 4837, 5004, 5171},\n    {5555, 5722, 5889, 6055, 6222, 6389,  6556,  6723,  6889,  7056, 7223,\n     7390, 7557, 7723, 7890, 8057, 8224,  8391,  8557,  8724,  8891, 9058,\n     9225, 9391, 9558, 9725, 9892, 10059, 10225, 10392, 10559, 10726},\n    {11110, 11277, 11444, 11610, 11777, 11944, 12111, 12278, 12444, 12611, 12778,\n     12945, 13112, 13278, 13445, 13612, 13779, 13946, 14112, 14279, 14446, 14613,\n     14780, 14946, 15113, 15280, 15447, 15614, 15780, 15947, 16114, 16281},\n    {16665, 16832, 16999, 17165, 17332, 17499, 17666, 17833, 17999, 18166, 18333,\n     18500, 18667, 18833, 19000, 19167, 19334, 19501, 19667, 19834, 20001, 20168,\n     20335, 20501, 20668, 20835, 21002, 21169, 21335, 21502, 21669, 21836},\n    {22220, 22387, 22554, 22720, 22887, 23054, 23221, 23388, 23554, 23721, 23888,\n     24055, 24222, 24388, 24555, 24722, 24889, 25056, 25222, 25389, 25556, 25723,\n     25890, 26056, 26223, 26390, 26557, 26724, 26890, 27057, 27224, 27391},\n    {27775, 27942, 28109, 28275, 28442, 28609, 28776, 28943, 29109, 29276, 29443,\n     29610, 29777, 29943, 30110, 30277, 30444, 30611, 30777, 30944, 31111, 31278,\n     31445, 31611, 31778, 31945, 32112, 32279, 32445, 32612, 32779, 32946},\n    {33330, 33497, 33664, 33830, 33997, 34164, 34331, 34498, 34664, 34831, 34998,\n     35165, 35332, 35498, 35665, 35832, 35999, 36166, 36332, 36499, 36666, 36833,\n     37000, 37166, 37333, 37500, 37667, 37834, 38000, 38167, 38334, 38501},\n    {38885, 39052, 39219, 39385, 39552, 39719, 39886, 40053, 40219, 40386, 40553,\n     40720, 40887, 41053, 41220, 41387, 41554, 41721, 41887, 42054, 42221, 42388,\n     42555, 42721, 42888, 43055, 43222, 43389, 43555, 43722, 43889, 44056},\n    {44440, 44607, 44774, 44940, 45107, 45274, 45441, 45608, 45774, 45941, 46108,\n     46275, 46442, 46608, 46775, 46942, 47109, 47276, 47442, 47609, 47776, 47943,\n     48110, 48276, 48443, 48610, 48777, 48944, 49110, 49277, 49444, 49611},\n    {49995, 50162, 50329, 50495, 50662, 50829, 50996, 51163, 51329, 51496, 51663,\n     51830, 51997, 52163, 52330, 52497, 52664, 52831, 52997, 53164, 53331, 53498,\n     53665, 53831, 53998, 54165, 54332, 54499, 54665, 54832, 54999, 55166},\n    {55550, 55717, 55884, 56050, 56217, 56384, 56551, 56718, 56884, 57051, 57218,\n     57385, 57552, 57718, 57885, 58052, 58219, 58386, 58552, 58719, 58886, 59053,\n     59220, 59386, 59553, 59720, 59887, 60054, 60220, 60387, 60554, 60721},\n    {61105, 61272, 61439, 61605, 61772, 61939, 62106, 62273, 62439, 62606, 62773,\n     62940, 63107, 63273, 63440, 63607, 63774, 63941, 64107, 64274, 64441, 64608,\n     64775, 64941, 65108, 65275, 65442, 65609, 65775, 65942, 66109, 66276}};\n\n  static constexpr int firing_time_offset_ns_dual_[12][32]{\n    {0,    167,  334,  500,  667,  834,  1001, 1168, 1334, 1501, 1668,\n     1835, 2002, 2168, 2335, 2502, 2669, 2836, 3002, 3169, 3336, 3503,\n     3670, 3836, 4003, 4170, 4337, 4504, 4670, 4837, 5004, 5171},\n    {0,    167,  334,  500,  667,  834,  1001, 1168, 1334, 1501, 1668,\n     1835, 2002, 2168, 2335, 2502, 2669, 2836, 3002, 3169, 3336, 3503,\n     3670, 3836, 4003, 4170, 4337, 4504, 4670, 4837, 5004, 5171},\n    {5555, 5722, 5889, 6055, 6222, 6389,  6556,  6723,  6889,  7056, 7223,\n     7390, 7557, 7723, 7890, 8057, 8224,  8391,  8557,  8724,  8891, 9058,\n     9225, 9391, 9558, 9725, 9892, 10059, 10225, 10392, 10559, 10726},\n    {5555, 5722, 5889, 6055, 6222, 6389,  6556,  6723,  6889,  7056, 7223,\n     7390, 7557, 7723, 7890, 8057, 8224,  8391,  8557,  8724,  8891, 9058,\n     9225, 9391, 9558, 9725, 9892, 10059, 10225, 10392, 10559, 10726},\n    {11110, 11277, 11444, 11610, 11777, 11944, 12111, 12278, 12444, 12611, 12778,\n     12945, 13112, 13278, 13445, 13612, 13779, 13946, 14112, 14279, 14446, 14613,\n     14780, 14946, 15113, 15280, 15447, 15614, 15780, 15947, 16114, 16281},\n    {11110, 11277, 11444, 11610, 11777, 11944, 12111, 12278, 12444, 12611, 12778,\n     12945, 13112, 13278, 13445, 13612, 13779, 13946, 14112, 14279, 14446, 14613,\n     14780, 14946, 15113, 15280, 15447, 15614, 15780, 15947, 16114, 16281},\n    {16665, 16832, 16999, 17165, 17332, 17499, 17666, 17833, 17999, 18166, 18333,\n     18500, 18667, 18833, 19000, 19167, 19334, 19501, 19667, 19834, 20001, 20168,\n     20335, 20501, 20668, 20835, 21002, 21169, 21335, 21502, 21669, 21836},\n    {16665, 16832, 16999, 17165, 17332, 17499, 17666, 17833, 17999, 18166, 18333,\n     18500, 18667, 18833, 19000, 19167, 19334, 19501, 19667, 19834, 20001, 20168,\n     20335, 20501, 20668, 20835, 21002, 21169, 21335, 21502, 21669, 21836},\n    {22220, 22387, 22554, 22720, 22887, 23054, 23221, 23388, 23554, 23721, 23888,\n     24055, 24222, 24388, 24555, 24722, 24889, 25056, 25222, 25389, 25556, 25723,\n     25890, 26056, 26223, 26390, 26557, 26724, 26890, 27057, 27224, 27391},\n    {22220, 22387, 22554, 22720, 22887, 23054, 23221, 23388, 23554, 23721, 23888,\n     24055, 24222, 24388, 24555, 24722, 24889, 25056, 25222, 25389, 25556, 25723,\n     25890, 26056, 26223, 26390, 26557, 26724, 26890, 27057, 27224, 27391},\n    {27775, 27942, 28109, 28275, 28442, 28609, 28776, 28943, 29109, 29276, 29443,\n     29610, 29777, 29943, 30110, 30277, 30444, 30611, 30777, 30944, 31111, 31278,\n     31445, 31611, 31778, 31945, 32112, 32279, 32445, 32612, 32779, 32946},\n    {27775, 27942, 28109, 28275, 28442, 28609, 28776, 28943, 29109, 29276, 29443,\n     29610, 29777, 29943, 30110, 30277, 30444, 30611, 30777, 30944, 31111, 31278,\n     31445, 31611, 31778, 31945, 32112, 32279, 32445, 32612, 32779, 32946}};\n\n  static constexpr uint8_t DUAL_RETURN_FLAG = 0x00;\n  static constexpr uint8_t STRONGEST_RETURN_FLAG = 0x04;\n  static constexpr uint8_t LAST_RETURN_FLAG = 0x05;\n  static constexpr uint8_t FIRST_RETURN_FLAG = 0x06;\n\n  static constexpr uint8_t SYNC_MODE_GPS_FLAG = 0x00;\n  static constexpr uint8_t SYNC_MODE_E2E_FLAG = 0x01;\n  static constexpr uint8_t SYNC_MODE_P2P_FLAG = 0x02;\n  static constexpr uint8_t SYNC_MODE_GPTP_FLAG = 0x03;\n\n  static constexpr uint8_t SYNC_STATUS_INVALID_FLAG = 0x00;\n  static constexpr uint8_t SYNC_STATUS_GPS_SUCCESS_FLAG = 0x01;\n  static constexpr uint8_t SYNC_STATUS_PTP_SUCCESS_FLAG = 0x02;\n\npublic:\n  static constexpr float MIN_RANGE = 0.1f;\n  static constexpr float MAX_RANGE = 30.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 1152000;\n\n  int getPacketRelativePointTimeOffset(\n    const uint32_t block_id, const uint32_t channel_id,\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration) override\n  {\n    if (sensor_configuration-&gt;return_mode == ReturnMode::DUAL)\n      return firing_time_offset_ns_dual_[block_id][channel_id];\n    else\n      return firing_time_offset_ns_single_[block_id][channel_id];\n  }\n\n  ReturnMode getReturnMode(const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        return ReturnMode::DUAL;\n      case STRONGEST_RETURN_FLAG:\n        return ReturnMode::SINGLE_STRONGEST;\n      case LAST_RETURN_FLAG:\n        return ReturnMode::SINGLE_LAST;\n      case FIRST_RETURN_FLAG:\n        return ReturnMode::SINGLE_FIRST;\n      default:\n        return ReturnMode::UNKNOWN;\n    }\n  }\n\n  RobosenseCalibrationConfiguration getSensorCalibration(\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)\n  {\n    return info_packet.sensor_calibration.getCalibration();\n  }\n\n  bool getSyncStatus(const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.time_sync_state.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        return false;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        return true;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  std::map&lt;std::string, std::string&gt; getSensorInfo(\n    const robosense_packet::bpearl_v4::InfoPacket &amp; info_packet)\n  {\n    std::map&lt;std::string, std::string&gt; sensor_info;\n    sensor_info[\"motor_speed\"] = std::to_string(info_packet.motor_speed_setting.value());\n    sensor_info[\"lidar_ip\"] = info_packet.ethernet.lidar_ip.to_string();\n    sensor_info[\"dest_pc_ip\"] = info_packet.ethernet.dest_pc_ip.to_string();\n    sensor_info[\"mac_addr\"] = info_packet.ethernet.mac_addr.to_string();\n    sensor_info[\"lidar_out_msop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_msop_port.value());\n    sensor_info[\"lidar_out_difop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_difop_port.value());\n    sensor_info[\"fov_start\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_start.value());\n    sensor_info[\"fov_end\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_end.value());\n    sensor_info[\"tcp_msop_port\"] = std::to_string(info_packet.tcp_msop_port.value());\n    sensor_info[\"phase_lock\"] = std::to_string(info_packet.phase_lock.value());\n    sensor_info[\"mainboard_firmware_version\"] = info_packet.mainboard_firmware_version.to_string();\n    sensor_info[\"bottom_firmware_version\"] = info_packet.bottom_firmware_version.to_string();\n    sensor_info[\"app_software_version\"] = info_packet.app_software_version.to_string();\n    sensor_info[\"motor_firmware_version\"] = info_packet.motor_firmware_version.to_string();\n    sensor_info[\"baud_rate\"] = std::to_string(info_packet.baud_rate.value());\n    sensor_info[\"serial_number\"] = info_packet.serial_number.to_string();\n\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"dual\";\n        break;\n      case STRONGEST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"strongest\";\n        break;\n      case LAST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"last\";\n        break;\n      case FIRST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"first\";\n        break;\n      default:\n        sensor_info[\"return_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.time_sync_mode.value()) {\n      case SYNC_MODE_GPS_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gps\";\n        break;\n      case SYNC_MODE_E2E_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"e2e\";\n        break;\n      case SYNC_MODE_P2P_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"p2p\";\n        break;\n      case SYNC_MODE_GPTP_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gptp\";\n        break;\n      default:\n        sensor_info[\"time_sync_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.time_sync_state.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        sensor_info[\"time_sync_state\"] = \"time_sync_invalid\";\n        break;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        sensor_info[\"time_sync_state\"] = \"gps_time_sync_successful\";\n        break;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        sensor_info[\"time_sync_state\"] = \"ptp_time_sync_successful\";\n        break;\n      default:\n        sensor_info[\"time_sync_state\"] = \"n/a\";\n    }\n\n    sensor_info[\"time\"] = std::to_string(info_packet.time.get_time_in_ns());\n    sensor_info[\"machine_current\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.machine_current.value());\n    sensor_info[\"machine_voltage\"] =\n      robosense_packet::get_float_value(info_packet.operating_status.machine_voltage.value());\n    sensor_info[\"rotation_direction\"] = std::to_string(info_packet.rotation_direction.value());\n    sensor_info[\"running_time\"] = std::to_string(info_packet.running_time.value());\n    sensor_info[\"startup_times\"] =\n      std::to_string(info_packet.fault_diagnosis.startup_times.value());\n\n    const std::bitset&lt;8&gt; gps_st_bits{info_packet.fault_diagnosis.gps_status.value()};\n    if (gps_st_bits[0])\n      sensor_info[\"pps_lock\"] = \"valid\";\n    else\n      sensor_info[\"pps_lock\"] = \"invalid\";\n    if (gps_st_bits[1])\n      sensor_info[\"gprmc_lock\"] = \"valid\";\n    else\n      sensor_info[\"gprmc_lock\"] = \"invalid\";\n    if (gps_st_bits[2])\n      sensor_info[\"utc_lock\"] = \"synchronized\";\n    else\n      sensor_info[\"utc_lock\"] = \"not_synchronized\";\n    if (gps_st_bits[3])\n      sensor_info[\"gprmc_input_status\"] = \"received_gprmc\";\n    else\n      sensor_info[\"gprmc_input_status\"] = \"no_gprmc\";\n    if (gps_st_bits[4])\n      sensor_info[\"pps_input_status\"] = \"received_pps\";\n    else\n      sensor_info[\"pps_input_status\"] = \"no_pps\";\n\n    sensor_info[\"machine_temp\"] =\n      robosense_packet::get_float_value(info_packet.fault_diagnosis.machine_temp.value());\n    sensor_info[\"phase\"] = std::to_string(info_packet.fault_diagnosis.phase.value());\n    sensor_info[\"rotation_speed\"] =\n      std::to_string(info_packet.fault_diagnosis.rotation_speed.value());\n\n    std::string gprmc_string;\n    for (auto i : info_packet.gprmc) {\n      gprmc_string += static_cast&lt;char&gt;(i.value());\n    }\n    sensor_info[\"gprmc_string\"] = gprmc_string;\n\n    return sensor_info;\n  }\n};\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/helios_8hpp/","title":"File helios.hpp","text":"<p>FileList &gt; decoders &gt; helios.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"</code></li> <li><code>#include \"boost/endian/buffers.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"nebula_decoders/helios_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace robosense_packet namespace helios"},{"location":"nebula_decoders/helios_8hpp/#classes","title":"Classes","text":"Type Name class Helios struct FaultDiagnosis struct Header struct InfoPacket struct OperatingStatus struct Packet struct SensorHwVersion struct WebPageVersion <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp</code></p>"},{"location":"nebula_decoders/helios_8hpp_source/","title":"File helios.hpp","text":"<p>File List &gt; decoders &gt; helios.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp\"\n\n#include \"boost/endian/buffers.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n\nusing namespace boost::endian;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace robosense_packet\n{\nnamespace helios\n{\n#pragma pack(push, 1)\n\nstruct Header\n{\n  big_uint32_buf_t header_id;\n  big_uint16_buf_t protocol_version;\n  big_uint16_buf_t reserved_first;\n  big_uint32_buf_t top_packet_count;\n  big_uint32_buf_t bottom_packet_count;\n  big_uint8_buf_t reserved_second;\n  big_uint8_buf_t range_resolution;\n  big_uint16_buf_t angle_interval_count;\n  Timestamp timestamp;\n  big_uint8_buf_t reserved_third;\n  big_uint8_buf_t lidar_type;\n  big_uint8_buf_t lidar_model;\n  big_uint8_buf_t reserved_fourth[9];\n};\n\nstruct Packet : public PacketBase&lt;12, 32, 2, 100&gt;\n{\n  typedef Body&lt;Block&lt;Unit, Packet::N_CHANNELS&gt;, Packet::N_BLOCKS&gt; body_t;\n  Header header;\n  body_t body;\n  big_uint48_buf_t tail;\n};\n\nstruct OperatingStatus\n{\n  big_uint16_buf_t i_dat;\n  big_uint16_buf_t v_dat;\n  big_uint16_buf_t v_dat_12v;\n  big_uint16_buf_t v_dat_5v;\n  big_uint16_buf_t v_dat_2v5;\n  big_uint16_buf_t v_dat_apd;\n};\n\nstruct FaultDiagnosis\n{\n  big_uint16_buf_t temperature1;\n  big_uint16_buf_t temperature2;\n  big_uint16_buf_t temperature3;\n  big_uint16_buf_t temperature4;\n  big_uint16_buf_t temperature5;\n  big_uint16_buf_t r_rpm;\n  big_uint8_buf_t lane_up;\n  big_uint16_buf_t lane_up_cnt;\n  big_uint16_buf_t top_status;\n  big_uint8_buf_t gps_status;\n};\n\nstruct SensorHwVersion\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    std::stringstream ss;\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(first_octet.value())\n       &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(second_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(third_octet.value());\n    return ss.str();\n  }\n};\n\nstruct WebPageVersion\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n  big_uint8_buf_t fourth_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    std::stringstream ss;\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(first_octet.value())\n       &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(second_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(third_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fourth_octet.value());\n    return ss.str();\n  }\n};\n\nstruct InfoPacket\n{\n  big_uint64_buf_t header;\n  big_uint16_buf_t motor_speed;\n  Ethernet ethernet;\n  FovSetting fov_setting;\n  big_uint16_buf_t reserved_first;\n  big_uint16_buf_t phase_lock;\n  FirmwareVersion top_firmware_version;\n  FirmwareVersion bottom_firmware_version;\n  FirmwareVersion bottom_software_version;\n  FirmwareVersion motor_firmware_version;\n  SensorHwVersion sensor_hw_version;\n  WebPageVersion web_page_version;\n  big_uint32_buf_t top_backup_crc;\n  big_uint32_buf_t bottom_backup_crc;\n  big_uint32_buf_t software_backup_crc;\n  big_uint32_buf_t webpage_backup_crc;\n  IpAddress ethernet_gateway;\n  IpAddress subnet_mask;\n  uint8_t reserved_second[201];\n  SerialNumber serial_number;\n  big_uint16_buf_t zero_angle_offset;\n  big_uint8_buf_t return_mode;\n  big_uint8_buf_t time_sync_mode;\n  big_uint8_buf_t sync_status;\n  Timestamp time;\n  OperatingStatus operating_status;\n  uint8_t reserved_third[17];\n  FaultDiagnosis fault_diagnosis;\n  big_uint8_buf_t code_wheel_status;\n  big_uint8_buf_t pps_trigger_mode;\n  uint8_t reserved_fourth[20];\n  big_uint8_buf_t gprmc[86];\n  SensorCalibration sensor_calibration;\n  uint8_t reserved_fifth[586];\n  big_uint16_buf_t tail;\n};\n\n#pragma pack(pop)\n}  // namespace helios\n}  // namespace robosense_packet\n\nclass Helios\n: public RobosenseSensor&lt;robosense_packet::helios::Packet, robosense_packet::helios::InfoPacket&gt;\n{\nprivate:\n  static constexpr int firing_time_offset_ns_single_[12][32] = {\n    {0,     1570,  3150,  4720,  6300,  7870,  9450,  11360, 13260, 15170, 17080,\n     18990, 20560, 22140, 23710, 25290, 26530, 29010, 27770, 30250, 31490, 32730,\n     33980, 35220, 36460, 37700, 38940, 40180, 41420, 42670, 43910, 45150},\n    {55560, 57130, 58700, 60280, 61850, 63430, 65000, 66910, 68820, 70730, 72640,\n     74540, 76120, 77690, 79270, 80840, 82080, 84570, 83320, 85810, 87050, 89530,\n     88290, 90770, 92010, 93260, 94500, 95740, 96980, 98220, 99460, 100700},\n    {111110, 112690, 114260, 115840, 117410, 118980, 120560, 122470, 124380, 126280, 128190,\n     130100, 131670, 133250, 134820, 136400, 137640, 140120, 138880, 141360, 142600, 145090,\n     143850, 146330, 147570, 148810, 150050, 151290, 152540, 153780, 155020, 156260},\n    {166670, 168240, 169820, 171390, 172970, 174540, 176110, 178020, 179930, 181840, 183750,\n     185650, 187230, 188800, 190380, 191950, 193190, 195680, 194440, 196920, 198160, 200640,\n     199400, 201880, 203130, 204370, 205610, 206850, 208090, 209330, 210570, 211810},\n    {222220, 223800, 225370, 226950, 228520, 230100, 231670, 233580, 235490, 237390, 239300,\n     241210, 242780, 244360, 245930, 247510, 248750, 251230, 249990, 252470, 253720, 256200,\n     254960, 257440, 258680, 259920, 261160, 262400, 263650, 264890, 266130, 267370},\n    {277780, 279350, 280930, 282500, 284080, 285650, 287230, 289130, 291040, 292950, 294860,\n     296770, 298340, 299920, 301490, 303060, 304310, 306790, 305550, 308030, 309270, 311750,\n     310510, 313000, 314240, 315480, 316720, 317960, 319200, 320440, 321680, 322930},\n    {333330, 334910, 336480, 338060, 339630, 341210, 342780, 344690, 346600, 348510, 350410,\n     352320, 353900, 355470, 357050, 358620, 359860, 362340, 361100, 363590, 364830, 367310,\n     366070, 368550, 369790, 371030, 372270, 373520, 374760, 376000, 377240, 378480},\n    {388890, 390460, 392040, 393610, 395190, 396760, 398340, 400240, 402150, 404060, 405970,\n     407880, 409450, 411030, 412600, 414180, 415420, 417900, 416660, 419140, 420380, 422860,\n     421620, 424110, 425350, 426590, 427830, 429070, 430310, 431550, 432800, 434040},\n    {444440, 446020, 447590, 449170, 450740, 452320, 453890, 455800, 457710, 459620, 461520,\n     463430, 465010, 466580, 468160, 469730, 470970, 473460, 472210, 474700, 475940, 478420,\n     477180, 479660, 480900, 482140, 483390, 484630, 485870, 487110, 488350, 489590},\n    {500000, 501570, 503150, 504720, 506300, 507870, 509450, 511360, 513260, 515170, 517080,\n     518990, 520560, 522140, 523710, 525290, 526530, 529010, 527770, 530250, 531490, 533980,\n     532730, 535220, 536460, 537700, 538940, 540180, 541420, 542670, 543910, 545150},\n    {555560, 557130, 558700, 560280, 561850, 563430, 565000, 566910, 568820, 570730, 572640,\n     574540, 576120, 577690, 579270, 580840, 582080, 584570, 583320, 585810, 587050, 589530,\n     588290, 590770, 592010, 593260, 594500, 595740, 596980, 598220, 599460, 600700},\n    {611110, 612690, 614260, 615840, 617410, 618980, 620560, 622470, 624380, 626280, 628190,\n     630100, 631670, 633250, 634820, 636400, 637640, 640120, 638880, 641360, 642600, 645090,\n     643850, 646330, 647570, 648810, 650050, 651290, 652540, 653780, 655020, 656260}};\n\n  static constexpr int firing_time_offset_ns_dual_[12][32]{\n    {0,     1570,  3150,  4720,  6300,  7870,  9450,  11360, 13260, 15170, 17080,\n     18990, 20560, 22140, 23710, 25290, 26530, 27770, 29010, 30250, 31490, 32730,\n     33980, 35220, 36460, 37700, 38940, 40180, 41420, 42670, 43910, 45150},\n    {0,     1570,  3150,  4720,  6300,  7870,  9450,  11360, 13260, 15170, 17080,\n     18990, 20560, 22140, 23710, 25290, 26530, 27770, 29010, 30250, 31490, 32730,\n     33980, 35220, 36460, 37700, 38940, 40180, 41420, 42670, 43910, 45150},\n    {55560, 57130, 58700, 60280, 61850, 63430, 65000, 66910, 68820, 70730, 72640,\n     74540, 76120, 77690, 79270, 80840, 82080, 83320, 84570, 85810, 87050, 88290,\n     89530, 90770, 92010, 93260, 94500, 95740, 96980, 98220, 99460, 100700},\n    {55560, 57130, 58700, 60280, 61850, 63430, 65000, 66910, 68820, 70730, 72640,\n     74540, 76120, 77690, 79270, 80840, 82080, 83320, 84570, 85810, 87050, 88290,\n     89530, 90770, 92010, 93260, 94500, 95740, 96980, 98220, 99460, 100700},\n    {111110, 112690, 114260, 115840, 117410, 118980, 120560, 122470, 124380, 126280, 128190,\n     130100, 131670, 133250, 134820, 136400, 137640, 138880, 140120, 141360, 142600, 143850,\n     145090, 146330, 147570, 148810, 150050, 151290, 152540, 153780, 155020, 156260},\n    {111110, 112690, 114260, 115840, 117410, 118980, 120560, 122470, 124380, 126280, 128190,\n     130100, 131670, 133250, 134820, 136400, 137640, 138880, 140120, 141360, 142600, 143850,\n     145090, 146330, 147570, 148810, 150050, 151290, 152540, 153780, 155020, 156260},\n    {166670, 168240, 169820, 171390, 172970, 174540, 176110, 178020, 179930, 181840, 183750,\n     185650, 187230, 188800, 190380, 191950, 193190, 194440, 195680, 196920, 198160, 199400,\n     200640, 201880, 203130, 204370, 205610, 206850, 208090, 209330, 210570, 211810},\n    {166670, 168240, 169820, 171390, 172970, 174540, 176110, 178020, 179930, 181840, 183750,\n     185650, 187230, 188800, 190380, 191950, 193190, 194440, 195680, 196920, 198160, 199400,\n     200640, 201880, 203130, 204370, 205610, 206850, 208090, 209330, 210570, 211810},\n    {222220, 223800, 225370, 226950, 228520, 230100, 231670, 233580, 235490, 237390, 239300,\n     241210, 242780, 244360, 245930, 247510, 248750, 249990, 251230, 252470, 253720, 254960,\n     256200, 257440, 258680, 259920, 261160, 262400, 263650, 264890, 266130, 267370},\n    {222220, 223800, 225370, 226950, 228520, 230100, 231670, 233580, 235490, 237390, 239300,\n     241210, 242780, 244360, 245930, 247510, 248750, 249990, 251230, 252470, 253720, 254960,\n     256200, 257440, 258680, 259920, 261160, 262400, 263650, 264890, 266130, 267370},\n    {277780, 279350, 280930, 282500, 284080, 285650, 287230, 289130, 291040, 292950, 294860,\n     296770, 298340, 299920, 301490, 303060, 304310, 305550, 306790, 308030, 309270, 310510,\n     311750, 313000, 314240, 315480, 316720, 317960, 319200, 320440, 321680, 322930},\n    {277780, 279350, 280930, 282500, 284080, 285650, 287230, 289130, 291040, 292950, 294860,\n     296770, 298340, 299920, 301490, 303060, 304310, 305550, 306790, 308030, 309270, 310510,\n     311750, 313000, 314240, 315480, 316720, 317960, 319200, 320440, 321680, 322930}};\n\n  static constexpr uint8_t DUAL_RETURN_FLAG = 0x00;\n  static constexpr uint8_t STRONGEST_RETURN_FLAG = 0x04;\n  static constexpr uint8_t LAST_RETURN_FLAG = 0x05;\n  static constexpr uint8_t FIRST_RETURN_FLAG = 0x06;\n\n  static constexpr uint8_t SYNC_MODE_GPS_FLAG = 0x00;\n  static constexpr uint8_t SYNC_MODE_E2E_FLAG = 0x01;\n  static constexpr uint8_t SYNC_MODE_P2P_FLAG = 0x02;\n  static constexpr uint8_t SYNC_MODE_GPTP_FLAG = 0x03;\n\n  static constexpr uint8_t SYNC_STATUS_INVALID_FLAG = 0x00;\n  static constexpr uint8_t SYNC_STATUS_GPS_SUCCESS_FLAG = 0x01;\n  static constexpr uint8_t SYNC_STATUS_PTP_SUCCESS_FLAG = 0x02;\n\npublic:\n  static constexpr float MIN_RANGE = 0.2f;\n  static constexpr float MAX_RANGE = 150.f;\n  static constexpr size_t MAX_SCAN_BUFFER_POINTS = 1152000;\n\n  int getPacketRelativePointTimeOffset(\n    const uint32_t block_id, const uint32_t channel_id,\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration) override\n  {\n    if (sensor_configuration-&gt;return_mode == ReturnMode::DUAL)\n      return firing_time_offset_ns_dual_[block_id][channel_id];\n    else\n      return firing_time_offset_ns_single_[block_id][channel_id];\n  }\n\n  ReturnMode getReturnMode(const robosense_packet::helios::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        return ReturnMode::DUAL;\n      case STRONGEST_RETURN_FLAG:\n        return ReturnMode::SINGLE_STRONGEST;\n      case LAST_RETURN_FLAG:\n        return ReturnMode::SINGLE_LAST;\n      case FIRST_RETURN_FLAG:\n        return ReturnMode::SINGLE_FIRST;\n      default:\n        return ReturnMode::UNKNOWN;\n    }\n  }\n\n  RobosenseCalibrationConfiguration getSensorCalibration(\n    const robosense_packet::helios::InfoPacket &amp; info_packet)\n  {\n    return info_packet.sensor_calibration.getCalibration();\n  }\n\n  bool getSyncStatus(const robosense_packet::helios::InfoPacket &amp; info_packet)\n  {\n    switch (info_packet.sync_status.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        return false;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        return true;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  std::map&lt;std::string, std::string&gt; getSensorInfo(\n    const robosense_packet::helios::InfoPacket &amp; info_packet)\n  {\n    std::map&lt;std::string, std::string&gt; sensor_info;\n    sensor_info[\"motor_speed\"] = std::to_string(info_packet.motor_speed.value());\n    sensor_info[\"lidar_ip\"] = info_packet.ethernet.lidar_ip.to_string();\n    sensor_info[\"dest_pc_ip\"] = info_packet.ethernet.dest_pc_ip.to_string();\n    sensor_info[\"mac_addr\"] = info_packet.ethernet.mac_addr.to_string();\n    sensor_info[\"lidar_out_msop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_msop_port.value());\n    sensor_info[\"pc_dest_msop_port\"] =\n      std::to_string(info_packet.ethernet.pc_dest_msop_port.value());\n    sensor_info[\"lidar_out_difop_port\"] =\n      std::to_string(info_packet.ethernet.lidar_out_difop_port.value());\n    sensor_info[\"pc_dest_difop_port\"] =\n      std::to_string(info_packet.ethernet.pc_dest_difop_port.value());\n    sensor_info[\"fov_start\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_start.value());\n    sensor_info[\"fov_end\"] =\n      robosense_packet::get_float_value(info_packet.fov_setting.fov_end.value());\n    sensor_info[\"phase_lock\"] = std::to_string(info_packet.phase_lock.value());\n    sensor_info[\"top_firmware_version\"] = info_packet.top_firmware_version.to_string();\n    sensor_info[\"bottom_firmware_version\"] = info_packet.bottom_firmware_version.to_string();\n    sensor_info[\"bottom_software_version\"] = info_packet.bottom_software_version.to_string();\n    sensor_info[\"motor_firmware_version\"] = info_packet.motor_firmware_version.to_string();\n    sensor_info[\"sensor_hw_version\"] = info_packet.sensor_hw_version.to_string();\n    sensor_info[\"web_page_version\"] = info_packet.web_page_version.to_string();\n    sensor_info[\"top_backup_crc\"] = std::to_string(info_packet.top_backup_crc.value());\n    sensor_info[\"bottom_backup_crc\"] = std::to_string(info_packet.bottom_backup_crc.value());\n    sensor_info[\"software_backup_crc\"] = std::to_string(info_packet.software_backup_crc.value());\n    sensor_info[\"webpage_backup_crc\"] = std::to_string(info_packet.webpage_backup_crc.value());\n    sensor_info[\"ethernet_gateway\"] = info_packet.ethernet_gateway.to_string();\n    sensor_info[\"subnet_mask\"] = info_packet.subnet_mask.to_string();\n    sensor_info[\"serial_number\"] = info_packet.serial_number.to_string();\n    sensor_info[\"zero_angle_offset\"] = std::to_string(info_packet.zero_angle_offset.value());\n\n    switch (info_packet.return_mode.value()) {\n      case DUAL_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"dual\";\n        break;\n      case STRONGEST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"strongest\";\n        break;\n      case LAST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"last\";\n        break;\n      case FIRST_RETURN_FLAG:\n        sensor_info[\"return_mode\"] = \"first\";\n        break;\n      default:\n        sensor_info[\"return_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.time_sync_mode.value()) {\n      case SYNC_MODE_GPS_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gps\";\n        break;\n      case SYNC_MODE_E2E_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"e2e\";\n        break;\n      case SYNC_MODE_P2P_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"p2p\";\n        break;\n      case SYNC_MODE_GPTP_FLAG:\n        sensor_info[\"time_sync_mode\"] = \"gptp\";\n        break;\n      default:\n        sensor_info[\"time_sync_mode\"] = \"n/a\";\n        break;\n    }\n\n    switch (info_packet.sync_status.value()) {\n      case SYNC_STATUS_INVALID_FLAG:\n        sensor_info[\"sync_status\"] = \"time_sync_invalid\";\n        break;\n      case SYNC_STATUS_GPS_SUCCESS_FLAG:\n        sensor_info[\"sync_status\"] = \"gps_time_sync_successful\";\n        break;\n      case SYNC_STATUS_PTP_SUCCESS_FLAG:\n        sensor_info[\"sync_status\"] = \"ptp_time_sync_successful\";\n        break;\n      default:\n        sensor_info[\"sync_status\"] = \"n/a\";\n    }\n\n    /*\n     * From the manual, here are the formulas for calculating following values:\n     *\n     * Idat = Value_temp / 4096 * 5 [A]\n     * Vdat = value / 4096 [V]\n     * Vdat_12V_reg = value / 4096 * 24.5 [V]\n     * Vdat_5V_reg = value / 4096 x 11 [V]\n     * Vdat_2V5_reg = value / 4096 x 10 [V]\n     * Vdat_APD = 516.65 * (value) / 4096 - 465.8 [V](negative value)\n     * Temperature 2&amp;3&amp;4 = 200 *\uff08value\uff09/ 4096 - 50\n     * Temperature 1&amp;5 = 503.975 * (value) / 4096 - 273.15\n     */\n    sensor_info[\"time\"] = std::to_string(info_packet.time.get_time_in_ns());\n    sensor_info[\"i_dat\"] = std::to_string(info_packet.operating_status.i_dat.value() / 4096.0 * 5);\n    sensor_info[\"v_dat\"] = std::to_string(info_packet.operating_status.v_dat.value() / 4096.0);\n    sensor_info[\"v_dat_12v\"] =\n      std::to_string(info_packet.operating_status.v_dat_12v.value() / 4096.0 * 24.5);\n    sensor_info[\"v_dat_5v\"] =\n      std::to_string(info_packet.operating_status.v_dat_5v.value() / 4096.0 * 11);\n    sensor_info[\"v_dat_2v5\"] =\n      std::to_string(info_packet.operating_status.v_dat_2v5.value() / 4096.0 * 10);\n    sensor_info[\"v_dat_apd\"] =\n      std::to_string(info_packet.operating_status.v_dat_apd.value() * 516.65 / 4096 - 465.8);\n    sensor_info[\"top_board_temp\"] =\n      std::to_string(info_packet.fault_diagnosis.temperature1.value() * 503.975 / 4096.0 - 273.15);\n    sensor_info[\"temperature2\"] =\n      std::to_string(info_packet.fault_diagnosis.temperature2.value() * 200 / 4096.0 - 50);\n    sensor_info[\"temperature3\"] =\n      std::to_string(info_packet.fault_diagnosis.temperature3.value() * 200 / 4096.0 - 50);\n    sensor_info[\"temperature4\"] =\n      std::to_string(info_packet.fault_diagnosis.temperature4.value() * 200 / 4096.0 - 50);\n    sensor_info[\"bottom_board_temp\"] =\n      std::to_string(info_packet.fault_diagnosis.temperature5.value() * 503.975 / 4096.0 - 273.15);\n    sensor_info[\"real_time_rot_speed\"] = std::to_string(info_packet.fault_diagnosis.r_rpm.value());\n    sensor_info[\"lane_up\"] = std::to_string(info_packet.fault_diagnosis.lane_up.value());\n    sensor_info[\"lane_up_cnt\"] = std::to_string(info_packet.fault_diagnosis.lane_up_cnt.value());\n    sensor_info[\"top_status\"] = std::to_string(info_packet.fault_diagnosis.top_status.value());\n\n    const std::bitset&lt;8&gt; gps_st_bits{info_packet.fault_diagnosis.gps_status.value()};\n    if (gps_st_bits[0])\n      sensor_info[\"pps_lock\"] = \"valid\";\n    else\n      sensor_info[\"pps_lock\"] = \"invalid\";\n    if (gps_st_bits[1])\n      sensor_info[\"gprmc_lock\"] = \"valid\";\n    else\n      sensor_info[\"gprmc_lock\"] = \"invalid\";\n    if (gps_st_bits[2])\n      sensor_info[\"utc_lock\"] = \"synchronized\";\n    else\n      sensor_info[\"utc_lock\"] = \"not_synchronized\";\n    if (gps_st_bits[3])\n      sensor_info[\"gprmc_input_status\"] = \"received_gprmc\";\n    else\n      sensor_info[\"gprmc_input_status\"] = \"no_gprmc\";\n    if (gps_st_bits[4])\n      sensor_info[\"pps_input_status\"] = \"received_pps\";\n    else\n      sensor_info[\"pps_input_status\"] = \"no_pps\";\n\n    sensor_info[\"code_wheel_status\"] = std::to_string(info_packet.code_wheel_status.value());\n    sensor_info[\"pps_trigger_mode\"] = std::to_string(info_packet.pps_trigger_mode.value());\n\n    std::string gprmc_string;\n    for (auto i : info_packet.gprmc) {\n      gprmc_string += static_cast&lt;char&gt;(i.value());\n    }\n    sensor_info[\"gprmc_string\"] = gprmc_string;\n\n    return sensor_info;\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__decoder_8hpp/","title":"File robosense_decoder.hpp","text":"<p>FileList &gt; decoders &gt; robosense_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_scan_decoder.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> </ul>"},{"location":"nebula_decoders/robosense__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__decoder_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseDecoder &lt;typename SensorT&gt; <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp</code></p>"},{"location":"nebula_decoders/robosense__decoder_8hpp_source/","title":"File robosense_decoder.hpp","text":"<p>File List &gt; decoders &gt; robosense_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_scan_decoder.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\ntemplate &lt;typename SensorT&gt;\nclass RobosenseDecoder : public RobosenseScanDecoder\n{\nprotected:\n  const std::shared_ptr&lt;drivers::RobosenseSensorConfiguration&gt; sensor_configuration_;\n\n  SensorT sensor_{};\n\n  typename SensorT::angle_corrector_t angle_corrector_;\n\n  NebulaPointCloudPtr decode_pc_;\n  NebulaPointCloudPtr output_pc_;\n\n  typename SensorT::packet_t packet_;\n  int last_phase_;\n  uint64_t output_scan_timestamp_ns_;\n  uint64_t decode_scan_timestamp_ns_;\n  bool has_scanned_;\n\n  rclcpp::Logger logger_;\n\n  bool parsePacket(const robosense_msgs::msg::RobosensePacket &amp; msop_packet)\n  {\n    if (msop_packet.data.size() &lt; sizeof(typename SensorT::packet_t)) {\n      RCLCPP_ERROR_STREAM(\n        logger_, \"Packet size mismatch:\" &lt;&lt; msop_packet.data.size() &lt;&lt; \" | Expected at least:\"\n                                         &lt;&lt; sizeof(typename SensorT::packet_t));\n      return false;\n    }\n    if (std::memcpy(&amp;packet_, msop_packet.data.data(), sizeof(typename SensorT::packet_t))) {\n      return true;\n    }\n\n    RCLCPP_ERROR(logger_, \"Packet memcopy failed\");\n    return false;\n  }\n\n  void convertReturns(size_t start_block_id, size_t n_blocks)\n  {\n    uint64_t packet_timestamp_ns = robosense_packet::get_timestamp_ns(packet_);\n    uint32_t raw_azimuth = packet_.body.blocks[start_block_id].get_azimuth();\n\n    std::vector&lt;const typename SensorT::packet_t::body_t::block_t::unit_t *&gt; return_units;\n\n    for (size_t channel_id = 0; channel_id &lt; SensorT::packet_t::N_CHANNELS; ++channel_id) {\n      // Find the units corresponding to the same return group as the current one.\n      // These are used to find duplicates in multi-return mode.\n      return_units.clear();\n      for (size_t block_offset = 0; block_offset &lt; n_blocks; ++block_offset) {\n        return_units.push_back(\n          &amp;packet_.body.blocks[block_offset + start_block_id].units[channel_id]);\n      }\n\n      for (size_t block_offset = 0; block_offset &lt; n_blocks; ++block_offset) {\n        auto &amp; unit = *return_units[block_offset];\n\n        if (unit.distance.value() == 0) {\n          continue;\n        }\n\n        auto distance = getDistance(unit);\n\n        if (distance &lt; SensorT::MIN_RANGE || distance &gt; SensorT::MAX_RANGE) {\n          continue;\n        }\n\n        auto return_type =\n          sensor_.getReturnType(sensor_configuration_-&gt;return_mode, block_offset, return_units);\n\n        // Keep only last of multiple identical points\n        if (return_type == ReturnType::IDENTICAL &amp;&amp; block_offset != n_blocks - 1) {\n          continue;\n        }\n\n        // Keep only last (if any) of multiple points that are too close\n        if (block_offset != n_blocks - 1) {\n          bool is_below_multi_return_threshold = false;\n\n          for (size_t return_idx = 0; return_idx &lt; n_blocks; ++return_idx) {\n            if (return_idx == block_offset) {\n              continue;\n            }\n\n            if (\n              fabsf(getDistance(*return_units[return_idx]) - distance) &lt;\n              sensor_configuration_-&gt;dual_return_distance_threshold) {\n              is_below_multi_return_threshold = true;\n              break;\n            }\n          }\n\n          if (is_below_multi_return_threshold) {\n            continue;\n          }\n        }\n\n        NebulaPoint point;\n        point.distance = distance;\n        point.intensity = unit.reflectivity.value();\n        point.time_stamp =\n          getPointTimeRelative(packet_timestamp_ns, block_offset + start_block_id, channel_id);\n\n        point.return_type = static_cast&lt;uint8_t&gt;(return_type);\n\n        auto corrected_angle_data = angle_corrector_.getCorrectedAngleData(raw_azimuth, channel_id);\n        point.channel = corrected_angle_data.corrected_channel_id;\n\n        // The raw_azimuth and channel are only used as indices, sin/cos functions use the precise\n        // corrected angles\n        float xyDistance = distance * corrected_angle_data.cos_elevation;\n        point.x = xyDistance * corrected_angle_data.cos_azimuth;\n        point.y = -xyDistance * corrected_angle_data.sin_azimuth;\n        point.z = distance * corrected_angle_data.sin_elevation;\n\n        // The driver wrapper converts to degrees, expects radians\n        point.azimuth = corrected_angle_data.azimuth_rad;\n        point.elevation = corrected_angle_data.elevation_rad;\n\n        decode_pc_-&gt;emplace_back(point);\n      }\n    }\n  }\n\n  bool checkScanCompleted(int current_phase)\n  {\n    return angle_corrector_.hasScanned(current_phase, last_phase_);\n  }\n\n  float getDistance(const typename SensorT::packet_t::body_t::block_t::unit_t &amp; unit)\n  {\n    return unit.distance.value() * robosense_packet::get_dis_unit(packet_);\n  }\n\n  uint32_t getPointTimeRelative(uint64_t packet_timestamp_ns, size_t block_id, size_t channel_id)\n  {\n    auto point_to_packet_offset_ns =\n      sensor_.getPacketRelativePointTimeOffset(block_id, channel_id, sensor_configuration_);\n    auto packet_to_scan_offset_ns =\n      static_cast&lt;uint32_t&gt;(packet_timestamp_ns - decode_scan_timestamp_ns_);\n    return packet_to_scan_offset_ns + point_to_packet_offset_ns;\n  }\n\npublic:\n  explicit RobosenseDecoder(\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;RobosenseCalibrationConfiguration&gt; &amp; calibration_configuration)\n  : sensor_configuration_(sensor_configuration),\n    angle_corrector_(calibration_configuration),\n    logger_(rclcpp::get_logger(\"RobosenseDecoder\"))\n  {\n    logger_.set_level(rclcpp::Logger::Level::Debug);\n    RCLCPP_INFO_STREAM(logger_, sensor_configuration_);\n\n    decode_pc_.reset(new NebulaPointCloud);\n    output_pc_.reset(new NebulaPointCloud);\n\n    decode_pc_-&gt;reserve(SensorT::MAX_SCAN_BUFFER_POINTS);\n    output_pc_-&gt;reserve(SensorT::MAX_SCAN_BUFFER_POINTS);\n  }\n\n  int unpack(const robosense_msgs::msg::RobosensePacket &amp; msop_packet) override\n  {\n    if (!parsePacket(msop_packet)) {\n      return -1;\n    }\n\n    if (decode_scan_timestamp_ns_ == 0) {\n      decode_scan_timestamp_ns_ = robosense_packet::get_timestamp_ns(packet_);\n    }\n\n    if (has_scanned_) {\n      has_scanned_ = false;\n    }\n\n    // For the dual return mode, the packet contains two blocks with the same azimuth, one for each\n    // return. For the single return mode, the packet contains only one block per azimuth.\n    // So, if the return mode is dual, we process two blocks per iteration, otherwise one.\n    const size_t n_returns = robosense_packet::get_n_returns(sensor_configuration_-&gt;return_mode);\n    int current_azimuth;\n\n    for (size_t block_id = 0; block_id &lt; SensorT::packet_t::N_BLOCKS; block_id += n_returns) {\n      current_azimuth =\n        (360 * SensorT::packet_t::DEGREE_SUBDIVISIONS +\n         packet_.body.blocks[block_id].get_azimuth() -\n         static_cast&lt;int&gt;(\n           sensor_configuration_-&gt;scan_phase * SensorT::packet_t::DEGREE_SUBDIVISIONS)) %\n        (360 * SensorT::packet_t::DEGREE_SUBDIVISIONS);\n\n      bool scan_completed = checkScanCompleted(current_azimuth);\n      if (scan_completed) {\n        std::swap(decode_pc_, output_pc_);\n        decode_pc_-&gt;clear();\n        has_scanned_ = true;\n        output_scan_timestamp_ns_ = decode_scan_timestamp_ns_;\n\n        // A new scan starts within the current packet, so the new scan's timestamp must be\n        // calculated as the packet timestamp plus the lowest time offset of any point in the\n        // remainder of the packet\n        decode_scan_timestamp_ns_ =\n          robosense_packet::get_timestamp_ns(packet_) +\n          sensor_.getEarliestPointTimeOffsetForBlock(block_id, sensor_configuration_);\n      }\n\n      convertReturns(block_id, n_returns);\n      last_phase_ = current_azimuth;\n    }\n\n    return last_phase_;\n  }\n\n  bool hasScanned() override { return has_scanned_; }\n\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; getPointcloud() override\n  {\n    double scan_timestamp_s = static_cast&lt;double&gt;(output_scan_timestamp_ns_) * 1e-9;\n    return std::make_pair(output_pc_, scan_timestamp_s);\n  }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__info__decoder_8hpp/","title":"File robosense_info_decoder.hpp","text":"<p>FileList &gt; decoders &gt; robosense_info_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__info__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__info__decoder_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseInfoDecoder &lt;typename SensorT&gt; <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder.hpp</code></p>"},{"location":"nebula_decoders/robosense__info__decoder_8hpp_source/","title":"File robosense_info_decoder.hpp","text":"<p>File List &gt; decoders &gt; robosense_info_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;typename SensorT&gt;\nclass RobosenseInfoDecoder : public RobosenseInfoDecoderBase\n{\nprotected:\n  SensorT sensor_{};\n\n  typename SensorT::info_t packet_{};\n\n  rclcpp::Logger logger_;\n\npublic:\n  bool parsePacket(const std::vector&lt;uint8_t&gt; &amp; raw_packet) override\n  {\n    const auto packet_size = raw_packet.size();\n    if (packet_size &lt; sizeof(typename SensorT::info_t)) {\n      RCLCPP_ERROR_STREAM(\n        logger_, \"Packet size mismatch:\" &lt;&lt; packet_size &lt;&lt; \" | Expected at least:\"\n                                         &lt;&lt; sizeof(typename SensorT::info_t));\n      return false;\n    }\n    try {\n      if (std::memcpy(&amp;packet_, raw_packet.data(), sizeof(typename SensorT::info_t)) == &amp;packet_) {\n        return true;\n      }\n    } catch (const std::exception &amp; e) {\n      RCLCPP_ERROR_STREAM(logger_, \"Packet memcopy failed: \" &lt;&lt; e.what());\n    }\n\n    return false;\n  }\n\n  RobosenseInfoDecoder() : logger_(rclcpp::get_logger(\"RobosenseInfoDecoder\"))\n  {\n    logger_.set_level(rclcpp::Logger::Level::Debug);\n  }\n\n  std::map&lt;std::string, std::string&gt; getSensorInfo() override\n  {\n    return sensor_.getSensorInfo(packet_);\n  }\n\n  ReturnMode getReturnMode() override { return sensor_.getReturnMode(packet_); }\n\n  RobosenseCalibrationConfiguration getSensorCalibration() override\n  {\n    return sensor_.getSensorCalibration(packet_);\n  }\n\n  bool getSyncStatus() override { return sensor_.getSyncStatus(packet_); }\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__info__decoder__base_8hpp/","title":"File robosense_info_decoder_base.hpp","text":"<p>FileList &gt; decoders &gt; robosense_info_decoder_base.hpp</p> <p>Go to the source code of this file</p>"},{"location":"nebula_decoders/robosense__info__decoder__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__info__decoder__base_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseInfoDecoderBase <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp</code></p>"},{"location":"nebula_decoders/robosense__info__decoder__base_8hpp_source/","title":"File robosense_info_decoder_base.hpp","text":"<p>File List &gt; decoders &gt; robosense_info_decoder_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace nebula\n{\nnamespace drivers\n{\n\nclass RobosenseInfoDecoderBase\n{\npublic:\n  RobosenseInfoDecoderBase(RobosenseInfoDecoderBase &amp;&amp; c) = delete;\n  RobosenseInfoDecoderBase &amp; operator=(RobosenseInfoDecoderBase &amp;&amp; c) = delete;\n  RobosenseInfoDecoderBase(const RobosenseInfoDecoderBase &amp; c) = delete;\n  RobosenseInfoDecoderBase &amp; operator=(const RobosenseInfoDecoderBase &amp; c) = delete;\n\n  virtual ~RobosenseInfoDecoderBase() = default;\n  RobosenseInfoDecoderBase() = default;\n\n  virtual bool parsePacket(const std::vector&lt;uint8_t&gt; &amp; raw_packet) = 0;\n\n  virtual std::map&lt;std::string, std::string&gt; getSensorInfo() = 0;\n\n  virtual ReturnMode getReturnMode() = 0;\n\n  virtual RobosenseCalibrationConfiguration getSensorCalibration() = 0;\n\n  virtual bool getSyncStatus() = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__packet_8hpp/","title":"File robosense_packet.hpp","text":"<p>FileList &gt; decoders &gt; robosense_packet.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"boost/endian/buffers.hpp\"</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__packet_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace robosense_packet"},{"location":"nebula_decoders/robosense__packet_8hpp/#classes","title":"Classes","text":"Type Name struct Block &lt;typename UnitT, UnitN&gt; struct Body &lt;typename BlockT, BlockN&gt; struct ChannelAngleCorrection struct CorrectedHorizontalAngle struct CorrectedVerticalAngle struct Ethernet struct FirmwareVersion struct FovSetting struct IpAddress struct MacAddress struct PacketBase &lt;nBlocks, nChannels, maxReturns, degreeSubdivisions&gt;Base struct for all Robosense packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. struct SensorCalibration struct SerialNumber struct Timestamp struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp</code></p>"},{"location":"nebula_decoders/robosense__packet_8hpp_source/","title":"File robosense_packet.hpp","text":"<p>File List &gt; decoders &gt; robosense_packet.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"boost/endian/buffers.hpp\"\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n\nusing namespace boost::endian;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace robosense_packet\n{\n\n#pragma pack(push, 1)\n\nstruct Timestamp\n{\n  big_uint48_buf_t seconds;\n  big_uint32_buf_t microseconds;\n\n  uint64_t get_time_in_ns() const\n  {\n    constexpr uint64_t NS_IN_SECOND = 1000000000ULL;\n    constexpr uint64_t NS_IN_MICROSECOND = 1000ULL;\n\n    uint64_t total_nanoseconds = seconds.value() * NS_IN_SECOND;\n    total_nanoseconds += microseconds.value() * NS_IN_MICROSECOND;\n\n    return total_nanoseconds;\n  }\n};\n\n\nstruct Unit\n{\n  big_uint16_buf_t distance;\n  big_uint8_buf_t reflectivity;\n};\n\ntemplate &lt;typename UnitT, size_t UnitN&gt;\nstruct Block\n{\n  big_uint16_buf_t flag;\n  big_uint16_buf_t azimuth;\n  UnitT units[UnitN];\n  typedef UnitT unit_t;\n\n  [[nodiscard]] uint16_t get_azimuth() const { return azimuth.value(); }\n};\n\ntemplate &lt;typename BlockT, size_t BlockN&gt;\nstruct Body\n{\n  typedef BlockT block_t;\n  BlockT blocks[BlockN];\n};\n\ntemplate &lt;size_t nBlocks, size_t nChannels, size_t maxReturns, size_t degreeSubdivisions&gt;\nstruct PacketBase\n{\n  static constexpr size_t N_BLOCKS = nBlocks;\n  static constexpr size_t N_CHANNELS = nChannels;\n  static constexpr size_t MAX_RETURNS = maxReturns;\n  static constexpr size_t DEGREE_SUBDIVISIONS = degreeSubdivisions;\n};\n\nstruct IpAddress\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n  big_uint8_buf_t fourth_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    return std::to_string(first_octet.value()) + \".\" + std::to_string(second_octet.value()) + \".\" +\n           std::to_string(third_octet.value()) + \".\" + std::to_string(fourth_octet.value());\n  }\n};\n\nstruct MacAddress\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n  big_uint8_buf_t fourth_octet;\n  big_uint8_buf_t fifth_octet;\n  big_uint8_buf_t sixth_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    std::stringstream ss;\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(first_octet.value())\n       &lt;&lt; \":\" &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(second_octet.value()) &lt;&lt; \":\" &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(third_octet.value()) &lt;&lt; \":\" &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fourth_octet.value()) &lt;&lt; \":\" &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fifth_octet.value()) &lt;&lt; \":\" &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(sixth_octet.value());\n    return ss.str();\n  }\n};\n\nstruct Ethernet\n{\n  IpAddress lidar_ip;\n  IpAddress dest_pc_ip;\n  MacAddress mac_addr;\n  big_uint16_buf_t lidar_out_msop_port;\n  big_uint16_buf_t pc_dest_msop_port;\n  big_uint16_buf_t lidar_out_difop_port;\n  big_uint16_buf_t pc_dest_difop_port;\n};\n\nstruct FovSetting\n{\n  big_uint16_buf_t fov_start;\n  big_uint16_buf_t fov_end;\n};\n\nconstexpr uint8_t ANGLE_SIGN_FLAG = 0x00;\n\nstruct ChannelAngleCorrection\n{\n  big_uint8_buf_t sign;\n  big_uint16_buf_t angle;\n\n  [[nodiscard]] float getAngle() const\n  {\n    return sign.value() == ANGLE_SIGN_FLAG\n             ? static_cast&lt;float&gt;(angle.value()) / 100.0f\n             : static_cast&lt;float&gt;(angle.value()) / -100.0f;\n  }\n};\n\nstruct CorrectedVerticalAngle\n{\n  ChannelAngleCorrection angles[32];\n};\n\nstruct CorrectedHorizontalAngle\n{\n  ChannelAngleCorrection angles[32];\n};\n\nstruct SensorCalibration\n{\n  CorrectedVerticalAngle corrected_vertical_angle;\n  CorrectedHorizontalAngle corrected_horizontal_angle;\n\n  RobosenseCalibrationConfiguration getCalibration() const\n  {\n    RobosenseCalibrationConfiguration calibration;\n    for (size_t i = 0; i &lt; 32; ++i) {\n      ChannelCorrection channel_correction;\n      channel_correction.azimuth = corrected_horizontal_angle.angles[i].getAngle();\n      channel_correction.elevation = corrected_vertical_angle.angles[i].getAngle();\n      calibration.calibration.push_back(channel_correction);\n    }\n    return calibration;\n  }\n};\n\nstruct FirmwareVersion\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n  big_uint8_buf_t fourth_octet;\n  big_uint8_buf_t fifth_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    std::stringstream ss;\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(first_octet.value())\n       &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(second_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(third_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fourth_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fifth_octet.value());\n    return ss.str();\n  }\n};\n\nstruct SerialNumber\n{\n  big_uint8_buf_t first_octet;\n  big_uint8_buf_t second_octet;\n  big_uint8_buf_t third_octet;\n  big_uint8_buf_t fourth_octet;\n  big_uint8_buf_t fifth_octet;\n  big_uint8_buf_t sixth_octet;\n\n  [[nodiscard]] std::string to_string() const\n  {\n    std::stringstream ss;\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(first_octet.value())\n       &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(second_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(third_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fourth_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(fifth_octet.value()) &lt;&lt; std::setw(2)\n       &lt;&lt; static_cast&lt;int&gt;(sixth_octet.value());\n    return ss.str();\n  }\n};\n\n#pragma pack(pop)\n\nsize_t get_n_returns(ReturnMode return_mode)\n{\n  if (return_mode == ReturnMode::DUAL) {\n    return 2;\n  }\n  return 1;\n}\n\ntemplate &lt;typename PacketT&gt;\nuint64_t get_timestamp_ns(const PacketT &amp; packet)\n{\n  return packet.header.timestamp.get_time_in_ns();\n}\n\ntemplate &lt;typename PacketT&gt;\ndouble get_dis_unit(const PacketT &amp; packet)\n{\n  // Packets define distance unit in millimeters, convert to meters here\n  const uint8_t range_resolution = packet.header.range_resolution.value();\n  if (range_resolution == 0) {\n    return 0.0050;\n  } else if (range_resolution == 1) {\n    return 0.0025;\n  }\n  throw std::runtime_error(\"Unknown range resolution\");\n}\n\nstd::string get_float_value(const uint16_t &amp; raw_angle)\n{\n  return std::to_string(static_cast&lt;float&gt;(raw_angle) / 100.0f);\n}\n\n}  // namespace robosense_packet\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__scan__decoder_8hpp/","title":"File robosense_scan_decoder.hpp","text":"<p>FileList &gt; decoders &gt; robosense_scan_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> <li><code>#include &lt;tuple&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__scan__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__scan__decoder_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseScanDecoder Base class for Robosense LiDAR decoder. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/robosense__scan__decoder_8hpp_source/","title":"File robosense_scan_decoder.hpp","text":"<p>File List &gt; decoders &gt; robosense_scan_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\n#include &lt;tuple&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass RobosenseScanDecoder\n{\npublic:\n  RobosenseScanDecoder(RobosenseScanDecoder &amp;&amp; c) = delete;\n  RobosenseScanDecoder &amp; operator=(RobosenseScanDecoder &amp;&amp; c) = delete;\n  RobosenseScanDecoder(const RobosenseScanDecoder &amp; c) = delete;\n  RobosenseScanDecoder &amp; operator=(const RobosenseScanDecoder &amp; c) = delete;\n\n  virtual ~RobosenseScanDecoder() = default;\n  RobosenseScanDecoder() = default;\n\n  virtual int unpack(const robosense_msgs::msg::RobosensePacket &amp; msop_packet) = 0;\n\n  virtual bool hasScanned() = 0;\n\n  virtual std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; getPointcloud() = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__sensor_8hpp/","title":"File robosense_sensor.hpp","text":"<p>FileList &gt; decoders &gt; robosense_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector_calibration_based.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__sensor_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseSensor &lt;typename PacketT, typename InfoPacketT&gt;Base class for all sensor definitions. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/decoders/robosense_sensor.hpp</code></p>"},{"location":"nebula_decoders/robosense__sensor_8hpp_source/","title":"File robosense_sensor.hpp","text":"<p>File List &gt; decoders &gt; robosense_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/angle_corrector_calibration_based.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_packet.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\n\ntemplate &lt;typename PacketT, typename InfoPacketT&gt;\nclass RobosenseSensor\n{\nprivate:\npublic:\n  typedef PacketT packet_t;\n  typedef InfoPacketT info_t;\n  typedef class AngleCorrectorCalibrationBased&lt;PacketT::N_CHANNELS, PacketT::DEGREE_SUBDIVISIONS&gt;\n    angle_corrector_t;\n\n  RobosenseSensor() = default;\n  virtual ~RobosenseSensor() = default;\n\n  virtual int getPacketRelativePointTimeOffset(\n    uint32_t block_id, uint32_t channel_id,\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration) = 0;\n\n  int getEarliestPointTimeOffsetForBlock(\n    uint32_t start_block_id,\n    const std::shared_ptr&lt;RobosenseSensorConfiguration&gt; &amp; sensor_configuration)\n  {\n    const auto n_returns = robosense_packet::get_n_returns(sensor_configuration-&gt;return_mode);\n    int min_offset_ns = std::numeric_limits&lt;int&gt;::max();\n\n    for (uint32_t block_id = start_block_id; block_id &lt; start_block_id + n_returns; ++block_id) {\n      for (uint32_t channel_id = 0; channel_id &lt; PacketT::N_CHANNELS; ++channel_id) {\n        min_offset_ns = std::min(\n          min_offset_ns,\n          getPacketRelativePointTimeOffset(block_id, channel_id, sensor_configuration));\n      }\n    }\n\n    return min_offset_ns;\n  }\n\n  static bool is_duplicate(\n    uint32_t return_idx,\n    const std::vector&lt;const typename PacketT::body_t::block_t::unit_t *&gt; &amp; return_units)\n  {\n    for (unsigned int i = 0; i &lt; return_units.size(); ++i) {\n      if (i == return_idx) {\n        continue;\n      }\n\n      if (\n        return_units[return_idx]-&gt;distance.value() == return_units[i]-&gt;distance.value() &amp;&amp;\n        return_units[return_idx]-&gt;reflectivity.value() == return_units[i]-&gt;reflectivity.value()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  virtual ReturnType getReturnType(\n    ReturnMode return_mode, unsigned int return_idx,\n    const std::vector&lt;const typename PacketT::body_t::block_t::unit_t *&gt; &amp; return_units)\n  {\n    if (is_duplicate(return_idx, return_units)) {\n      return ReturnType::IDENTICAL;\n    }\n\n    switch (return_mode) {\n      case ReturnMode::SINGLE_FIRST:\n        return ReturnType::FIRST;\n      case ReturnMode::SINGLE_LAST:\n        return ReturnType::LAST;\n      case ReturnMode::SINGLE_STRONGEST:\n        return ReturnType::STRONGEST;\n      case ReturnMode::DUAL:\n        if (return_idx == 0) {\n          return ReturnType::STRONGEST;\n        } else {\n          return ReturnType::LAST;\n        }\n      default:\n        return ReturnType::UNKNOWN;\n    }\n  }\n};\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__driver_8hpp/","title":"File robosense_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_robosense &gt; robosense_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__driver_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseDriver Robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/robosense_driver.hpp</code></p>"},{"location":"nebula_decoders/robosense__driver_8hpp_source/","title":"File robosense_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_robosense &gt; robosense_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp\"\n\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass RobosenseDriver : NebulaDriverBase\n{\nprivate:\n  Status driver_status_;\n\n  std::shared_ptr&lt;RobosenseScanDecoder&gt; scan_decoder_;\n\npublic:\n  RobosenseDriver() = delete;\n\n  explicit RobosenseDriver(\n    const std::shared_ptr&lt;drivers::RobosenseSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::RobosenseCalibrationConfiguration&gt; &amp; calibration_configuration);\n\n  Status GetStatus();\n\n  Status SetCalibrationConfiguration(\n    const CalibrationConfigurationBase &amp; calibration_configuration) override;\n\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; ConvertScanToPointcloud(\n    const std::shared_ptr&lt;robosense_msgs::msg::RobosenseScan&gt; &amp; robosense_scan);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/robosense__info__driver_8hpp/","title":"File robosense_info_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_robosense &gt; robosense_info_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/robosense__info__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/robosense__info__driver_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseInfoDriver Robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp</code></p>"},{"location":"nebula_decoders/robosense__info__driver_8hpp_source/","title":"File robosense_info_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_robosense &gt; robosense_info_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v3.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/bpearl_v4.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/helios.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/decoders/robosense_info_decoder_base.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass RobosenseInfoDriver\n{\nprivate:\n  Status driver_status_;\n\n  std::shared_ptr&lt;RobosenseInfoDecoderBase&gt; info_decoder_;\n\npublic:\n  RobosenseInfoDriver() = delete;\n\n  explicit RobosenseInfoDriver(\n    const std::shared_ptr&lt;drivers::RobosenseSensorConfiguration&gt; &amp; sensor_configuration);\n\n  Status GetStatus();\n\n  Status DecodeInfoPacket(const std::vector&lt;uint8_t&gt; &amp; packet);\n\n  std::map&lt;std::string, std::string&gt; GetSensorInfo();\n\n  ReturnMode GetReturnMode();\n\n  RobosenseCalibrationConfiguration GetSensorCalibration();\n\n  bool GetSyncStatus();\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne</p>"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/#files","title":"Files","text":"Type Name file velodyne_driver.hpp"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/#directories","title":"Directories","text":"Type Name dir decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/</code></p>"},{"location":"nebula_decoders/dir_283845edb88ec58ddf1e6c9e3e9b0224/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders","text":"<p>FileList &gt; decoders</p>"},{"location":"nebula_decoders/dir_283845edb88ec58ddf1e6c9e3e9b0224/#files","title":"Files","text":"Type Name file velodyne_scan_decoder.hpp file vlp16_decoder.hpp file vlp32_decoder.hpp file vls128_decoder.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/</code></p>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/","title":"File velodyne_scan_decoder.hpp","text":"<p>FileList &gt; decoders &gt; velodyne_scan_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;boost/format.hpp&gt;</code></li> <li><code>#include &lt;pcl/point_cloud.h&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> </ul>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. struct raw_block Raw Velodyne data block. struct raw_packet Raw Velodyne packet."},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#public-types","title":"Public Types","text":"Type Name union two_bytes"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#union-two_bytes","title":"union two_bytes","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp_source/","title":"File velodyne_scan_decoder.hpp","text":"<p>File List &gt; decoders &gt; velodyne_scan_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n#define NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;boost/format.hpp&gt;\n\n#include &lt;pcl/point_cloud.h&gt;\n\n#include &lt;cerrno&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;tuple&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstatic const int SIZE_BLOCK = 100;\nstatic const int RAW_SCAN_SIZE = 3;\nstatic const int SCANS_PER_BLOCK = 32;\nstatic const int BLOCK_DATA_SIZE = (SCANS_PER_BLOCK * RAW_SCAN_SIZE);\n\nstatic const double ROTATION_RESOLUTION = 0.01;     // [deg]\nstatic const uint16_t ROTATION_MAX_UNITS = 36000u;  // [deg/100]\n\nstatic const size_t RETURN_MODE_INDEX = 1204;\n\nstatic const uint16_t UPPER_BANK = 0xeeff;\nstatic const uint16_t LOWER_BANK = 0xddff;\n\nstatic const uint16_t RETURN_MODE_STRONGEST = 55;\nstatic const uint16_t RETURN_MODE_LAST = 56;\nstatic const uint16_t RETURN_MODE_DUAL = 57;\n\nstatic const int VLP16_FIRINGS_PER_BLOCK = 2;\nstatic const int VLP16_SCANS_PER_FIRING = 16;\nstatic const float VLP16_BLOCK_DURATION = 110.592f;  // [\u00b5s]\nstatic const float VLP16_DSR_TOFFSET = 2.304f;       // [\u00b5s]\nstatic const float VLP16_FIRING_TOFFSET = 55.296f;   // [\u00b5s]\n\nstatic const float VLP128_DISTANCE_RESOLUTION = 0.004f;  // [m]\n\n// These are used to detect which bank of 32 lasers is in this block\nstatic const uint16_t VLS128_BANK_1 = 0xeeff;\nstatic const uint16_t VLS128_BANK_2 = 0xddff;\nstatic const uint16_t VLS128_BANK_3 = 0xccff;\nstatic const uint16_t VLS128_BANK_4 = 0xbbff;\n\nstatic const float VLS128_CHANNEL_DURATION =\n  2.665f;  // [\u00b5s] Channels corresponds to one laser firing\nstatic const float VLS128_SEQ_DURATION =\n  53.3f;  // [\u00b5s] Sequence is a set of laser firings including recharging\n\ntypedef struct raw_block\n{\n  uint16_t header;    \n  uint16_t rotation;  \n  uint8_t data[BLOCK_DATA_SIZE];\n} raw_block_t;\n\nunion two_bytes {\n  uint16_t uint;\n  uint8_t bytes[2];\n};\n\nstatic const int PACKET_SIZE = 1206;\nstatic const int BLOCKS_PER_PACKET = 12;\nstatic const int PACKET_STATUS_SIZE = 4;\nstatic const int SCANS_PER_PACKET = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET);\n\ntypedef struct raw_packet\n{\n  raw_block_t blocks[BLOCKS_PER_PACKET];\n  uint16_t revolution;\n  uint8_t status[PACKET_STATUS_SIZE];\n} raw_packet_t;\n\nenum RETURN_TYPE {\n  INVALID = 0,\n  SINGLE_STRONGEST = 1,\n  SINGLE_LAST = 2,\n  DUAL_STRONGEST_FIRST = 3,\n  DUAL_STRONGEST_LAST = 4,\n  DUAL_WEAK_FIRST = 5,\n  DUAL_WEAK_LAST = 6,\n  DUAL_ONLY = 7\n};\n\nclass VelodyneScanDecoder\n{\nprotected:\n  drivers::NebulaPointCloudPtr scan_pc_;\n  drivers::NebulaPointCloudPtr overflow_pc_;\n\n  uint16_t scan_phase_{};\n  uint16_t last_phase_{};\n  bool has_scanned_ = true;\n  double dual_return_distance_threshold_{};  // Velodyne does this internally, this will not be\n                                             // implemented here\n  double scan_timestamp_{};\n\n  std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; sensor_configuration_;\n  std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; calibration_configuration_;\n\npublic:\n  VelodyneScanDecoder(VelodyneScanDecoder &amp;&amp; c) = delete;\n  VelodyneScanDecoder &amp; operator=(VelodyneScanDecoder &amp;&amp; c) = delete;\n  VelodyneScanDecoder(const VelodyneScanDecoder &amp; c) = delete;\n  VelodyneScanDecoder &amp; operator=(const VelodyneScanDecoder &amp; c) = delete;\n\n  virtual ~VelodyneScanDecoder() = default;\n  VelodyneScanDecoder() = default;\n\n  virtual void unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0;\n  virtual bool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0;\n\n  virtual bool hasScanned() = 0;\n  virtual int pointsPerPacket() = 0;\n\n  virtual std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() = 0;\n  virtual void reset_pointcloud(size_t n_pts, double time_stamp) = 0;\n  virtual void reset_overflow(double time_stamp) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n</code></pre>"},{"location":"nebula_decoders/vlp16__decoder_8hpp/","title":"File vlp16_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vlp16_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_decoders/vlp16__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vlp16"},{"location":"nebula_decoders/vlp16__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vlp16Decoder Velodyne LiDAR decoder (VLP16) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/vlp16__decoder_8hpp_source/","title":"File vlp16_decoder.hpp","text":"<p>File List &gt; decoders &gt; vlp16_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;array&gt;\n#include &lt;memory&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vlp16\n{\nconstexpr uint32_t MAX_POINTS = 300000;\nclass Vlp16Decoder : public VelodyneScanDecoder\n{\npublic:\n  explicit Vlp16Decoder(\n    const std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\n  void unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  bool hasScanned() override;\n  int pointsPerPacket() override;\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n  void reset_pointcloud(size_t n_pts, double time_stamp) override;\n  void reset_overflow(double time_stamp) override;\n\nprivate:\n  bool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  float sin_rot_table_[ROTATION_MAX_UNITS];\n  float cos_rot_table_[ROTATION_MAX_UNITS];\n  float rotation_radians_[ROTATION_MAX_UNITS];\n  int phase_;\n  int max_pts_;\n  double last_block_timestamp_;\n  std::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\n};\n\n}  // namespace vlp16\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/vlp32__decoder_8hpp/","title":"File vlp32_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vlp32_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_decoders/vlp32__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vlp32"},{"location":"nebula_decoders/vlp32__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vlp32Decoder Velodyne LiDAR decoder (VLP32) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/vlp32__decoder_8hpp_source/","title":"File vlp32_decoder.hpp","text":"<p>File List &gt; decoders &gt; vlp32_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;array&gt;\n#include &lt;memory&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vlp32\n{\nclass Vlp32Decoder : public VelodyneScanDecoder\n{\npublic:\n  explicit Vlp32Decoder(\n    const std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\n  void unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  bool hasScanned() override;\n  int pointsPerPacket() override;\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n  void reset_pointcloud(size_t n_pts, double time_stamp) override;\n  void reset_overflow(double time_stamp) override;\n\nprivate:\n  bool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  float sin_rot_table_[ROTATION_MAX_UNITS];\n  float cos_rot_table_[ROTATION_MAX_UNITS];\n  float rotation_radians_[ROTATION_MAX_UNITS];\n  std::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\n  int phase_;\n  int max_pts_;\n  double last_block_timestamp_;\n};\n\n}  // namespace vlp32\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/vls128__decoder_8hpp/","title":"File vls128_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vls128_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/vls128__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vls128"},{"location":"nebula_decoders/vls128__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vls128Decoder Velodyne LiDAR decoder (VLS128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/vls128__decoder_8hpp_source/","title":"File vls128_decoder.hpp","text":"<p>File List &gt; decoders &gt; vls128_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vls128\n{\nclass Vls128Decoder : public VelodyneScanDecoder\n{\npublic:\n  explicit Vls128Decoder(\n    const std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\n  void unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  bool hasScanned() override;\n  int pointsPerPacket() override;\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n  void reset_pointcloud(size_t n_pts, double time_stamp) override;\n  void reset_overflow(double time_stamp) override;\n\nprivate:\n  bool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\n  float sin_rot_table_[ROTATION_MAX_UNITS];\n  float cos_rot_table_[ROTATION_MAX_UNITS];\n  float rotation_radians_[ROTATION_MAX_UNITS];\n  float vls_128_laser_azimuth_cache_[16];\n  int phase_;\n  int max_pts_;\n  double last_block_timestamp_;\n  std::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\n};\n\n}  // namespace vls128\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/velodyne__driver_8hpp/","title":"File velodyne_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne &gt; velodyne_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/velodyne__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/velodyne__driver_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneDriver Velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp</code></p>"},{"location":"nebula_decoders/velodyne__driver_8hpp_source/","title":"File velodyne_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne &gt; velodyne_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_DRIVER_H\n#define NEBULA_VELODYNE_DRIVER_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass VelodyneDriver : NebulaDriverBase\n{\nprivate:\n  Status driver_status_;\n  std::shared_ptr&lt;drivers::VelodyneScanDecoder&gt; scan_decoder_;\n\npublic:\n  VelodyneDriver() = delete;\n  VelodyneDriver(\n    const std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\n\n  Status SetCalibrationConfiguration(\n    const CalibrationConfigurationBase &amp; calibration_configuration) override;\n\n  Status GetStatus();\n\n  std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; ConvertScanToPointcloud(\n    const std::shared_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; &amp; velodyne_scan);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_DRIVER_H\n</code></pre>"},{"location":"nebula_decoders/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace endian </li> <li>namespace nebula <ul> <li>namespace drivers <ul> <li>namespace hesai_packet <ul> <li>namespace return_mode </li> </ul> </li> <li>namespace robosense_packet <ul> <li>namespace bpearl_v3 </li> <li>namespace bpearl_v4 </li> <li>namespace helios </li> </ul> </li> <li>namespace vlp16 </li> <li>namespace vlp32 </li> <li>namespace vls128 </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/classes/","title":"Class Index","text":""},{"location":"nebula_decoders/classes/#a","title":"a","text":"<ul> <li>AngleCorrector (nebula::drivers)</li> <li>AngleCorrectorCalibrationBased (nebula::drivers)</li> <li>AngleCorrectorCorrectionBased (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#b","title":"b","text":"<ul> <li>Block (nebula::drivers::hesai_packet)</li> <li>Block (nebula::drivers::robosense_packet)</li> <li>Body (nebula::drivers::hesai_packet)</li> <li>Body (nebula::drivers::robosense_packet)</li> <li>BpearlV3 (nebula::drivers)</li> <li>BpearlV4 (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#c","title":"c","text":"<ul> <li>ChannelAngleCorrection (nebula::drivers::robosense_packet)</li> <li>CorrectedAngleData (nebula::drivers)</li> <li>CorrectedHorizontalAngle (nebula::drivers::robosense_packet)</li> <li>CorrectedVerticalAngle (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#d","title":"d","text":"<ul> <li>DateTime (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#e","title":"e","text":"<ul> <li>Ethernet (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#f","title":"f","text":"<ul> <li>FaultDiagnosis (nebula::drivers::robosense_packet::bpearl_v3)</li> <li>FaultDiagnosis (nebula::drivers::robosense_packet::bpearl_v4)</li> <li>FaultDiagnosis (nebula::drivers::robosense_packet::helios)</li> <li>FineAzimuthBlock (nebula::drivers::hesai_packet)</li> <li>FirmwareVersion (nebula::drivers::robosense_packet)</li> <li>FovSetting (nebula::drivers::robosense_packet)</li> <li>FunctionalSafety (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#h","title":"h","text":"<ul> <li>Header (nebula::drivers::robosense_packet::bpearl_v3)</li> <li>Header (nebula::drivers::robosense_packet::bpearl_v4)</li> <li>Header (nebula::drivers::robosense_packet::helios)</li> <li>Header12B (nebula::drivers::hesai_packet)</li> <li>Header8B (nebula::drivers::hesai_packet)</li> <li>Helios (nebula::drivers)</li> <li>HesaiDecoder (nebula::drivers)</li> <li>HesaiDriver (nebula::drivers)</li> <li>HesaiScanDecoder (nebula::drivers)</li> <li>HesaiSensor (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#i","title":"i","text":"<ul> <li>InfoPacket (nebula::drivers::robosense_packet::bpearl_v3)</li> <li>InfoPacket (nebula::drivers::robosense_packet::bpearl_v4)</li> <li>InfoPacket (nebula::drivers::robosense_packet::helios)</li> <li>IpAddress (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#m","title":"m","text":"<ul> <li>MacAddress (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#o","title":"o","text":"<ul> <li>OperatingStatus (nebula::drivers::robosense_packet::bpearl_v3)</li> <li>OperatingStatus (nebula::drivers::robosense_packet::bpearl_v4)</li> <li>OperatingStatus (nebula::drivers::robosense_packet::helios)</li> </ul>"},{"location":"nebula_decoders/classes/#p","title":"p","text":"<ul> <li>Packet (nebula::drivers::robosense_packet::bpearl_v3)</li> <li>Packet (nebula::drivers::robosense_packet::bpearl_v4)</li> <li>Packet (nebula::drivers::robosense_packet::helios)</li> <li>Packet128E3X (nebula::drivers::hesai_packet)</li> <li>Packet40P (nebula::drivers::hesai_packet)</li> <li>Packet64 (nebula::drivers::hesai_packet)</li> <li>PacketAT128E2X (nebula::drivers::hesai_packet)</li> <li>PacketBase (nebula::drivers::hesai_packet)</li> <li>PacketBase (nebula::drivers::robosense_packet)</li> <li>PacketQT128C2X (nebula::drivers::hesai_packet)</li> <li>PacketQT64 (nebula::drivers::hesai_packet)</li> <li>PacketXT32 (nebula::drivers::hesai_packet)</li> <li>PacketXT32M2X (nebula::drivers::hesai_packet)</li> <li>Pandar128E3X (nebula::drivers)</li> <li>Pandar128E4X (nebula::drivers)</li> <li>Pandar40 (nebula::drivers)</li> <li>Pandar64 (nebula::drivers)</li> <li>PandarAT128 (nebula::drivers)</li> <li>PandarQT128 (nebula::drivers)</li> <li>PandarQT64 (nebula::drivers)</li> <li>PandarXT32 (nebula::drivers)</li> <li>PandarXT32M (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#r","title":"r","text":"<ul> <li>raw_block (nebula::drivers)</li> <li>raw_packet (nebula::drivers)</li> <li>RobosenseDecoder (nebula::drivers)</li> <li>RobosenseDriver (nebula::drivers)</li> <li>RobosenseInfoDecoder (nebula::drivers)</li> <li>RobosenseInfoDecoderBase (nebula::drivers)</li> <li>RobosenseInfoDriver (nebula::drivers)</li> <li>RobosenseScanDecoder (nebula::drivers)</li> <li>RobosenseSensor (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#s","title":"s","text":"<ul> <li>SecondsSinceEpoch (nebula::drivers::hesai_packet)</li> <li>SensorCalibration (nebula::drivers::robosense_packet)</li> <li>SensorHwVersion (nebula::drivers::robosense_packet::helios)</li> <li>SerialNumber (nebula::drivers::robosense_packet)</li> <li>SOBBlock (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#t","title":"t","text":"<ul> <li>Tail128E3X (nebula::drivers::hesai_packet)</li> <li>Tail40P (nebula::drivers::hesai_packet)</li> <li>TailAT128E2X (nebula::drivers::hesai_packet)</li> <li>TailQT128C2X (nebula::drivers::hesai_packet)</li> <li>TailQT64 (nebula::drivers::hesai_packet)</li> <li>TailXT32 (nebula::drivers::hesai_packet)</li> <li>Timestamp (nebula::drivers::robosense_packet)</li> <li>Timestamp (nebula::drivers::robosense_packet::bpearl_v3)</li> </ul>"},{"location":"nebula_decoders/classes/#u","title":"u","text":"<ul> <li>Unit (nebula::drivers::robosense_packet)</li> <li>Unit3B (nebula::drivers::hesai_packet)</li> <li>Unit4B (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/classes/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers)</li> <li>VelodyneScanDecoder (nebula::drivers)</li> <li>Vlp16Decoder (nebula::drivers::vlp16)</li> <li>Vlp32Decoder (nebula::drivers::vlp32)</li> <li>Vls128Decoder (nebula::drivers::vls128)</li> </ul>"},{"location":"nebula_decoders/classes/#w","title":"w","text":"<ul> <li>WebPageVersion (nebula::drivers::robosense_packet::helios)</li> </ul>"},{"location":"nebula_decoders/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::AngleCorrector Handles angle correction for given azimuth/channel combinations, as well as trigonometry lookup tables. <ul> <li>class nebula::drivers::AngleCorrectorCalibrationBased </li> <li>class nebula::drivers::AngleCorrectorCalibrationBased </li> <li>class nebula::drivers::AngleCorrectorCorrectionBased </li> </ul> </li> <li>class nebula::drivers::RobosenseSensor Base class for all sensor definitions. </li> <li>class nebula::drivers::HesaiScanDecoder Base class for Hesai LiDAR decoder. <ul> <li>class nebula::drivers::HesaiDecoder </li> </ul> </li> <li>class nebula::drivers::NebulaDriverBase Base class for each sensor driver. <ul> <li>class nebula::drivers::HesaiDriver Hesai driver. </li> <li>class nebula::drivers::RobosenseDriver Robosense driver. </li> <li>class nebula::drivers::VelodyneDriver Velodyne driver. </li> </ul> </li> <li>class nebula::drivers::HesaiSensor Base class for all sensor definitions. </li> <li>class nebula::drivers::RobosenseScanDecoder Base class for Robosense LiDAR decoder. <ul> <li>class nebula::drivers::RobosenseDecoder </li> </ul> </li> <li>class nebula::drivers::RobosenseInfoDecoderBase <ul> <li>class nebula::drivers::RobosenseInfoDecoder </li> </ul> </li> <li>class nebula::drivers::RobosenseInfoDriver Robosense driver. </li> <li>class nebula::drivers::VelodyneScanDecoder Base class for Velodyne LiDAR decoder. <ul> <li>class nebula::drivers::vlp16::Vlp16Decoder Velodyne LiDAR decoder (VLP16) </li> <li>class nebula::drivers::vlp32::Vlp32Decoder Velodyne LiDAR decoder (VLP32) </li> <li>class nebula::drivers::vls128::Vls128Decoder Velodyne LiDAR decoder (VLS128) </li> </ul> </li> <li>struct nebula::drivers::CorrectedAngleData </li> <li>struct nebula::drivers::hesai_packet::Block </li> <li>struct nebula::drivers::hesai_packet::Body </li> <li>struct nebula::drivers::hesai_packet::DateTime DateTime struct for Hesai packets.</li> <li>struct nebula::drivers::hesai_packet::FineAzimuthBlock </li> <li>struct nebula::drivers::hesai_packet::FunctionalSafety </li> <li>struct nebula::drivers::hesai_packet::Header12B </li> <li>struct nebula::drivers::hesai_packet::Header8B </li> <li>struct nebula::drivers::hesai_packet::PacketBase Base struct for all Hesai packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. </li> <li>struct nebula::drivers::hesai_packet::SOBBlock </li> <li>struct nebula::drivers::hesai_packet::SecondsSinceEpoch </li> <li>struct nebula::drivers::hesai_packet::Tail128E3X </li> <li>struct nebula::drivers::hesai_packet::Tail40P </li> <li>struct nebula::drivers::hesai_packet::TailAT128E2X </li> <li>struct nebula::drivers::hesai_packet::TailQT128C2X </li> <li>struct nebula::drivers::hesai_packet::TailQT64 </li> <li>struct nebula::drivers::hesai_packet::TailXT32 </li> <li>struct nebula::drivers::hesai_packet::Unit3B </li> <li>struct nebula::drivers::hesai_packet::Unit4B </li> <li>struct nebula::drivers::raw_block Raw Velodyne data block. </li> <li>struct nebula::drivers::raw_packet Raw Velodyne packet. </li> <li>struct nebula::drivers::robosense_packet::Block </li> <li>struct nebula::drivers::robosense_packet::Body </li> <li>struct nebula::drivers::robosense_packet::ChannelAngleCorrection </li> <li>struct nebula::drivers::robosense_packet::CorrectedHorizontalAngle </li> <li>struct nebula::drivers::robosense_packet::CorrectedVerticalAngle </li> <li>struct nebula::drivers::robosense_packet::Ethernet </li> <li>struct nebula::drivers::robosense_packet::FirmwareVersion </li> <li>struct nebula::drivers::robosense_packet::FovSetting </li> <li>struct nebula::drivers::robosense_packet::IpAddress </li> <li>struct nebula::drivers::robosense_packet::MacAddress </li> <li>struct nebula::drivers::robosense_packet::PacketBase Base struct for all Robosense packets. This struct is not allowed to have any non-static members, otherwise memory layout is not guaranteed for the derived structs. </li> <li>struct nebula::drivers::robosense_packet::SensorCalibration </li> <li>struct nebula::drivers::robosense_packet::SerialNumber </li> <li>struct nebula::drivers::robosense_packet::Timestamp </li> <li>struct nebula::drivers::robosense_packet::Unit </li> <li>struct nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis </li> <li>struct nebula::drivers::robosense_packet::bpearl_v3::Header </li> <li>struct nebula::drivers::robosense_packet::bpearl_v3::InfoPacket </li> <li>struct nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus </li> <li>struct nebula::drivers::robosense_packet::bpearl_v3::Timestamp </li> <li>struct nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis </li> <li>struct nebula::drivers::robosense_packet::bpearl_v4::Header </li> <li>struct nebula::drivers::robosense_packet::bpearl_v4::InfoPacket </li> <li>struct nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus </li> <li>struct nebula::drivers::robosense_packet::helios::FaultDiagnosis </li> <li>struct nebula::drivers::robosense_packet::helios::Header </li> <li>struct nebula::drivers::robosense_packet::helios::InfoPacket </li> <li>struct nebula::drivers::robosense_packet::helios::OperatingStatus </li> <li>struct nebula::drivers::robosense_packet::helios::SensorHwVersion </li> <li>struct nebula::drivers::robosense_packet::helios::WebPageVersion </li> </ul>"},{"location":"nebula_decoders/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_decoders/todo/","title":"Todo","text":"<p>Todo List</p>"},{"location":"nebula_decoders/todo/#member-nebuladriversraw_packet_t","title":"Member nebula::drivers::raw_packet_t","text":"<p>figure out if revolution is only present for one of the two types of status fields</p>"},{"location":"nebula_decoders/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p> <ul> <li>Todo List </li> </ul>"},{"location":"nebula_decoders/class_members/","title":"Class Members","text":""},{"location":"nebula_decoders/class_members/#a","title":"a","text":"<ul> <li>AngleCorrector (nebula::drivers::AngleCorrector)</li> <li>AngleCorrectorCalibrationBased (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_cos_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_offset_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_sin_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>AngleCorrectorCorrectionBased (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>azimuth_rad (nebula::drivers::CorrectedAngleData)</li> <li>angle_corrector_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>angle_corrector_t (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>azimuth (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>azimuth_state (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>angle (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>angles (nebula::drivers::robosense_packet::CorrectedHorizontalAngle, nebula::drivers::robosense_packet::CorrectedVerticalAngle)</li> <li>app_software_version (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>angle_interval_count (nebula::drivers::robosense_packet::helios::Header)</li> </ul>"},{"location":"nebula_decoders/class_members/#b","title":"b","text":"<ul> <li>block_azimuth_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>block_firing_offset_ns_ (nebula::drivers::HesaiDecoder)</li> <li>block_t (nebula::drivers::hesai_packet::Body, nebula::drivers::robosense_packet::Body)</li> <li>blocks (nebula::drivers::hesai_packet::Body, nebula::drivers::raw_packet, nebula::drivers::robosense_packet::Body)</li> <li>block_num (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>body (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::Packet)</li> <li>body_t (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::Packet)</li> <li>bottom_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>bottom_software_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>baud_rate (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>bottom_packet_count (nebula::drivers::robosense_packet::helios::Header)</li> <li>bottom_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#c","title":"c","text":"<ul> <li>cos_ (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>corrected_channel_id (nebula::drivers::CorrectedAngleData)</li> <li>cos_azimuth (nebula::drivers::CorrectedAngleData)</li> <li>cos_elevation (nebula::drivers::CorrectedAngleData)</li> <li>channel_firing_offset_ns_ (nebula::drivers::HesaiDecoder)</li> <li>checkScanCompleted (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>convertReturns (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>ConvertScanToPointcloud (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> <li>calibration_configuration_ (nebula::drivers::VelodyneScanDecoder)</li> <li>crc_fs (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>crc_body (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X)</li> <li>confidence_or_reserved (nebula::drivers::hesai_packet::Unit4B)</li> <li>corrected_horizontal_angle (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>corrected_vertical_angle (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>checksum (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>code_wheel_status (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>cos_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#d","title":"d","text":"<ul> <li>DUAL_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>decode_pc_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>decode_scan_timestamp_ns_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>driver_status_ (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::RobosenseInfoDriver, nebula::drivers::VelodyneDriver)</li> <li>DecodeInfoPacket (nebula::drivers::RobosenseInfoDriver)</li> <li>dual_return_distance_threshold_ (nebula::drivers::VelodyneScanDecoder)</li> <li>day (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>dis_unit (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>DEGREE_SUBDIVISIONS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>date_time (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>distance (nebula::drivers::hesai_packet::Unit3B, nebula::drivers::hesai_packet::Unit4B, nebula::drivers::robosense_packet::Unit)</li> <li>data (nebula::drivers::raw_block)</li> <li>dest_pc_ip (nebula::drivers::robosense_packet::Ethernet)</li> </ul>"},{"location":"nebula_decoders/class_members/#e","title":"e","text":"<ul> <li>elevation_angle_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_cos_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_sin_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_rad (nebula::drivers::CorrectedAngleData)</li> <li>elapsed_time_flag (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket)</li> <li>ethernet (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>ethernet_gateway (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#f","title":"f","text":"<ul> <li>findField (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>firing_time_offset_ns_dual_ (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>firing_time_offset_ns_single_ (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>FIRST_RETURN_FLAG (nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>firing_time_offset_as0_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_as1_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_static_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_ns_ (nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT64)</li> <li>fine_azimuth (nebula::drivers::hesai_packet::FineAzimuthBlock)</li> <li>fault_code (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>fault_code_id (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>fs_version (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>flags (nebula::drivers::hesai_packet::Header12B)</li> <li>fs (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::PacketQT128C2X)</li> <li>factory_information (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>flag (nebula::drivers::robosense_packet::Block)</li> <li>fifth_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber)</li> <li>first_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>fourth_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>fov_end (nebula::drivers::robosense_packet::FovSetting)</li> <li>fov_start (nebula::drivers::robosense_packet::FovSetting)</li> <li>fault_diagnosis (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>fov_setting (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#g","title":"g","text":"<ul> <li>getCorrectedAngleData (nebula::drivers::AngleCorrector, nebula::drivers::AngleCorrectorCalibrationBased, nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>getPacketRelativePointTimeOffset (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::HesaiSensor, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M, nebula::drivers::RobosenseSensor)</li> <li>getReturnMode (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSensorCalibration (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSensorInfo (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSyncStatus (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getDistance (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>getPointTimeRelative (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>getPointcloud (nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder)</li> <li>GetStatus (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::RobosenseInfoDriver, nebula::drivers::VelodyneDriver)</li> <li>getEarliestPointTimeOffsetForBlock (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>getReturnType (nebula::drivers::HesaiSensor, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::PandarXT32, nebula::drivers::RobosenseSensor)</li> <li>GetReturnMode (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSensorCalibration (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSensorInfo (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSyncStatus (nebula::drivers::RobosenseInfoDriver)</li> <li>get_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>get_azimuth (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>get_seconds (nebula::drivers::hesai_packet::DateTime, nebula::drivers::hesai_packet::SecondsSinceEpoch)</li> <li>geAzimuthState (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>getAngle (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>getCalibration (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>get_time_in_ns (nebula::drivers::robosense_packet::Timestamp, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>gps_st (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>gprmc (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>gps_status (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> </ul>"},{"location":"nebula_decoders/class_members/#h","title":"h","text":"<ul> <li>hasScanned (nebula::drivers::AngleCorrector, nebula::drivers::AngleCorrectorCalibrationBased, nebula::drivers::AngleCorrectorCorrectionBased, nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>HesaiDecoder (nebula::drivers::HesaiDecoder)</li> <li>has_scanned_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>HesaiDriver (nebula::drivers::HesaiDriver)</li> <li>HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>HesaiSensor (nebula::drivers::HesaiSensor)</li> <li>hires_as0_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as0_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as1_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as1_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as2_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as2_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as3_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as3_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hour (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>header (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::raw_block, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::InfoPacket, nebula::drivers::robosense_packet::helios::Packet)</li> <li>high_temperature_shutdown_flag (nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X)</li> <li>header_id (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> </ul>"},{"location":"nebula_decoders/class_members/#i","title":"i","text":"<ul> <li>is_duplicate (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>is_strongest (nebula::drivers::HesaiSensor)</li> <li>info_decoder_ (nebula::drivers::RobosenseInfoDriver)</li> <li>info_t (nebula::drivers::RobosenseSensor)</li> <li>i_dat (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> </ul>"},{"location":"nebula_decoders/class_members/#l","title":"l","text":"<ul> <li>logger_ (nebula::drivers::AngleCorrectorCorrectionBased, nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>LAST_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>last_phase_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>loop1 (nebula::drivers::PandarQT128)</li> <li>loop2 (nebula::drivers::PandarQT128)</li> <li>lidar_state (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>laser_num (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>lidar_ip (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_out_difop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_out_msop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_model (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>lidar_type (nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>lane_up (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>lane_up_cnt (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>last_block_timestamp_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#m","title":"m","text":"<ul> <li>MAX_AZIMUTH_LEN (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>MAX_AZIMUTH_LENGTH (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>MAX_RANGE (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>MAX_SCAN_BUFFER_POINTS (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>MIN_RANGE (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>minute (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>month (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>MAX_RETURNS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>motor_speed (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>mode_flag (nebula::drivers::hesai_packet::TailQT128C2X)</li> <li>mac_addr (nebula::drivers::robosense_packet::Ethernet)</li> <li>microseconds (nebula::drivers::robosense_packet::Timestamp)</li> <li>manc_err1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>manc_err2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>motor_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>microsecond (nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>millisecond (nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>machine_temp (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>mainboard_firmware_version (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>motor_speed_setting (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>machine_current (nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus)</li> <li>machine_voltage (nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus)</li> <li>max_pts_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers::NebulaDriverBase)</li> <li>N_BLOCKS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>N_CHANNELS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> </ul>"},{"location":"nebula_decoders/class_members/#o","title":"o","text":"<ul> <li>output_pc_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>output_scan_timestamp_ns_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>operator= (nebula::drivers::HesaiScanDecoder, nebula::drivers::NebulaDriverBase, nebula::drivers::RobosenseInfoDecoderBase, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>OperationalState (nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X)</li> <li>overflow_pc_ (nebula::drivers::VelodyneScanDecoder)</li> <li>operational_state (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>operating_status (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#p","title":"p","text":"<ul> <li>packet_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>parsePacket (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>packet_t (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>pointsPerPacket (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>protocol_major (nebula::drivers::hesai_packet::Header12B)</li> <li>protocol_minor (nebula::drivers::hesai_packet::Header12B)</li> <li>pc_dest_difop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>pc_dest_msop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>packet_count (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header)</li> <li>phase_lock (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>phase (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>protocol_version (nebula::drivers::robosense_packet::helios::Header)</li> <li>pps_trigger_mode (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>phase_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#r","title":"r","text":"<ul> <li>RobosenseDecoder (nebula::drivers::RobosenseDecoder)</li> <li>RobosenseDriver (nebula::drivers::RobosenseDriver)</li> <li>RobosenseInfoDecoder (nebula::drivers::RobosenseInfoDecoder)</li> <li>RobosenseInfoDecoderBase (nebula::drivers::RobosenseInfoDecoderBase)</li> <li>RobosenseInfoDriver (nebula::drivers::RobosenseInfoDriver)</li> <li>RobosenseScanDecoder (nebula::drivers::RobosenseScanDecoder)</li> <li>RobosenseSensor (nebula::drivers::RobosenseSensor)</li> <li>reset_overflow (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reset_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reserved1 (nebula::drivers::hesai_packet::FunctionalSafety, nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B, nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>reserved2 (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X)</li> <li>return_num (nebula::drivers::hesai_packet::Header12B)</li> <li>return_mode (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reflectivity (nebula::drivers::hesai_packet::Unit3B, nebula::drivers::hesai_packet::Unit4B, nebula::drivers::robosense_packet::Unit)</li> <li>rotation (nebula::drivers::raw_block)</li> <li>revolution (nebula::drivers::raw_packet)</li> <li>r_rpm1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>r_rpm2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>reserved_first (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_fourth (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_second (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_third (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reverse_zero_angle_offset (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket)</li> <li>rotation_direction (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>reserved (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>rotation_speed (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>reserved_fifth (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_sixth (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>running_time (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>r_rpm (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>range_resolution (nebula::drivers::robosense_packet::helios::Header)</li> <li>rotation_radians_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#s","title":"s","text":"<ul> <li>sensor_calibration_ (nebula::drivers::AngleCorrector)</li> <li>sensor_correction_ (nebula::drivers::AngleCorrector)</li> <li>sin_ (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>STRONGEST_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_E2E_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_GPS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_GPTP_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_P2P_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_GPS_SUCCESS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_INVALID_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_PTP_SUCCESS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>sin_azimuth (nebula::drivers::CorrectedAngleData)</li> <li>sin_elevation (nebula::drivers::CorrectedAngleData)</li> <li>sensor_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>sensor_configuration_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>SetCalibrationConfiguration (nebula::drivers::HesaiDriver, nebula::drivers::NebulaDriverBase, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> <li>scan_decoder_ (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> <li>standard_as0_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as0_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as1_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as1_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>scan_pc_ (nebula::drivers::VelodyneScanDecoder)</li> <li>scan_phase_ (nebula::drivers::VelodyneScanDecoder)</li> <li>scan_timestamp_ (nebula::drivers::VelodyneScanDecoder)</li> <li>second (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>sop (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>sob (nebula::drivers::hesai_packet::SOBBlock)</li> <li>seconds (nebula::drivers::hesai_packet::SecondsSinceEpoch, nebula::drivers::robosense_packet::Timestamp)</li> <li>status (nebula::drivers::raw_packet)</li> <li>sign (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>second_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>sixth_octet (nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber)</li> <li>sensor_calibration (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>serial_number (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>sync_status (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>startup_times (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>sensor_hw_version (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>software_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>subnet_mask (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>sin_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#t","title":"t","text":"<ul> <li>tail (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::InfoPacket, nebula::drivers::robosense_packet::helios::Packet)</li> <li>timestamp (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>third_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>to_string (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>temperature1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature3 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature4 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature5 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature6 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>temperature (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>top_board_temperature (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>tcp_msop_port (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>time (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>time_sync_mode (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>top_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>time_sync_state (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>top_status (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>top_packet_count (nebula::drivers::robosense_packet::helios::Header)</li> <li>top_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>timing_offsets_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#u","title":"u","text":"<ul> <li>unpack (nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>unit_t (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>units (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>udp_sequence (nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X)</li> </ul>"},{"location":"nebula_decoders/class_members/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers::VelodyneDriver)</li> <li>VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> <li>v_dat_0v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_0v5 (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_12v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_1v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_1v25 (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_5v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_2v5 (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_apd (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>Vlp16Decoder (nebula::drivers::vlp16::Vlp16Decoder)</li> <li>Vlp32Decoder (nebula::drivers::vlp32::Vlp32Decoder)</li> <li>Vls128Decoder (nebula::drivers::vls128::Vls128Decoder)</li> <li>vls_128_laser_azimuth_cache_ (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#w","title":"w","text":"<ul> <li>web_page_version (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>webpage_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#y","title":"y","text":"<ul> <li>year (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> </ul>"},{"location":"nebula_decoders/class_members/#z","title":"z","text":"<ul> <li>zero (nebula::drivers::hesai_packet::SecondsSinceEpoch)</li> <li>zero_angle_offset (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_members/#_1","title":"~","text":"<ul> <li>~HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>~HesaiSensor (nebula::drivers::HesaiSensor)</li> <li>~RobosenseInfoDecoderBase (nebula::drivers::RobosenseInfoDecoderBase)</li> <li>~RobosenseScanDecoder (nebula::drivers::RobosenseScanDecoder)</li> <li>~RobosenseSensor (nebula::drivers::RobosenseSensor)</li> <li>~VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_decoders/class_member_functions/#a","title":"a","text":"<ul> <li>AngleCorrector (nebula::drivers::AngleCorrector)</li> <li>AngleCorrectorCalibrationBased (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>AngleCorrectorCorrectionBased (nebula::drivers::AngleCorrectorCorrectionBased)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#c","title":"c","text":"<ul> <li>checkScanCompleted (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>convertReturns (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>ConvertScanToPointcloud (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#d","title":"d","text":"<ul> <li>DecodeInfoPacket (nebula::drivers::RobosenseInfoDriver)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#f","title":"f","text":"<ul> <li>findField (nebula::drivers::AngleCorrectorCorrectionBased)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#g","title":"g","text":"<ul> <li>getCorrectedAngleData (nebula::drivers::AngleCorrector, nebula::drivers::AngleCorrectorCalibrationBased, nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>getPacketRelativePointTimeOffset (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::HesaiSensor, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M, nebula::drivers::RobosenseSensor)</li> <li>getReturnMode (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSensorCalibration (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSensorInfo (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getSyncStatus (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase)</li> <li>getDistance (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>getPointTimeRelative (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>getPointcloud (nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder)</li> <li>GetStatus (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::RobosenseInfoDriver, nebula::drivers::VelodyneDriver)</li> <li>getEarliestPointTimeOffsetForBlock (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>getReturnType (nebula::drivers::HesaiSensor, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::PandarXT32, nebula::drivers::RobosenseSensor)</li> <li>GetReturnMode (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSensorCalibration (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSensorInfo (nebula::drivers::RobosenseInfoDriver)</li> <li>GetSyncStatus (nebula::drivers::RobosenseInfoDriver)</li> <li>get_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>get_azimuth (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>get_seconds (nebula::drivers::hesai_packet::DateTime, nebula::drivers::hesai_packet::SecondsSinceEpoch)</li> <li>geAzimuthState (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>getAngle (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>getCalibration (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>get_time_in_ns (nebula::drivers::robosense_packet::Timestamp, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#h","title":"h","text":"<ul> <li>hasScanned (nebula::drivers::AngleCorrector, nebula::drivers::AngleCorrectorCalibrationBased, nebula::drivers::AngleCorrectorCorrectionBased, nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>HesaiDecoder (nebula::drivers::HesaiDecoder)</li> <li>HesaiDriver (nebula::drivers::HesaiDriver)</li> <li>HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>HesaiSensor (nebula::drivers::HesaiSensor)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#i","title":"i","text":"<ul> <li>is_duplicate (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> <li>is_strongest (nebula::drivers::HesaiSensor)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers::NebulaDriverBase)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::HesaiScanDecoder, nebula::drivers::NebulaDriverBase, nebula::drivers::RobosenseInfoDecoderBase, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#p","title":"p","text":"<ul> <li>parsePacket (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder, nebula::drivers::RobosenseInfoDecoderBase, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>pointsPerPacket (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#r","title":"r","text":"<ul> <li>RobosenseDecoder (nebula::drivers::RobosenseDecoder)</li> <li>RobosenseDriver (nebula::drivers::RobosenseDriver)</li> <li>RobosenseInfoDecoder (nebula::drivers::RobosenseInfoDecoder)</li> <li>RobosenseInfoDecoderBase (nebula::drivers::RobosenseInfoDecoderBase)</li> <li>RobosenseInfoDriver (nebula::drivers::RobosenseInfoDriver)</li> <li>RobosenseScanDecoder (nebula::drivers::RobosenseScanDecoder)</li> <li>RobosenseSensor (nebula::drivers::RobosenseSensor)</li> <li>reset_overflow (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reset_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#s","title":"s","text":"<ul> <li>SetCalibrationConfiguration (nebula::drivers::HesaiDriver, nebula::drivers::NebulaDriverBase, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#t","title":"t","text":"<ul> <li>to_string (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#u","title":"u","text":"<ul> <li>unpack (nebula::drivers::HesaiDecoder, nebula::drivers::HesaiScanDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers::VelodyneDriver)</li> <li>VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> <li>Vlp16Decoder (nebula::drivers::vlp16::Vlp16Decoder)</li> <li>Vlp32Decoder (nebula::drivers::vlp32::Vlp32Decoder)</li> <li>Vls128Decoder (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#_1","title":"~","text":"<ul> <li>~HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>~HesaiSensor (nebula::drivers::HesaiSensor)</li> <li>~RobosenseInfoDecoderBase (nebula::drivers::RobosenseInfoDecoderBase)</li> <li>~RobosenseScanDecoder (nebula::drivers::RobosenseScanDecoder)</li> <li>~RobosenseSensor (nebula::drivers::RobosenseSensor)</li> <li>~VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_decoders/class_member_variables/#a","title":"a","text":"<ul> <li>azimuth_cos_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_offset_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_sin_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>azimuth_rad (nebula::drivers::CorrectedAngleData)</li> <li>angle_corrector_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>azimuth (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>azimuth_state (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>angle (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>angles (nebula::drivers::robosense_packet::CorrectedHorizontalAngle, nebula::drivers::robosense_packet::CorrectedVerticalAngle)</li> <li>app_software_version (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>angle_interval_count (nebula::drivers::robosense_packet::helios::Header)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#b","title":"b","text":"<ul> <li>block_azimuth_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>block_firing_offset_ns_ (nebula::drivers::HesaiDecoder)</li> <li>blocks (nebula::drivers::hesai_packet::Body, nebula::drivers::raw_packet, nebula::drivers::robosense_packet::Body)</li> <li>block_num (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>body (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::Packet)</li> <li>bottom_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>bottom_software_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>baud_rate (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>bottom_packet_count (nebula::drivers::robosense_packet::helios::Header)</li> <li>bottom_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#c","title":"c","text":"<ul> <li>cos_ (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>corrected_channel_id (nebula::drivers::CorrectedAngleData)</li> <li>cos_azimuth (nebula::drivers::CorrectedAngleData)</li> <li>cos_elevation (nebula::drivers::CorrectedAngleData)</li> <li>channel_firing_offset_ns_ (nebula::drivers::HesaiDecoder)</li> <li>calibration_configuration_ (nebula::drivers::VelodyneScanDecoder)</li> <li>crc_fs (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>crc_body (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X)</li> <li>confidence_or_reserved (nebula::drivers::hesai_packet::Unit4B)</li> <li>corrected_horizontal_angle (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>corrected_vertical_angle (nebula::drivers::robosense_packet::SensorCalibration)</li> <li>checksum (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>code_wheel_status (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>cos_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#d","title":"d","text":"<ul> <li>DUAL_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>decode_pc_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>decode_scan_timestamp_ns_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>driver_status_ (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::RobosenseInfoDriver, nebula::drivers::VelodyneDriver)</li> <li>dual_return_distance_threshold_ (nebula::drivers::VelodyneScanDecoder)</li> <li>day (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>dis_unit (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>DEGREE_SUBDIVISIONS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>date_time (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>distance (nebula::drivers::hesai_packet::Unit3B, nebula::drivers::hesai_packet::Unit4B, nebula::drivers::robosense_packet::Unit)</li> <li>data (nebula::drivers::raw_block)</li> <li>dest_pc_ip (nebula::drivers::robosense_packet::Ethernet)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#e","title":"e","text":"<ul> <li>elevation_angle_rad_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_cos_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_sin_ (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>elevation_rad (nebula::drivers::CorrectedAngleData)</li> <li>elapsed_time_flag (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket)</li> <li>ethernet (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>ethernet_gateway (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#f","title":"f","text":"<ul> <li>firing_time_offset_ns_dual_ (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>firing_time_offset_ns_single_ (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>FIRST_RETURN_FLAG (nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>firing_time_offset_as0_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_as1_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_static_ns_ (nebula::drivers::Pandar128E4X)</li> <li>firing_time_offset_ns_ (nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT64)</li> <li>fine_azimuth (nebula::drivers::hesai_packet::FineAzimuthBlock)</li> <li>fault_code (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>fault_code_id (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>fs_version (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>flags (nebula::drivers::hesai_packet::Header12B)</li> <li>fs (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::PacketQT128C2X)</li> <li>factory_information (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>flag (nebula::drivers::robosense_packet::Block)</li> <li>fifth_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber)</li> <li>first_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>fourth_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>fov_end (nebula::drivers::robosense_packet::FovSetting)</li> <li>fov_start (nebula::drivers::robosense_packet::FovSetting)</li> <li>fault_diagnosis (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>fov_setting (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#g","title":"g","text":"<ul> <li>gps_st (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>gprmc (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>gps_status (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#h","title":"h","text":"<ul> <li>has_scanned_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>hires_as0_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as0_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as1_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as1_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as2_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as2_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as3_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hires_as3_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>hour (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>header (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::raw_block, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::InfoPacket, nebula::drivers::robosense_packet::helios::Packet)</li> <li>high_temperature_shutdown_flag (nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X)</li> <li>header_id (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#i","title":"i","text":"<ul> <li>info_decoder_ (nebula::drivers::RobosenseInfoDriver)</li> <li>i_dat (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#l","title":"l","text":"<ul> <li>logger_ (nebula::drivers::AngleCorrectorCorrectionBased, nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>LAST_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>last_phase_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>loop1 (nebula::drivers::PandarQT128)</li> <li>loop2 (nebula::drivers::PandarQT128)</li> <li>lidar_state (nebula::drivers::hesai_packet::FunctionalSafety)</li> <li>laser_num (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>lidar_ip (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_out_difop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_out_msop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>lidar_model (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>lidar_type (nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>lane_up (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>lane_up_cnt (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>last_block_timestamp_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#m","title":"m","text":"<ul> <li>MAX_AZIMUTH_LEN (nebula::drivers::AngleCorrectorCalibrationBased)</li> <li>MAX_AZIMUTH_LENGTH (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>MAX_RANGE (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>MAX_SCAN_BUFFER_POINTS (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>MIN_RANGE (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios, nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X, nebula::drivers::Pandar40, nebula::drivers::Pandar64, nebula::drivers::PandarAT128, nebula::drivers::PandarQT128, nebula::drivers::PandarQT64, nebula::drivers::PandarXT32, nebula::drivers::PandarXT32M)</li> <li>minute (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>month (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>MAX_RETURNS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>motor_speed (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>mode_flag (nebula::drivers::hesai_packet::TailQT128C2X)</li> <li>mac_addr (nebula::drivers::robosense_packet::Ethernet)</li> <li>microseconds (nebula::drivers::robosense_packet::Timestamp)</li> <li>manc_err1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>manc_err2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>motor_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>microsecond (nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>millisecond (nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>machine_temp (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>mainboard_firmware_version (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>motor_speed_setting (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>machine_current (nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus)</li> <li>machine_voltage (nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus)</li> <li>max_pts_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#n","title":"n","text":"<ul> <li>N_BLOCKS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> <li>N_CHANNELS (nebula::drivers::hesai_packet::PacketBase, nebula::drivers::robosense_packet::PacketBase)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#o","title":"o","text":"<ul> <li>output_pc_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>output_scan_timestamp_ns_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder)</li> <li>overflow_pc_ (nebula::drivers::VelodyneScanDecoder)</li> <li>operational_state (nebula::drivers::hesai_packet::Tail128E3X)</li> <li>operating_status (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#p","title":"p","text":"<ul> <li>packet_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>protocol_major (nebula::drivers::hesai_packet::Header12B)</li> <li>protocol_minor (nebula::drivers::hesai_packet::Header12B)</li> <li>pc_dest_difop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>pc_dest_msop_port (nebula::drivers::robosense_packet::Ethernet)</li> <li>packet_count (nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header)</li> <li>phase_lock (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>phase (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>protocol_version (nebula::drivers::robosense_packet::helios::Header)</li> <li>pps_trigger_mode (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>phase_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#r","title":"r","text":"<ul> <li>reserved1 (nebula::drivers::hesai_packet::FunctionalSafety, nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B, nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32)</li> <li>reserved2 (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X)</li> <li>return_num (nebula::drivers::hesai_packet::Header12B)</li> <li>return_mode (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reflectivity (nebula::drivers::hesai_packet::Unit3B, nebula::drivers::hesai_packet::Unit4B, nebula::drivers::robosense_packet::Unit)</li> <li>rotation (nebula::drivers::raw_block)</li> <li>revolution (nebula::drivers::raw_packet)</li> <li>r_rpm1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>r_rpm2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>reserved_first (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_fourth (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_second (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_third (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::OperatingStatus, nebula::drivers::robosense_packet::helios::Header, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reverse_zero_angle_offset (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket)</li> <li>rotation_direction (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>reserved (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>rotation_speed (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>reserved_fifth (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>reserved_sixth (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>running_time (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>r_rpm (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>range_resolution (nebula::drivers::robosense_packet::helios::Header)</li> <li>rotation_radians_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#s","title":"s","text":"<ul> <li>sensor_calibration_ (nebula::drivers::AngleCorrector)</li> <li>sensor_correction_ (nebula::drivers::AngleCorrector)</li> <li>sin_ (nebula::drivers::AngleCorrectorCorrectionBased)</li> <li>STRONGEST_RETURN_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_E2E_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_GPS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_GPTP_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_MODE_P2P_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_GPS_SUCCESS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_INVALID_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>SYNC_STATUS_PTP_SUCCESS_FLAG (nebula::drivers::BpearlV3, nebula::drivers::BpearlV4, nebula::drivers::Helios)</li> <li>sin_azimuth (nebula::drivers::CorrectedAngleData)</li> <li>sin_elevation (nebula::drivers::CorrectedAngleData)</li> <li>sensor_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::RobosenseInfoDecoder)</li> <li>sensor_configuration_ (nebula::drivers::HesaiDecoder, nebula::drivers::RobosenseDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>scan_decoder_ (nebula::drivers::HesaiDriver, nebula::drivers::RobosenseDriver, nebula::drivers::VelodyneDriver)</li> <li>standard_as0_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as0_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as1_far_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>standard_as1_near_offset_ns_ (nebula::drivers::Pandar128E3X)</li> <li>scan_pc_ (nebula::drivers::VelodyneScanDecoder)</li> <li>scan_phase_ (nebula::drivers::VelodyneScanDecoder)</li> <li>scan_timestamp_ (nebula::drivers::VelodyneScanDecoder)</li> <li>second (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> <li>sop (nebula::drivers::hesai_packet::Header12B, nebula::drivers::hesai_packet::Header8B)</li> <li>sob (nebula::drivers::hesai_packet::SOBBlock)</li> <li>seconds (nebula::drivers::hesai_packet::SecondsSinceEpoch, nebula::drivers::robosense_packet::Timestamp)</li> <li>status (nebula::drivers::raw_packet)</li> <li>sign (nebula::drivers::robosense_packet::ChannelAngleCorrection)</li> <li>second_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>sixth_octet (nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber)</li> <li>sensor_calibration (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>serial_number (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>sync_status (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>startup_times (nebula::drivers::robosense_packet::bpearl_v4::FaultDiagnosis)</li> <li>sensor_hw_version (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>software_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>subnet_mask (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>sin_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#t","title":"t","text":"<ul> <li>tail (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::InfoPacket, nebula::drivers::robosense_packet::helios::Packet)</li> <li>timestamp (nebula::drivers::hesai_packet::Tail128E3X, nebula::drivers::hesai_packet::Tail40P, nebula::drivers::hesai_packet::TailAT128E2X, nebula::drivers::hesai_packet::TailQT128C2X, nebula::drivers::hesai_packet::TailQT64, nebula::drivers::hesai_packet::TailXT32, nebula::drivers::robosense_packet::bpearl_v3::Header, nebula::drivers::robosense_packet::bpearl_v4::Header, nebula::drivers::robosense_packet::helios::Header)</li> <li>third_octet (nebula::drivers::robosense_packet::FirmwareVersion, nebula::drivers::robosense_packet::IpAddress, nebula::drivers::robosense_packet::MacAddress, nebula::drivers::robosense_packet::SerialNumber, nebula::drivers::robosense_packet::helios::SensorHwVersion, nebula::drivers::robosense_packet::helios::WebPageVersion)</li> <li>temperature1 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature2 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature3 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature4 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature5 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis, nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>temperature6 (nebula::drivers::robosense_packet::bpearl_v3::FaultDiagnosis)</li> <li>temperature (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>top_board_temperature (nebula::drivers::robosense_packet::bpearl_v3::Header)</li> <li>tcp_msop_port (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>time (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>time_sync_mode (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::bpearl_v4::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>top_firmware_version (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>time_sync_state (nebula::drivers::robosense_packet::bpearl_v4::InfoPacket)</li> <li>top_status (nebula::drivers::robosense_packet::helios::FaultDiagnosis)</li> <li>top_packet_count (nebula::drivers::robosense_packet::helios::Header)</li> <li>top_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>timing_offsets_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#u","title":"u","text":"<ul> <li>units (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> <li>udp_sequence (nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#v","title":"v","text":"<ul> <li>v_dat_0v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_0v5 (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_12v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_1v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_1v25 (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus)</li> <li>v_dat_5v (nebula::drivers::robosense_packet::bpearl_v3::OperatingStatus, nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_2v5 (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>v_dat_apd (nebula::drivers::robosense_packet::helios::OperatingStatus)</li> <li>vls_128_laser_azimuth_cache_ (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#w","title":"w","text":"<ul> <li>web_page_version (nebula::drivers::robosense_packet::helios::InfoPacket)</li> <li>webpage_backup_crc (nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#y","title":"y","text":"<ul> <li>year (nebula::drivers::hesai_packet::DateTime, nebula::drivers::robosense_packet::bpearl_v3::Timestamp)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#z","title":"z","text":"<ul> <li>zero (nebula::drivers::hesai_packet::SecondsSinceEpoch)</li> <li>zero_angle_offset (nebula::drivers::robosense_packet::bpearl_v3::InfoPacket, nebula::drivers::robosense_packet::helios::InfoPacket)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"nebula_decoders/class_member_typedefs/#a","title":"a","text":"<ul> <li>angle_corrector_t (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/#b","title":"b","text":"<ul> <li>block_t (nebula::drivers::hesai_packet::Body, nebula::drivers::robosense_packet::Body)</li> <li>body_t (nebula::drivers::hesai_packet::Packet128E3X, nebula::drivers::hesai_packet::Packet40P, nebula::drivers::hesai_packet::Packet64, nebula::drivers::hesai_packet::PacketAT128E2X, nebula::drivers::hesai_packet::PacketQT128C2X, nebula::drivers::hesai_packet::PacketQT64, nebula::drivers::hesai_packet::PacketXT32, nebula::drivers::hesai_packet::PacketXT32M2X, nebula::drivers::robosense_packet::bpearl_v3::Packet, nebula::drivers::robosense_packet::bpearl_v4::Packet, nebula::drivers::robosense_packet::helios::Packet)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/#i","title":"i","text":"<ul> <li>info_t (nebula::drivers::RobosenseSensor)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/#p","title":"p","text":"<ul> <li>packet_t (nebula::drivers::HesaiSensor, nebula::drivers::RobosenseSensor)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/#u","title":"u","text":"<ul> <li>unit_t (nebula::drivers::hesai_packet::Block, nebula::drivers::hesai_packet::FineAzimuthBlock, nebula::drivers::hesai_packet::SOBBlock, nebula::drivers::robosense_packet::Block)</li> </ul>"},{"location":"nebula_decoders/class_member_enums/","title":"Class Member Enums","text":""},{"location":"nebula_decoders/class_member_enums/#o","title":"o","text":"<ul> <li>OperationalState (nebula::drivers::Pandar128E3X, nebula::drivers::Pandar128E4X)</li> </ul>"},{"location":"nebula_decoders/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_decoders/namespace_members/#a","title":"a","text":"<ul> <li>AngleCorrectionType (nebula::drivers)</li> <li>ANGLE_SIGN_FLAG (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#b","title":"b","text":"<ul> <li>BLOCKS_PER_PACKET (nebula::drivers)</li> <li>BLOCK_DATA_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#g","title":"g","text":"<ul> <li>get_dis_unit (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; Packet40P &gt; (nebula::drivers::hesai_packet)</li> <li>get_n_returns (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_timestamp_ns (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; bpearl_v3::Packet &gt; (nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; bpearl_v4::Packet &gt; (nebula::drivers::robosense_packet)</li> <li>get_float_value (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#l","title":"l","text":"<ul> <li>LOWER_BANK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#m","title":"m","text":"<ul> <li>MAX_POINTS (nebula::drivers::vlp16)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#p","title":"p","text":"<ul> <li>PACKET_SIZE (nebula::drivers)</li> <li>PACKET_STATUS_SIZE (nebula::drivers)</li> <li>Packet128E4X (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#r","title":"r","text":"<ul> <li>RAW_SCAN_SIZE (nebula::drivers)</li> <li>RETURN_MODE_DUAL (nebula::drivers)</li> <li>RETURN_MODE_INDEX (nebula::drivers)</li> <li>RETURN_MODE_LAST (nebula::drivers)</li> <li>RETURN_MODE_STRONGEST (nebula::drivers)</li> <li>RETURN_TYPE (nebula::drivers)</li> <li>ROTATION_MAX_UNITS (nebula::drivers)</li> <li>ROTATION_RESOLUTION (nebula::drivers)</li> <li>ReturnMode (nebula::drivers::hesai_packet::return_mode)</li> <li>raw_block_t (nebula::drivers)</li> <li>raw_packet_t (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#s","title":"s","text":"<ul> <li>SCANS_PER_BLOCK (nebula::drivers)</li> <li>SCANS_PER_PACKET (nebula::drivers)</li> <li>SIZE_BLOCK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#t","title":"t","text":"<ul> <li>Tail64 (nebula::drivers::hesai_packet)</li> <li>TailXT32M2X (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#u","title":"u","text":"<ul> <li>UPPER_BANK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#v","title":"v","text":"<ul> <li>VLP128_DISTANCE_RESOLUTION (nebula::drivers)</li> <li>VLP16_BLOCK_DURATION (nebula::drivers)</li> <li>VLP16_DSR_TOFFSET (nebula::drivers)</li> <li>VLP16_FIRINGS_PER_BLOCK (nebula::drivers)</li> <li>VLP16_FIRING_TOFFSET (nebula::drivers)</li> <li>VLP16_SCANS_PER_FIRING (nebula::drivers)</li> <li>VLS128_BANK_1 (nebula::drivers)</li> <li>VLS128_BANK_2 (nebula::drivers)</li> <li>VLS128_BANK_3 (nebula::drivers)</li> <li>VLS128_BANK_4 (nebula::drivers)</li> <li>VLS128_CHANNEL_DURATION (nebula::drivers)</li> <li>VLS128_SEQ_DURATION (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"nebula_decoders/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_dis_unit (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; Packet40P &gt; (nebula::drivers::hesai_packet)</li> <li>get_n_returns (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_timestamp_ns (nebula::drivers::hesai_packet, nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; bpearl_v3::Packet &gt; (nebula::drivers::robosense_packet)</li> <li>get_dis_unit&lt; bpearl_v4::Packet &gt; (nebula::drivers::robosense_packet)</li> <li>get_float_value (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_decoders/namespace_member_variables/#a","title":"a","text":"<ul> <li>ANGLE_SIGN_FLAG (nebula::drivers::robosense_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#b","title":"b","text":"<ul> <li>BLOCKS_PER_PACKET (nebula::drivers)</li> <li>BLOCK_DATA_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOWER_BANK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_POINTS (nebula::drivers::vlp16)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#p","title":"p","text":"<ul> <li>PACKET_SIZE (nebula::drivers)</li> <li>PACKET_STATUS_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#r","title":"r","text":"<ul> <li>RAW_SCAN_SIZE (nebula::drivers)</li> <li>RETURN_MODE_DUAL (nebula::drivers)</li> <li>RETURN_MODE_INDEX (nebula::drivers)</li> <li>RETURN_MODE_LAST (nebula::drivers)</li> <li>RETURN_MODE_STRONGEST (nebula::drivers)</li> <li>ROTATION_MAX_UNITS (nebula::drivers)</li> <li>ROTATION_RESOLUTION (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#s","title":"s","text":"<ul> <li>SCANS_PER_BLOCK (nebula::drivers)</li> <li>SCANS_PER_PACKET (nebula::drivers)</li> <li>SIZE_BLOCK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#u","title":"u","text":"<ul> <li>UPPER_BANK (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#v","title":"v","text":"<ul> <li>VLP128_DISTANCE_RESOLUTION (nebula::drivers)</li> <li>VLP16_BLOCK_DURATION (nebula::drivers)</li> <li>VLP16_DSR_TOFFSET (nebula::drivers)</li> <li>VLP16_FIRINGS_PER_BLOCK (nebula::drivers)</li> <li>VLP16_FIRING_TOFFSET (nebula::drivers)</li> <li>VLP16_SCANS_PER_FIRING (nebula::drivers)</li> <li>VLS128_BANK_1 (nebula::drivers)</li> <li>VLS128_BANK_2 (nebula::drivers)</li> <li>VLS128_BANK_3 (nebula::drivers)</li> <li>VLS128_BANK_4 (nebula::drivers)</li> <li>VLS128_CHANNEL_DURATION (nebula::drivers)</li> <li>VLS128_SEQ_DURATION (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"nebula_decoders/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>Packet128E4X (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>raw_block_t (nebula::drivers)</li> <li>raw_packet_t (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>Tail64 (nebula::drivers::hesai_packet)</li> <li>TailXT32M2X (nebula::drivers::hesai_packet)</li> </ul>"},{"location":"nebula_decoders/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"nebula_decoders/namespace_member_enums/#a","title":"a","text":"<ul> <li>AngleCorrectionType (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_enums/#r","title":"r","text":"<ul> <li>RETURN_TYPE (nebula::drivers)</li> <li>ReturnMode (nebula::drivers::hesai_packet::return_mode)</li> </ul>"},{"location":"nebula_decoders/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_decoders/macros/","title":"Macros","text":""},{"location":"nebula_decoders/macros/#_","title":"_","text":"<ul> <li>_ (angle_corrector_correction_based.hpp)</li> </ul>"},{"location":"nebula_decoders/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_decoders/links/","title":"Nebula Decoders","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_hw_interfaces/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO </li> <li>struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO </li> <li>struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR </li> <li>struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE </li> <li>struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS </li> <li>struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG </li> <li>struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>namespace drivers <ul> <li>class HesaiHwInterface Hardware interface of hesai driver. </li> <li>class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. </li> <li>class RobosenseHwInterface Hardware interface of Robosense driver. </li> <li>class VelodyneHwInterface Hardware interface of velodyne driver. </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_hw_interfaces <ul> <li>dir include <ul> <li>dir nebula_hw_interfaces <ul> <li>dir nebula_hw_interfaces_common <ul> <li>file nebula_hw_interface_base.hpp </li> </ul> </li> <li>dir nebula_hw_interfaces_hesai <ul> <li>file hesai_cmd_response.hpp </li> <li>file hesai_hw_interface.hpp </li> </ul> </li> <li>dir nebula_hw_interfaces_robosense <ul> <li>file robosense_hw_interface.hpp </li> </ul> </li> <li>dir nebula_hw_interfaces_velodyne <ul> <li>file velodyne_hw_interface.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_hw_interfaces/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers"},{"location":"nebula_hw_interfaces/namespacenebula/#classes","title":"Classes","text":"Type Name struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/","title":"Struct nebula::HesaiConfig","text":"<p>ClassList &gt; nebula &gt; HesaiConfig</p> <p>struct of PTC_COMMAND_GET_CONFIG_INFO </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#public-attributes","title":"Public Attributes","text":"Type Name int clock_data_fmt int clock_source int dest_LiDAR_udp_port int dest_gps_udp_port int dest_ipaddr int gateway int ipaddr int mask int motor_status int noise_filtering int reflectivity_mapping unsigned char reserved int return_mode int spin_rate int standby_mode int start_angle int stop_angle int sync int sync_angle int trigger_method int udp_seq int vlan_flag int vlan_id"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-clock_data_fmt","title":"variable clock_data_fmt","text":"<pre><code>int nebula::HesaiConfig::clock_data_fmt;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-clock_source","title":"variable clock_source","text":"<pre><code>int nebula::HesaiConfig::clock_source;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_lidar_udp_port","title":"variable dest_LiDAR_udp_port","text":"<pre><code>int nebula::HesaiConfig::dest_LiDAR_udp_port;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_gps_udp_port","title":"variable dest_gps_udp_port","text":"<pre><code>int nebula::HesaiConfig::dest_gps_udp_port;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_ipaddr","title":"variable dest_ipaddr","text":"<pre><code>int nebula::HesaiConfig::dest_ipaddr[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-gateway","title":"variable gateway","text":"<pre><code>int nebula::HesaiConfig::gateway[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-ipaddr","title":"variable ipaddr","text":"<pre><code>int nebula::HesaiConfig::ipaddr[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-mask","title":"variable mask","text":"<pre><code>int nebula::HesaiConfig::mask[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-motor_status","title":"variable motor_status","text":"<pre><code>int nebula::HesaiConfig::motor_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-noise_filtering","title":"variable noise_filtering","text":"<pre><code>int nebula::HesaiConfig::noise_filtering;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-reflectivity_mapping","title":"variable reflectivity_mapping","text":"<pre><code>int nebula::HesaiConfig::reflectivity_mapping;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-reserved","title":"variable reserved","text":"<pre><code>unsigned char nebula::HesaiConfig::reserved[6];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-return_mode","title":"variable return_mode","text":"<pre><code>int nebula::HesaiConfig::return_mode;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-spin_rate","title":"variable spin_rate","text":"<pre><code>int nebula::HesaiConfig::spin_rate;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-standby_mode","title":"variable standby_mode","text":"<pre><code>int nebula::HesaiConfig::standby_mode;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-start_angle","title":"variable start_angle","text":"<pre><code>int nebula::HesaiConfig::start_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-stop_angle","title":"variable stop_angle","text":"<pre><code>int nebula::HesaiConfig::stop_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-sync","title":"variable sync","text":"<pre><code>int nebula::HesaiConfig::sync;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-sync_angle","title":"variable sync_angle","text":"<pre><code>int nebula::HesaiConfig::sync_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-trigger_method","title":"variable trigger_method","text":"<pre><code>int nebula::HesaiConfig::trigger_method;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-udp_seq","title":"variable udp_seq","text":"<pre><code>int nebula::HesaiConfig::udp_seq;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-vlan_flag","title":"variable vlan_flag","text":"<pre><code>int nebula::HesaiConfig::vlan_flag;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-vlan_id","title":"variable vlan_id","text":"<pre><code>int nebula::HesaiConfig::vlan_id;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiConfig::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiConfig const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/","title":"Struct nebula::HesaiInventory","text":"<p>ClassList &gt; nebula &gt; HesaiInventory</p> <p>struct of PTC_COMMAND_GET_INVENTORY_INFO </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-attributes","title":"Public Attributes","text":"Type Name int angle_offset std::vector&lt; char &gt; control_fw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; date_of_manufacture   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; hw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; mac   = = std::vector&lt;char&gt;(6) int model int motor_type int num_of_lines std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(11) std::vector&lt; char &gt; sensor_fw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; sn   = = std::vector&lt;char&gt;(18) std::vector&lt; char &gt; sw_ver   = = std::vector&lt;char&gt;(16)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-functions","title":"Public Functions","text":"Type Name HesaiInventory ()  HesaiInventory (const HesaiInventory &amp; arg)  std::string get_str_model ()"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-angle_offset","title":"variable angle_offset","text":"<pre><code>int nebula::HesaiInventory::angle_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-control_fw_ver","title":"variable control_fw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::control_fw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-date_of_manufacture","title":"variable date_of_manufacture","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::date_of_manufacture;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-hw_ver","title":"variable hw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::hw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-mac","title":"variable mac","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::mac;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-model","title":"variable model","text":"<pre><code>int nebula::HesaiInventory::model;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-motor_type","title":"variable motor_type","text":"<pre><code>int nebula::HesaiInventory::motor_type;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-num_of_lines","title":"variable num_of_lines","text":"<pre><code>int nebula::HesaiInventory::num_of_lines;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiInventory::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sensor_fw_ver","title":"variable sensor_fw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sensor_fw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sn","title":"variable sn","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sn;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sw_ver","title":"variable sw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-hesaiinventory-12","title":"function HesaiInventory [1/2]","text":"<pre><code>inline nebula::HesaiInventory::HesaiInventory () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-hesaiinventory-22","title":"function HesaiInventory [2/2]","text":"<pre><code>inline nebula::HesaiInventory::HesaiInventory (\n    const HesaiInventory &amp; arg\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-get_str_model","title":"function get_str_model","text":"<pre><code>inline std::string nebula::HesaiInventory::get_str_model () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiInventory::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiInventory const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/","title":"Struct nebula::HesaiLidarMonitor","text":"<p>ClassList &gt; nebula &gt; HesaiLidarMonitor</p> <p>struct of PTC_COMMAND_LIDAR_MONITOR </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#public-attributes","title":"Public Attributes","text":"Type Name int input_current int input_power int input_voltage std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(52)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_current","title":"variable input_current","text":"<pre><code>int nebula::HesaiLidarMonitor::input_current;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_power","title":"variable input_power","text":"<pre><code>int nebula::HesaiLidarMonitor::input_power;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_voltage","title":"variable input_voltage","text":"<pre><code>int nebula::HesaiLidarMonitor::input_voltage;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiLidarMonitor::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarMonitor::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiLidarMonitor const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/","title":"Struct nebula::HesaiLidarRangeAll","text":"<p>ClassList &gt; nebula &gt; HesaiLidarRangeAll</p> <p>struct of PTC_COMMAND_GET_LIDAR_RANGE </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#public-attributes","title":"Public Attributes","text":"Type Name int end int method int start"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-end","title":"variable end","text":"<pre><code>int nebula::HesaiLidarRangeAll::end;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-method","title":"variable method","text":"<pre><code>int nebula::HesaiLidarRangeAll::method;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-start","title":"variable start","text":"<pre><code>int nebula::HesaiLidarRangeAll::start;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarRangeAll::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiLidarRangeAll const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/","title":"Struct nebula::HesaiLidarStatus","text":"<p>ClassList &gt; nebula &gt; HesaiLidarStatus</p> <p>struct of PTC_COMMAND_GET_LIDAR_STATUS </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-attributes","title":"Public Attributes","text":"Type Name int gps_gprmc_status int gps_pps_lock int motor_speed int ptp_clock_status std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(5) int startup_times int system_uptime std::vector&lt; int &gt; temperature   = = std::vector&lt;int&gt;(8) int total_operation_time"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-functions","title":"Public Functions","text":"Type Name HesaiLidarStatus ()  HesaiLidarStatus (const HesaiLidarStatus &amp; arg)  std::string get_str_gps_gprmc_status ()  std::string get_str_gps_pps_lock ()  std::string get_str_ptp_clock_status ()"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-gps_gprmc_status","title":"variable gps_gprmc_status","text":"<pre><code>int nebula::HesaiLidarStatus::gps_gprmc_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-gps_pps_lock","title":"variable gps_pps_lock","text":"<pre><code>int nebula::HesaiLidarStatus::gps_pps_lock;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>int nebula::HesaiLidarStatus::motor_speed;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-ptp_clock_status","title":"variable ptp_clock_status","text":"<pre><code>int nebula::HesaiLidarStatus::ptp_clock_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiLidarStatus::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-startup_times","title":"variable startup_times","text":"<pre><code>int nebula::HesaiLidarStatus::startup_times;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-system_uptime","title":"variable system_uptime","text":"<pre><code>int nebula::HesaiLidarStatus::system_uptime;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-temperature","title":"variable temperature","text":"<pre><code>std::vector&lt;int&gt; nebula::HesaiLidarStatus::temperature;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-total_operation_time","title":"variable total_operation_time","text":"<pre><code>int nebula::HesaiLidarStatus::total_operation_time;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-hesailidarstatus-12","title":"function HesaiLidarStatus [1/2]","text":"<pre><code>inline nebula::HesaiLidarStatus::HesaiLidarStatus () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-hesailidarstatus-22","title":"function HesaiLidarStatus [2/2]","text":"<pre><code>inline nebula::HesaiLidarStatus::HesaiLidarStatus (\n    const HesaiLidarStatus &amp; arg\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_gps_gprmc_status","title":"function get_str_gps_gprmc_status","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_gps_gprmc_status () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_gps_pps_lock","title":"function get_str_gps_pps_lock","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_gps_pps_lock () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_ptp_clock_status","title":"function get_str_ptp_clock_status","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_ptp_clock_status () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarStatus::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiLidarStatus const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/","title":"Struct nebula::HesaiPtpConfig","text":"<p>ClassList &gt; nebula &gt; HesaiPtpConfig</p> <p>struct of PTC_COMMAND_GET_PTP_CONFIG </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#public-attributes","title":"Public Attributes","text":"Type Name int domain int logAnnounceInterval int logMinDelayReqInterval int logSyncInterval int network int profile int status"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-domain","title":"variable domain","text":"<pre><code>int nebula::HesaiPtpConfig::domain;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logannounceinterval","title":"variable logAnnounceInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logAnnounceInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logmindelayreqinterval","title":"variable logMinDelayReqInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logMinDelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logsyncinterval","title":"variable logSyncInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logSyncInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-network","title":"variable network","text":"<pre><code>int nebula::HesaiPtpConfig::network;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-profile","title":"variable profile","text":"<pre><code>int nebula::HesaiPtpConfig::profile;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-status","title":"variable status","text":"<pre><code>int nebula::HesaiPtpConfig::status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpConfig::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiPtpConfig const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/","title":"Struct nebula::HesaiPtpDiagGrandmaster","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagGrandmaster</p> <p>LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#public-attributes","title":"Public Attributes","text":"Type Name int clockQuality int time_flags int time_source int utc_offset"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-clockquality","title":"variable clockQuality","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::clockQuality;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-time_flags","title":"variable time_flags","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::time_flags;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-time_source","title":"variable time_source","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::time_source;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-utc_offset","title":"variable utc_offset","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::utc_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagGrandmaster::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiPtpDiagGrandmaster const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/","title":"Struct nebula::HesaiPtpDiagPort","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagPort</p> <p>PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-attributes","title":"Public Attributes","text":"Type Name int announceReceiptTimeout int delayMechanism int logAnnounceInterval int logMinDelayReqInterval int logMinPdelayReqInterval int logSyncInterval long long peerMeanPathDelay std::vector&lt; char &gt; portIdentity   = = std::vector&lt;char&gt;(10) int portState int versionNumber"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-functions","title":"Public Functions","text":"Type Name HesaiPtpDiagPort ()  HesaiPtpDiagPort (const HesaiPtpDiagPort &amp; arg)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-announcereceipttimeout","title":"variable announceReceiptTimeout","text":"<pre><code>int nebula::HesaiPtpDiagPort::announceReceiptTimeout;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-delaymechanism","title":"variable delayMechanism","text":"<pre><code>int nebula::HesaiPtpDiagPort::delayMechanism;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logannounceinterval","title":"variable logAnnounceInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logAnnounceInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logmindelayreqinterval","title":"variable logMinDelayReqInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logMinDelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logminpdelayreqinterval","title":"variable logMinPdelayReqInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logMinPdelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logsyncinterval","title":"variable logSyncInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logSyncInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-peermeanpathdelay","title":"variable peerMeanPathDelay","text":"<pre><code>long long nebula::HesaiPtpDiagPort::peerMeanPathDelay;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-portidentity","title":"variable portIdentity","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiPtpDiagPort::portIdentity;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-portstate","title":"variable portState","text":"<pre><code>int nebula::HesaiPtpDiagPort::portState;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-versionnumber","title":"variable versionNumber","text":"<pre><code>int nebula::HesaiPtpDiagPort::versionNumber;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#function-hesaiptpdiagport-12","title":"function HesaiPtpDiagPort [1/2]","text":"<pre><code>inline nebula::HesaiPtpDiagPort::HesaiPtpDiagPort () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#function-hesaiptpdiagport-22","title":"function HesaiPtpDiagPort [2/2]","text":"<pre><code>inline nebula::HesaiPtpDiagPort::HesaiPtpDiagPort (\n    const HesaiPtpDiagPort &amp; arg\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagPort::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiPtpDiagPort const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/","title":"Struct nebula::HesaiPtpDiagStatus","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagStatus</p> <p>PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#public-attributes","title":"Public Attributes","text":"Type Name int elapsed_millisec long long master_offset int ptp_state"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-elapsed_millisec","title":"variable elapsed_millisec","text":"<pre><code>int nebula::HesaiPtpDiagStatus::elapsed_millisec;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-master_offset","title":"variable master_offset","text":"<pre><code>long long nebula::HesaiPtpDiagStatus::master_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-ptp_state","title":"variable ptp_state","text":"<pre><code>int nebula::HesaiPtpDiagStatus::ptp_state;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagStatus::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiPtpDiagStatus const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/","title":"Struct nebula::HesaiPtpDiagTime","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagTime</p> <p>LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-attributes","title":"Public Attributes","text":"Type Name int cumulativeScaledRateOffset long long gmIdentity int gmPresent int gmTimeBaseIndicator long long ingress_time std::vector&lt; char &gt; lastGmPhaseChange   = = std::vector&lt;char&gt;(12) long long master_offset int scaledLastGmPhaseChange"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-functions","title":"Public Functions","text":"Type Name HesaiPtpDiagTime ()  HesaiPtpDiagTime (const HesaiPtpDiagTime &amp; arg)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-cumulativescaledrateoffset","title":"variable cumulativeScaledRateOffset","text":"<pre><code>int nebula::HesaiPtpDiagTime::cumulativeScaledRateOffset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmidentity","title":"variable gmIdentity","text":"<pre><code>long long nebula::HesaiPtpDiagTime::gmIdentity;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmpresent","title":"variable gmPresent","text":"<pre><code>int nebula::HesaiPtpDiagTime::gmPresent;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmtimebaseindicator","title":"variable gmTimeBaseIndicator","text":"<pre><code>int nebula::HesaiPtpDiagTime::gmTimeBaseIndicator;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-ingress_time","title":"variable ingress_time","text":"<pre><code>long long nebula::HesaiPtpDiagTime::ingress_time;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-lastgmphasechange","title":"variable lastGmPhaseChange","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiPtpDiagTime::lastGmPhaseChange;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-master_offset","title":"variable master_offset","text":"<pre><code>long long nebula::HesaiPtpDiagTime::master_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-scaledlastgmphasechange","title":"variable scaledLastGmPhaseChange","text":"<pre><code>int nebula::HesaiPtpDiagTime::scaledLastGmPhaseChange;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#function-hesaiptpdiagtime-12","title":"function HesaiPtpDiagTime [1/2]","text":"<pre><code>inline nebula::HesaiPtpDiagTime::HesaiPtpDiagTime () \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#function-hesaiptpdiagtime-22","title":"function HesaiPtpDiagTime [2/2]","text":"<pre><code>inline nebula::HesaiPtpDiagTime::HesaiPtpDiagTime (\n    const HesaiPtpDiagTime &amp; arg\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagTime::operator&lt;&lt; (\n    std::ostream &amp; os,\n    nebula::HesaiPtpDiagTime const &amp; arg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name class HesaiHwInterface Hardware interface of hesai driver. class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. class RobosenseHwInterface Hardware interface of Robosense driver. class VelodyneHwInterface Hardware interface of velodyne driver."},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint16_t BPEARL_INFO_PACKET_SIZE   = = 1248 constexpr uint16_t BPEARL_PACKET_SIZE   = = 1248 constexpr uint16_t HELIOS_INFO_PACKET_SIZE   = = 1248 constexpr uint16_t HELIOS_PACKET_SIZE   = = 1248 const int HESAI_LIDAR_GPS_CLOCK_SOURCE   = = 0 const int HESAI_LIDAR_PTP_CLOCK_SOURCE   = = 1 const uint16_t MTU_SIZE   = = 1500 const uint16_t PANDAR128_E4X_EXTENDED_PACKET_SIZE   = = 1117 const uint16_t PANDAR128_E4X_PACKET_SIZE   = = 861 const uint16_t PANDAR40P_EXTENDED_PACKET_SIZE   = = 1266 const uint16_t PANDAR40_PACKET_SIZE   = = 1262 const uint16_t PANDAR64_EXTENDED_PACKET_SIZE   = = 1198 const uint16_t PANDAR64_PACKET_SIZE   = = 1194 const uint16_t PANDARAT128_PACKET_SIZE   = = 1118 const uint16_t PANDARQT128_PACKET_SIZE   = = 1127 const uint16_t PANDARQT64_PACKET_SIZE   = = 1072 const uint16_t PANDARXT32M_PACKET_SIZE   = = 820 const uint16_t PANDARXT32_PACKET_SIZE   = = 1080 const uint8_t PTC_COMMAND_DUMMY_BYTE   = = 0x00 const uint8_t PTC_COMMAND_GET_CONFIG_INFO   = = 0x08 const uint8_t PTC_COMMAND_GET_INVENTORY_INFO   = = 0x07 const uint8_t PTC_COMMAND_GET_LIDAR_CALIBRATION   = = 0x05 const uint8_t PTC_COMMAND_GET_LIDAR_RANGE   = = 0x23 const uint8_t PTC_COMMAND_GET_LIDAR_STATUS   = = 0x09 const uint8_t PTC_COMMAND_GET_PTP_CONFIG   = = 0x26 const uint8_t PTC_COMMAND_HEADER_HIGH   = = 0x47 const uint8_t PTC_COMMAND_HEADER_LOW   = = 0x74 const uint8_t PTC_COMMAND_LIDAR_MONITOR   = = 0x27 const uint8_t PTC_COMMAND_PTP_DIAGNOSTICS   = = 0x06 const uint8_t PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP   = = 0x04 const uint8_t PTC_COMMAND_PTP_PORT_DATA_SET   = = 0x02 const uint8_t PTC_COMMAND_PTP_STATUS   = = 0x01 const uint8_t PTC_COMMAND_PTP_TIME_STATUS_NP   = = 0x03 const uint8_t PTC_COMMAND_RESET   = = 0x25 const uint8_t PTC_COMMAND_SET_CLOCK_SOURCE   = = 0x1f const uint8_t PTC_COMMAND_SET_CONTROL_PORT   = = 0x21 const uint8_t PTC_COMMAND_SET_DESTINATION_IP   = = 0x20 const uint8_t PTC_COMMAND_SET_LIDAR_RANGE   = = 0x22 const uint8_t PTC_COMMAND_SET_PTP_CONFIG   = = 0x24 const uint8_t PTC_COMMAND_SET_RETURN_MODE   = = 0x1e const uint8_t PTC_COMMAND_SET_ROTATE_DIRECTION   = = 0x2a const uint8_t PTC_COMMAND_SET_SPIN_RATE   = = 0x17 const uint8_t PTC_COMMAND_SET_STANDBY_MODE   = = 0x1c const uint8_t PTC_COMMAND_SET_SYNC_ANGLE   = = 0x18 const uint8_t PTC_COMMAND_SET_TRIGGER_METHOD   = = 0x1b const int PTP_LOG_ANNOUNCE_INTERVAL   = = 1 const int PTP_LOG_MIN_DELAY_INTERVAL   = = 0 const int PTP_SYNC_INTERVAL   = = 1 const int PandarTcpCommandPort   = = 9347"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-bpearl_info_packet_size","title":"variable BPEARL_INFO_PACKET_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::BPEARL_INFO_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-bpearl_packet_size","title":"variable BPEARL_PACKET_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::BPEARL_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-helios_info_packet_size","title":"variable HELIOS_INFO_PACKET_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::HELIOS_INFO_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-helios_packet_size","title":"variable HELIOS_PACKET_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::HELIOS_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-hesai_lidar_gps_clock_source","title":"variable HESAI_LIDAR_GPS_CLOCK_SOURCE","text":"<pre><code>const int nebula::drivers::HESAI_LIDAR_GPS_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-hesai_lidar_ptp_clock_source","title":"variable HESAI_LIDAR_PTP_CLOCK_SOURCE","text":"<pre><code>const int nebula::drivers::HESAI_LIDAR_PTP_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-mtu_size","title":"variable MTU_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::MTU_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar128_e4x_extended_packet_size","title":"variable PANDAR128_E4X_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR128_E4X_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar128_e4x_packet_size","title":"variable PANDAR128_E4X_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR128_E4X_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar40p_extended_packet_size","title":"variable PANDAR40P_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR40P_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar40_packet_size","title":"variable PANDAR40_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR40_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar64_extended_packet_size","title":"variable PANDAR64_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR64_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar64_packet_size","title":"variable PANDAR64_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR64_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarat128_packet_size","title":"variable PANDARAT128_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARAT128_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarqt128_packet_size","title":"variable PANDARQT128_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARQT128_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarqt64_packet_size","title":"variable PANDARQT64_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARQT64_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarxt32m_packet_size","title":"variable PANDARXT32M_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARXT32M_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarxt32_packet_size","title":"variable PANDARXT32_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARXT32_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_dummy_byte","title":"variable PTC_COMMAND_DUMMY_BYTE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_DUMMY_BYTE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_config_info","title":"variable PTC_COMMAND_GET_CONFIG_INFO","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_CONFIG_INFO;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_inventory_info","title":"variable PTC_COMMAND_GET_INVENTORY_INFO","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_INVENTORY_INFO;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_calibration","title":"variable PTC_COMMAND_GET_LIDAR_CALIBRATION","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_CALIBRATION;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_range","title":"variable PTC_COMMAND_GET_LIDAR_RANGE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_RANGE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_status","title":"variable PTC_COMMAND_GET_LIDAR_STATUS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_STATUS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_ptp_config","title":"variable PTC_COMMAND_GET_PTP_CONFIG","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_PTP_CONFIG;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_header_high","title":"variable PTC_COMMAND_HEADER_HIGH","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_HEADER_HIGH;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_header_low","title":"variable PTC_COMMAND_HEADER_LOW","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_HEADER_LOW;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_lidar_monitor","title":"variable PTC_COMMAND_LIDAR_MONITOR","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_LIDAR_MONITOR;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_diagnostics","title":"variable PTC_COMMAND_PTP_DIAGNOSTICS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_DIAGNOSTICS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_grandmaster_settings_np","title":"variable PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_port_data_set","title":"variable PTC_COMMAND_PTP_PORT_DATA_SET","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_PORT_DATA_SET;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_status","title":"variable PTC_COMMAND_PTP_STATUS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_STATUS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_time_status_np","title":"variable PTC_COMMAND_PTP_TIME_STATUS_NP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_TIME_STATUS_NP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_reset","title":"variable PTC_COMMAND_RESET","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_RESET;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_clock_source","title":"variable PTC_COMMAND_SET_CLOCK_SOURCE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_control_port","title":"variable PTC_COMMAND_SET_CONTROL_PORT","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_CONTROL_PORT;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_destination_ip","title":"variable PTC_COMMAND_SET_DESTINATION_IP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_DESTINATION_IP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_lidar_range","title":"variable PTC_COMMAND_SET_LIDAR_RANGE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_LIDAR_RANGE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_ptp_config","title":"variable PTC_COMMAND_SET_PTP_CONFIG","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_PTP_CONFIG;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_return_mode","title":"variable PTC_COMMAND_SET_RETURN_MODE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_RETURN_MODE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_rotate_direction","title":"variable PTC_COMMAND_SET_ROTATE_DIRECTION","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_ROTATE_DIRECTION;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_spin_rate","title":"variable PTC_COMMAND_SET_SPIN_RATE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_SPIN_RATE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_standby_mode","title":"variable PTC_COMMAND_SET_STANDBY_MODE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_STANDBY_MODE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_sync_angle","title":"variable PTC_COMMAND_SET_SYNC_ANGLE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_SYNC_ANGLE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_trigger_method","title":"variable PTC_COMMAND_SET_TRIGGER_METHOD","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_TRIGGER_METHOD;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_log_announce_interval","title":"variable PTP_LOG_ANNOUNCE_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_LOG_ANNOUNCE_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_log_min_delay_interval","title":"variable PTP_LOG_MIN_DELAY_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_LOG_MIN_DELAY_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_sync_interval","title":"variable PTP_SYNC_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_SYNC_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandartcpcommandport","title":"variable PandarTcpCommandPort","text":"<pre><code>const int nebula::drivers::PandarTcpCommandPort;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/","title":"Class nebula::drivers::HesaiHwInterface","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiHwInterface</p> <p>Hardware interface of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_interface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaHwInterfaceBase</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions","title":"Public Functions","text":"Type Name HesaiStatus CheckAndSetConfig (std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration, HesaiConfig hesai_config) Checking the current settings and changing the difference point. HesaiStatus CheckAndSetConfig (std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration, HesaiLidarRangeAll hesai_lidar_range_all) Checking the current settings and changing the difference point. HesaiStatus CheckAndSetConfig () Checking the current settings and changing the difference point. virtual Status CloudInterfaceStart () Starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () Function for stopping the interface that handles UDP streams. Status FinalizeTcpDriver () Closes the TcpDriver and related resources. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) Printing calibration configuration. Status GetConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. std::shared_ptr&lt; boost::asio::io_context &gt; GetIOContext () GetIO Context. Status GetInventory (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarMonitor (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true)  Status GetLidarMonitor (bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. HesaiStatus GetLidarMonitorAsyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting lidar_monitor via HTTP API. HesaiStatus GetLidarMonitorAsyncHttp (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting lidar_monitor via HTTP API. Status GetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarStatus (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetPtpConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpConfig (bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpDiagGrandmaster (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagGrandmaster (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagGrandmaster (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagPort (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagPort (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagPort (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagStatus (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagStatus (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagTime (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) Status GetPtpDiagTime (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) Status GetPtpDiagTime (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) Printing sensor configuration. HesaiHwInterface () Constructor. void IOContextRun () Call run() of IO Context. Status InitializeTcpDriver (bool setup_sensor=true) Initializing tcp_driver for TCP communication. int NebulaModelToHesaiModelNo (nebula::drivers::SensorModel model) Convert to model in Hesai protocol from nebula::drivers::SensorModel. boost::property_tree::ptree ParseJson (const std::string &amp; str) Parsing json string to property_tree. virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Cloud Packet data from the UDP Driver. Status RegisterScanCallback (std::function&lt; void(std::unique_ptr&lt; pandar_msgs::msg::PandarScan &gt;)&gt; scan_callback) Registering callback for PandarScan. Status SendReset (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SendReset (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SendReset (bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SetClockSource (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int clock_source, bool with_run)  Status SetClockSource (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int clock_source, bool with_run)  Status SetClockSource (int clock_source, bool with_run=true)  Status SetControlPort (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetControlPort (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetControlPort (int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetDestinationIp (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetDestinationIp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetDestinationIp (int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. void SetLogger (std::shared_ptr&lt; rclcpp::Logger &gt; node) Setting rclcpp::Logger. Status SetPtpConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. Status SetPtpConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. Status SetPtpConfig (int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. HesaiStatus SetPtpConfigSyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval)  HesaiStatus SetPtpConfigSyncHttp (int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval)  Status SetReturnMode (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetReturnMode (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetReturnMode (int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetRotDir (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. Status SetRotDir (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. Status SetRotDir (int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Setting sensor configuration. Status SetSpinRate (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. Status SetSpinRate (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. Status SetSpinRate (uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. HesaiStatus SetSpinSpeedAsyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, uint16_t rpm) Setting spin_speed via HTTP API. HesaiStatus SetSpinSpeedAsyncHttp (uint16_t rpm) Setting spin_speed via HTTP API. Status SetStandbyMode (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetStandbyMode (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetStandbyMode (int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetSyncAngle (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. Status SetSyncAngle (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. Status SetSyncAngle (int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. HesaiStatus SetSyncAngleSyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int enable, int angle)  HesaiStatus SetSyncAngleSyncHttp (int enable, int angle)  void SetTargetModel (int model) Set target model number (for proper use of HTTP and TCP according to the support of the target model) void SetTargetModel (nebula::drivers::SensorModel model) Set target model number (for proper use of HTTP and TCP according to the support of the target model) Status SetTriggerMethod (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. Status SetTriggerMethod (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. Status SetTriggerMethod (int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. bool UseHttpGetLidarMonitor (int model) Whether to use HTTP for getting LidarMonitor. bool UseHttpGetLidarMonitor () Whether to use HTTP for getting LidarMonitor. bool UseHttpSetSpinRate (int model) Whether to use HTTP for setting SpinRate. bool UseHttpSetSpinRate () Whether to use HTTP for setting SpinRate. Status syncGetInventory (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiInventory &amp;result)&gt; callback) Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) Status syncGetInventory (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver) Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) Status syncGetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiInventory &amp;result)&gt; callback) Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) Status syncGetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetInventory (std::function&lt; void(HesaiInventory &amp;result)&gt; callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor (std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor () Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) ~HesaiHwInterface () Destructor."},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Public Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#protected-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Protected Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-13","title":"function CheckAndSetConfig [1/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig (\n    std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration,\n    HesaiConfig hesai_config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Current SensorConfiguration </li> <li><code>hesai_config</code> Current HesaiConfig </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-23","title":"function CheckAndSetConfig [2/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig (\n    std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration,\n    HesaiLidarRangeAll hesai_lidar_range_all\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Current SensorConfiguration </li> <li><code>hesai_lidar_range_all</code> Current HesaiLidarRangeAll </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-33","title":"function CheckAndSetConfig [3/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::CloudInterfaceStart () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::CloudInterfaceStop () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-finalizetcpdriver","title":"function FinalizeTcpDriver","text":"<p>Closes the TcpDriver and related resources. <pre><code>Status nebula::drivers::HesaiHwInterface::FinalizeTcpDriver () \n</code></pre></p> <p>Returns:</p> <p>Status result </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Printing calibration configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::GetCalibrationConfiguration (\n    CalibrationConfigurationBase &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-15","title":"function GetConfig [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiConfig &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-25","title":"function GetConfig [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiConfig &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-35","title":"function GetConfig [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-45","title":"function GetConfig [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\n    std::function&lt; void( HesaiConfig &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-55","title":"function GetConfig [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getiocontext","title":"function GetIOContext","text":"<p>GetIO Context. <pre><code>std::shared_ptr&lt; boost::asio::io_context &gt; nebula::drivers::HesaiHwInterface::GetIOContext () \n</code></pre></p> <p>Returns:</p> <p>IO Context </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-15","title":"function GetInventory [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-25","title":"function GetInventory [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-35","title":"function GetInventory [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-45","title":"function GetInventory [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-55","title":"function GetInventory [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-15","title":"function GetLidarCalibration [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-25","title":"function GetLidarCalibration [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>bytes_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-35","title":"function GetLidarCalibration [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-45","title":"function GetLidarCalibration [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-55","title":"function GetLidarCalibration [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-13","title":"function GetLidarCalibrationFromSensor [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\n    std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-23","title":"function GetLidarCalibrationFromSensor [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>bytes_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-33","title":"function GetLidarCalibrationFromSensor [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>str_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-15","title":"function GetLidarMonitor [1/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarMonitor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-25","title":"function GetLidarMonitor [2/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarMonitor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-35","title":"function GetLidarMonitor [3/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-45","title":"function GetLidarMonitor [4/5]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\n    std::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-55","title":"function GetLidarMonitor [5/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitorasynchttp-12","title":"function GetLidarMonitorAsyncHttp [1/2]","text":"<p>Getting lidar_monitor via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::GetLidarMonitorAsyncHttp (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context </li> <li><code>str_callback</code> Callback function for received string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitorasynchttp-22","title":"function GetLidarMonitorAsyncHttp [2/2]","text":"<p>Getting lidar_monitor via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::GetLidarMonitorAsyncHttp (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-15","title":"function GetLidarRange [1/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-25","title":"function GetLidarRange [2/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-35","title":"function GetLidarRange [3/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-45","title":"function GetLidarRange [4/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\n    std::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-55","title":"function GetLidarRange [5/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-15","title":"function GetLidarStatus [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-25","title":"function GetLidarStatus [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-35","title":"function GetLidarStatus [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-45","title":"function GetLidarStatus [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\n    std::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-55","title":"function GetLidarStatus [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-13","title":"function GetPtpConfig [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-23","title":"function GetPtpConfig [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-33","title":"function GetPtpConfig [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-13","title":"function GetPtpDiagGrandmaster [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-23","title":"function GetPtpDiagGrandmaster [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-33","title":"function GetPtpDiagGrandmaster [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-13","title":"function GetPtpDiagPort [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-23","title":"function GetPtpDiagPort [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-33","title":"function GetPtpDiagPort [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-13","title":"function GetPtpDiagStatus [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-23","title":"function GetPtpDiagStatus [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-33","title":"function GetPtpDiagStatus [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-13","title":"function GetPtpDiagTime [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-23","title":"function GetPtpDiagTime [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-33","title":"function GetPtpDiagTime [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Printing sensor configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::GetSensorConfiguration (\n    SensorConfigurationBase &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-hesaihwinterface","title":"function HesaiHwInterface","text":"<pre><code>nebula::drivers::HesaiHwInterface::HesaiHwInterface () \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-iocontextrun","title":"function IOContextRun","text":"<pre><code>void nebula::drivers::HesaiHwInterface::IOContextRun () \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-initializetcpdriver","title":"function InitializeTcpDriver","text":"<p>Initializing tcp_driver for TCP communication. <pre><code>Status nebula::drivers::HesaiHwInterface::InitializeTcpDriver (\n    bool setup_sensor=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>setup_sensor</code> Whether to also initialize tcp_driver for sensor configuration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-nebulamodeltohesaimodelno","title":"function NebulaModelToHesaiModelNo","text":"<p>Convert to model in Hesai protocol from nebula::drivers::SensorModel. <pre><code>int nebula::drivers::HesaiHwInterface::NebulaModelToHesaiModelNo (\n    nebula::drivers::SensorModel model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> </li> </ul> <p>Returns:</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-parsejson","title":"function ParseJson","text":"<p>Parsing json string to property_tree. <pre><code>boost::property_tree::ptree nebula::drivers::HesaiHwInterface::ParseJson (\n    const std::string &amp; str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> JSON string </li> </ul> <p>Returns:</p> <p>Parsed property_tree </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<p>Callback function to receive the Cloud Packet data from the UDP Driver. <pre><code>virtual void nebula::drivers::HesaiHwInterface::ReceiveCloudPacketCallback (\n    const std::vector&lt; uint8_t &gt; &amp; buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Implements nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-registerscancallback","title":"function RegisterScanCallback","text":"<p>Registering callback for PandarScan. <pre><code>Status nebula::drivers::HesaiHwInterface::RegisterScanCallback (\n    std::function&lt; void(std::unique_ptr&lt; pandar_msgs::msg::PandarScan &gt;)&gt; scan_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-13","title":"function SendReset [1/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-23","title":"function SendReset [2/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-33","title":"function SendReset [3/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-13","title":"function SetClockSource [1/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int clock_source,\n    bool with_run\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-23","title":"function SetClockSource [2/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int clock_source,\n    bool with_run\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-33","title":"function SetClockSource [3/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\n    int clock_source,\n    bool with_run=true\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-13","title":"function SetControlPort [1/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int ip_1,\n    int ip_2,\n    int ip_3,\n    int ip_4,\n    int mask_1,\n    int mask_2,\n    int mask_3,\n    int mask_4,\n    int gateway_1,\n    int gateway_2,\n    int gateway_3,\n    int gateway_4,\n    int vlan_flg,\n    int vlan_id,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-23","title":"function SetControlPort [2/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int ip_1,\n    int ip_2,\n    int ip_3,\n    int ip_4,\n    int mask_1,\n    int mask_2,\n    int mask_3,\n    int mask_4,\n    int gateway_1,\n    int gateway_2,\n    int gateway_3,\n    int gateway_4,\n    int vlan_flg,\n    int vlan_id,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-33","title":"function SetControlPort [3/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\n    int ip_1,\n    int ip_2,\n    int ip_3,\n    int ip_4,\n    int mask_1,\n    int mask_2,\n    int mask_3,\n    int mask_4,\n    int gateway_1,\n    int gateway_2,\n    int gateway_3,\n    int gateway_4,\n    int vlan_flg,\n    int vlan_id,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-13","title":"function SetDestinationIp [1/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int dest_ip_1,\n    int dest_ip_2,\n    int dest_ip_3,\n    int dest_ip_4,\n    int port,\n    int gps_port,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-23","title":"function SetDestinationIp [2/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int dest_ip_1,\n    int dest_ip_2,\n    int dest_ip_3,\n    int dest_ip_4,\n    int port,\n    int gps_port,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-33","title":"function SetDestinationIp [3/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\n    int dest_ip_1,\n    int dest_ip_2,\n    int dest_ip_3,\n    int dest_ip_4,\n    int port,\n    int gps_port,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-16","title":"function SetLidarRange [1/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int method,\n    std::vector&lt; unsigned char &gt; data,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-26","title":"function SetLidarRange [2/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int method,\n    std::vector&lt; unsigned char &gt; data,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-36","title":"function SetLidarRange [3/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    int method,\n    std::vector&lt; unsigned char &gt; data,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-46","title":"function SetLidarRange [4/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int start,\n    int end,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-56","title":"function SetLidarRange [5/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int start,\n    int end,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-66","title":"function SetLidarRange [6/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\n    int start,\n    int end,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlogger","title":"function SetLogger","text":"<p>Setting rclcpp::Logger. <pre><code>void nebula::drivers::HesaiHwInterface::SetLogger (\n    std::shared_ptr&lt; rclcpp::Logger &gt; node\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>node</code> Logger </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-13","title":"function SetPtpConfig [1/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-23","title":"function SetPtpConfig [2/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-33","title":"function SetPtpConfig [3/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfigsynchttp-12","title":"function SetPtpConfigSyncHttp [1/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetPtpConfigSyncHttp (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfigsynchttp-22","title":"function SetPtpConfigSyncHttp [2/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetPtpConfigSyncHttp (\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-13","title":"function SetReturnMode [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int return_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-23","title":"function SetReturnMode [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int return_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-33","title":"function SetReturnMode [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\n    int return_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-13","title":"function SetRotDir [1/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-23","title":"function SetRotDir [2/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-33","title":"function SetRotDir [3/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\n    int mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Setting sensor configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::SetSensorConfiguration (\n    std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-13","title":"function SetSpinRate [1/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    uint16_t rpm,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-23","title":"function SetSpinRate [2/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    uint16_t rpm,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-33","title":"function SetSpinRate [3/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\n    uint16_t rpm,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinspeedasynchttp-12","title":"function SetSpinSpeedAsyncHttp [1/2]","text":"<p>Setting spin_speed via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSpinSpeedAsyncHttp (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    uint16_t rpm\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>rpm</code> spin_speed (300, 600, 1200) </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinspeedasynchttp-22","title":"function SetSpinSpeedAsyncHttp [2/2]","text":"<p>Setting spin_speed via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSpinSpeedAsyncHttp (\n    uint16_t rpm\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> spin_speed (300, 600, 1200) </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-13","title":"function SetStandbyMode [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int standby_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-23","title":"function SetStandbyMode [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int standby_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-33","title":"function SetStandbyMode [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\n    int standby_mode,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-13","title":"function SetSyncAngle [1/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int sync_angle,\n    int angle,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-23","title":"function SetSyncAngle [2/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int sync_angle,\n    int angle,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-33","title":"function SetSyncAngle [3/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\n    int sync_angle,\n    int angle,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncanglesynchttp-12","title":"function SetSyncAngleSyncHttp [1/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSyncAngleSyncHttp (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int enable,\n    int angle\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncanglesynchttp-22","title":"function SetSyncAngleSyncHttp [2/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSyncAngleSyncHttp (\n    int enable,\n    int angle\n) \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settargetmodel-12","title":"function SetTargetModel [1/2]","text":"<p>Set target model number (for proper use of HTTP and TCP according to the support of the target model) <pre><code>void nebula::drivers::HesaiHwInterface::SetTargetModel (\n    int model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settargetmodel-22","title":"function SetTargetModel [2/2]","text":"<p>Set target model number (for proper use of HTTP and TCP according to the support of the target model) <pre><code>void nebula::drivers::HesaiHwInterface::SetTargetModel (\n    nebula::drivers::SensorModel model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-13","title":"function SetTriggerMethod [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    int trigger_method,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-23","title":"function SetTriggerMethod [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    int trigger_method,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-33","title":"function SetTriggerMethod [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\n    int trigger_method,\n    bool with_run=true\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpgetlidarmonitor-12","title":"function UseHttpGetLidarMonitor [1/2]","text":"<p>Whether to use HTTP for getting LidarMonitor. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpGetLidarMonitor (\n    int model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpgetlidarmonitor-22","title":"function UseHttpGetLidarMonitor [2/2]","text":"<p>Whether to use HTTP for getting LidarMonitor. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpGetLidarMonitor () \n</code></pre></p> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpsetspinrate-12","title":"function UseHttpSetSpinRate [1/2]","text":"<p>Whether to use HTTP for setting SpinRate. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpSetSpinRate (\n    int model\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpsetspinrate-22","title":"function UseHttpSetSpinRate [2/2]","text":"<p>Whether to use HTTP for setting SpinRate. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpSetSpinRate () \n</code></pre></p> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetinventory-15","title":"function syncGetInventory [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetInventory (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetinventory-25","title":"function syncGetInventory [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetInventory (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetinventory-35","title":"function syncGetInventory [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetInventory (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetinventory-45","title":"function syncGetInventory [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetInventory (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetinventory-55","title":"function syncGetInventory [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetInventory (\n    std::function&lt; void( HesaiInventory &amp;result)&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiInventory </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-15","title":"function syncGetLidarCalibration [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-25","title":"function syncGetLidarCalibration [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>bytes_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-35","title":"function syncGetLidarCalibration [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-45","title":"function syncGetLidarCalibration [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx,\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-55","title":"function syncGetLidarCalibration [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\n    std::shared_ptr&lt; boost::asio::io_context &gt; ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-13","title":"function syncGetLidarCalibrationFromSensor [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor (\n    std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback\n) \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-23","title":"function syncGetLidarCalibrationFromSensor [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>bytes_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-33","title":"function syncGetLidarCalibrationFromSensor [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>str_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-hesaihwinterface_1","title":"function ~HesaiHwInterface","text":"<pre><code>nebula::drivers::HesaiHwInterface::~HesaiHwInterface () \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/","title":"Class nebula::drivers::NebulaHwInterfaceBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; NebulaHwInterfaceBase</p> <p>Base class for hardware interface of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_interface_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiHwInterface,  nebula::drivers::RobosenseHwInterface,  nebula::drivers::VelodyneHwInterface</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#public-functions","title":"Public Functions","text":"Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Virtual function for starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Virtual function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Virtual function for printing calibration configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration (\n    CalibrationConfigurationBase &amp; calibration_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Virtual function for printing sensor configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration (\n    SensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-13","title":"function NebulaHwInterfaceBase [1/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase (\n    NebulaHwInterfaceBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-23","title":"function NebulaHwInterfaceBase [2/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase (\n    const NebulaHwInterfaceBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-33","title":"function NebulaHwInterfaceBase [3/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase () = default\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Virtual function for setting sensor configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration (\n    std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwInterfaceBase &amp; nebula::drivers::NebulaHwInterfaceBase::operator= (\n    NebulaHwInterfaceBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwInterfaceBase &amp; nebula::drivers::NebulaHwInterfaceBase::operator= (\n    const NebulaHwInterfaceBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<pre><code>virtual void nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback (\n    const std::vector&lt; uint8_t &gt; &amp; buffer\n) = 0\n</code></pre> <p>Callback function to receive the Cloud Packet data from the UDP Driver </p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Returns:</p> <p>Status::OK if no error occurred. </p> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/","title":"Class nebula::drivers::RobosenseHwInterface","text":"<p>ClassList &gt; nebula &gt; drivers &gt; RobosenseHwInterface</p> <p>Hardware interface of Robosense driver. </p> <ul> <li><code>#include &lt;robosense_hw_interface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaHwInterfaceBase</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#public-functions","title":"Public Functions","text":"Type Name virtual Status CloudInterfaceStart () Starting the interface that handles UDP streams for MSOP packets. virtual Status CloudInterfaceStop () Function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) overridePrinting calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) Printing sensor configuration. Status InfoInterfaceStart () Starting the interface that handles UDP streams for DIFOP packets. virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Cloud Packet data from the UDP Driver. void ReceiveInfoPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Info Packet data from the UDP Driver. Status RegisterInfoCallback (std::function&lt; void(std::unique_ptr&lt; robosense_msgs::msg::RobosenseInfoPacket &gt;)&gt; info_callback) Registering callback for RobosensePacket. Status RegisterScanCallback (std::function&lt; void(std::unique_ptr&lt; robosense_msgs::msg::RobosenseScan &gt;)&gt; scan_callback) Registering callback for RobosenseScan. RobosenseHwInterface () Constructor. void SetLogger (std::shared_ptr&lt; rclcpp::Logger &gt; logger) Setting rclcpp::Logger. virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Setting sensor configuration."},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#public-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Public Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#protected-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Protected Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Starting the interface that handles UDP streams for MSOP packets. <pre><code>virtual Status nebula::drivers::RobosenseHwInterface::CloudInterfaceStart () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::RobosenseHwInterface::CloudInterfaceStop () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Printing calibration configuration. <pre><code>virtual Status nebula::drivers::RobosenseHwInterface::GetCalibrationConfiguration (\n    CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Printing sensor configuration. <pre><code>virtual Status nebula::drivers::RobosenseHwInterface::GetSensorConfiguration (\n    SensorConfigurationBase &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-infointerfacestart","title":"function InfoInterfaceStart","text":"<p>Starting the interface that handles UDP streams for DIFOP packets. <pre><code>Status nebula::drivers::RobosenseHwInterface::InfoInterfaceStart () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<p>Callback function to receive the Cloud Packet data from the UDP Driver. <pre><code>virtual void nebula::drivers::RobosenseHwInterface::ReceiveCloudPacketCallback (\n    const std::vector&lt; uint8_t &gt; &amp; buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Implements nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-receiveinfopacketcallback","title":"function ReceiveInfoPacketCallback","text":"<p>Callback function to receive the Info Packet data from the UDP Driver. <pre><code>void nebula::drivers::RobosenseHwInterface::ReceiveInfoPacketCallback (\n    const std::vector&lt; uint8_t &gt; &amp; buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-registerinfocallback","title":"function RegisterInfoCallback","text":"<p>Registering callback for RobosensePacket. <pre><code>Status nebula::drivers::RobosenseHwInterface::RegisterInfoCallback (\n    std::function&lt; void(std::unique_ptr&lt; robosense_msgs::msg::RobosenseInfoPacket &gt;)&gt; info_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-registerscancallback","title":"function RegisterScanCallback","text":"<p>Registering callback for RobosenseScan. <pre><code>Status nebula::drivers::RobosenseHwInterface::RegisterScanCallback (\n    std::function&lt; void(std::unique_ptr&lt; robosense_msgs::msg::RobosenseScan &gt;)&gt; scan_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-robosensehwinterface","title":"function RobosenseHwInterface","text":"<pre><code>nebula::drivers::RobosenseHwInterface::RobosenseHwInterface () \n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-setlogger","title":"function SetLogger","text":"<p>Setting rclcpp::Logger. <pre><code>void nebula::drivers::RobosenseHwInterface::SetLogger (\n    std::shared_ptr&lt; rclcpp::Logger &gt; logger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>node</code> Logger </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1RobosenseHwInterface/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Setting sensor configuration. <pre><code>virtual Status nebula::drivers::RobosenseHwInterface::SetSensorConfiguration (\n    std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration</p> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/","title":"Class nebula::drivers::VelodyneHwInterface","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneHwInterface</p> <p>Hardware interface of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_interface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaHwInterfaceBase</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions","title":"Public Functions","text":"Type Name VelodyneStatus CheckAndSetConfigBySnapshotAsync (std::shared_ptr&lt; VelodyneSensorConfiguration &gt; sensor_configuration) Checking the current settings and changing the difference point. virtual Status CloudInterfaceStart () Starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () Function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) Printing calibration configuration. std::string GetDiag () Getting diagnostic information from the sensor (sync) VelodyneStatus GetDiagAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting diagnostic information from the sensor (async) VelodyneStatus GetDiagAsync () Getting diagnostic information from the sensor (async) virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) Printing sensor configuration. std::string GetSnapshot () Getting current sensor configuration and status data (sync) VelodyneStatus GetSnapshotAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting current sensor configuration and status data (async) VelodyneStatus GetSnapshotAsync () Getting current sensor configuration and status data (async) std::string GetStatus () Getting the current operational state and parameters of the sensor (sync) VelodyneStatus GetStatusAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting the current operational state and parameters of the sensor (async) VelodyneStatus GetStatusAsync () Getting the current operational state and parameters of the sensor (async) VelodyneStatus InitHttpClient () Initializing HTTP client (sync) VelodyneStatus InitHttpClientAsync () Initializing HTTP client (async) Status InitializeSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Initializing sensor configuration. VelodyneStatus LaserOff () Turn laser state off (sync) VelodyneStatus LaserOffAsync () Turn laser state off (async) VelodyneStatus LaserOn () Turn laser state on (sync) VelodyneStatus LaserOnAsync () Turn laser state on (async) VelodyneStatus LaserOnOff (bool on) Turn laser state on/off (sync) VelodyneStatus LaserOnOffAsync (bool on) Turn laser state on/off (async) boost::property_tree::ptree ParseJson (const std::string &amp; str) Parsing JSON string to property_tree. virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Cloud Packet data from the UDP Driver. Status RegisterScanCallback (std::function&lt; void(std::unique_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt;)&gt; scan_callback) Registering callback for PandarScan. VelodyneStatus ResetSystem () Resets the sensor (sync) VelodyneStatus ResetSystemAsync () Resets the sensor (async) VelodyneStatus SaveConfig () Save Configuration to the LiDAR memory (sync) VelodyneStatus SaveConfigAsync () Save Configuration to the LiDAR memory (async) VelodyneStatus SetFovEnd (uint16_t fov_end) Setting Field of View End (sync) VelodyneStatus SetFovEndAsync (uint16_t fov_end) Setting Field of View End (async) VelodyneStatus SetFovStart (uint16_t fov_start) Setting Field of View Start (sync) VelodyneStatus SetFovStartAsync (uint16_t fov_start) Setting Field of View Start (async) VelodyneStatus SetHostAddr (std::string addr) Setting host (destination) IP address (sync) VelodyneStatus SetHostAddrAsync (std::string addr) Setting host (destination) IP address (async) VelodyneStatus SetHostDport (uint16_t dport) Setting host (destination) data port (sync) VelodyneStatus SetHostDportAsync (uint16_t dport) Setting host (destination) data port (async) VelodyneStatus SetHostTport (uint16_t tport) Setting host (destination) telemetry port (sync) VelodyneStatus SetHostTportAsync (uint16_t tport) Setting host (destination) telemetry port (async) void SetLogger (std::shared_ptr&lt; rclcpp::Logger &gt; node) Setting rclcpp::Logger. VelodyneStatus SetNetAddr (std::string addr) Setting network (sensor) IP address (sync) VelodyneStatus SetNetAddrAsync (std::string addr) Setting network (sensor) IP address (async) VelodyneStatus SetNetDhcp (bool use_dhcp) This determines if the sensor is to rely on a DHCP server for its IP address (sync) VelodyneStatus SetNetDhcpAsync (bool use_dhcp) This determines if the sensor is to rely on a DHCP server for its IP address (async) VelodyneStatus SetNetGateway (std::string gateway) Setting the gateway address of the sensor (sync) VelodyneStatus SetNetGatewayAsync (std::string gateway) Setting the gateway address of the sensor (async) VelodyneStatus SetNetMask (std::string mask) Setting the network mask of the sensor (sync) VelodyneStatus SetNetMaskAsync (std::string mask) Setting the network mask of the sensor (async) VelodyneStatus SetReturnType (ReturnMode return_mode) Setting Return Type (sync) VelodyneStatus SetReturnTypeAsync (ReturnMode return_mode) Setting Return Type (async) VelodyneStatus SetRpm (uint16_t rpm) Setting Motor RPM (sync) VelodyneStatus SetRpmAsync (uint16_t rpm) Setting Motor RPM (async) virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Setting sensor configuration with InitializeSensorConfiguration &amp; CheckAndSetConfigBySnapshotAsync. VelodyneHwInterface () Constructor."},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Public Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#protected-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Protected Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-checkandsetconfigbysnapshotasync","title":"function CheckAndSetConfigBySnapshotAsync","text":"<p>Checking the current settings and changing the difference point. <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::CheckAndSetConfigBySnapshotAsync (\n    std::shared_ptr&lt; VelodyneSensorConfiguration &gt; sensor_configuration\n) \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::CloudInterfaceStart () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::CloudInterfaceStop () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Printing calibration configuration. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::GetCalibrationConfiguration (\n    CalibrationConfigurationBase &amp; calibration_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiag","title":"function GetDiag","text":"<p>Getting diagnostic information from the sensor (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetDiag () \n</code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiagasync-12","title":"function GetDiagAsync [1/2]","text":"<p>Getting diagnostic information from the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetDiagAsync (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiagasync-22","title":"function GetDiagAsync [2/2]","text":"<p>Getting diagnostic information from the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetDiagAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Printing sensor configuration. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::GetSensorConfiguration (\n    SensorConfigurationBase &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshot","title":"function GetSnapshot","text":"<p>Getting current sensor configuration and status data (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetSnapshot () \n</code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshotasync-12","title":"function GetSnapshotAsync [1/2]","text":"<p>Getting current sensor configuration and status data (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetSnapshotAsync (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshotasync-22","title":"function GetSnapshotAsync [2/2]","text":"<p>Getting current sensor configuration and status data (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetSnapshotAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatus","title":"function GetStatus","text":"<p>Getting the current operational state and parameters of the sensor (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatusasync-12","title":"function GetStatusAsync [1/2]","text":"<p>Getting the current operational state and parameters of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetStatusAsync (\n    std::function&lt; void(const std::string &amp;str)&gt; str_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatusasync-22","title":"function GetStatusAsync [2/2]","text":"<p>Getting the current operational state and parameters of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetStatusAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-inithttpclient","title":"function InitHttpClient","text":"<p>Initializing HTTP client (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::InitHttpClient () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-inithttpclientasync","title":"function InitHttpClientAsync","text":"<p>Initializing HTTP client (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::InitHttpClientAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-initializesensorconfiguration","title":"function InitializeSensorConfiguration","text":"<p>Initializing sensor configuration. <pre><code>Status nebula::drivers::VelodyneHwInterface::InitializeSensorConfiguration (\n    std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseroff","title":"function LaserOff","text":"<p>Turn laser state off (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOff () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseroffasync","title":"function LaserOffAsync","text":"<p>Turn laser state off (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOffAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseron","title":"function LaserOn","text":"<p>Turn laser state on (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOn () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronasync","title":"function LaserOnAsync","text":"<p>Turn laser state on (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronoff","title":"function LaserOnOff","text":"<p>Turn laser state on/off (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnOff (\n    bool on\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> is ON </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronoffasync","title":"function LaserOnOffAsync","text":"<p>Turn laser state on/off (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnOffAsync (\n    bool on\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> is ON </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-parsejson","title":"function ParseJson","text":"<p>Parsing JSON string to property_tree. <pre><code>boost::property_tree::ptree nebula::drivers::VelodyneHwInterface::ParseJson (\n    const std::string &amp; str\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> JSON string </li> </ul> <p>Returns:</p> <p>property_tree </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<p>Callback function to receive the Cloud Packet data from the UDP Driver. <pre><code>virtual void nebula::drivers::VelodyneHwInterface::ReceiveCloudPacketCallback (\n    const std::vector&lt; uint8_t &gt; &amp; buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Implements nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-registerscancallback","title":"function RegisterScanCallback","text":"<p>Registering callback for PandarScan. <pre><code>Status nebula::drivers::VelodyneHwInterface::RegisterScanCallback (\n    std::function&lt; void(std::unique_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt;)&gt; scan_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-resetsystem","title":"function ResetSystem","text":"<p>Resets the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::ResetSystem () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-resetsystemasync","title":"function ResetSystemAsync","text":"<p>Resets the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::ResetSystemAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-saveconfig","title":"function SaveConfig","text":"<p>Save Configuration to the LiDAR memory (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SaveConfig () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-saveconfigasync","title":"function SaveConfigAsync","text":"<p>Save Configuration to the LiDAR memory (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SaveConfigAsync () \n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovend","title":"function SetFovEnd","text":"<p>Setting Field of View End (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovEnd (\n    uint16_t fov_end\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_end</code> FOV end </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovendasync","title":"function SetFovEndAsync","text":"<p>Setting Field of View End (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovEndAsync (\n    uint16_t fov_end\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_end</code> FOV end </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovstart","title":"function SetFovStart","text":"<p>Setting Field of View Start (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovStart (\n    uint16_t fov_start\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_start</code> FOV start </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovstartasync","title":"function SetFovStartAsync","text":"<p>Setting Field of View Start (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovStartAsync (\n    uint16_t fov_start\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_start</code> FOV start </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostaddr","title":"function SetHostAddr","text":"<p>Setting host (destination) IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostAddr (\n    std::string addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> destination IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostaddrasync","title":"function SetHostAddrAsync","text":"<p>Setting host (destination) IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostAddrAsync (\n    std::string addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> destination IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostdport","title":"function SetHostDport","text":"<p>Setting host (destination) data port (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostDport (\n    uint16_t dport\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dport</code> destination data port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostdportasync","title":"function SetHostDportAsync","text":"<p>Setting host (destination) data port (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostDportAsync (\n    uint16_t dport\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dport</code> destination data port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethosttport","title":"function SetHostTport","text":"<p>Setting host (destination) telemetry port (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostTport (\n    uint16_t tport\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tport</code> destination telemetry port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethosttportasync","title":"function SetHostTportAsync","text":"<p>Setting host (destination) telemetry port (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostTportAsync (\n    uint16_t tport\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tport</code> destination telemetry port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setlogger","title":"function SetLogger","text":"<p>Setting rclcpp::Logger. <pre><code>void nebula::drivers::VelodyneHwInterface::SetLogger (\n    std::shared_ptr&lt; rclcpp::Logger &gt; node\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>node</code> Logger </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetaddr","title":"function SetNetAddr","text":"<p>Setting network (sensor) IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetAddr (\n    std::string addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> sensor IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetaddrasync","title":"function SetNetAddrAsync","text":"<p>Setting network (sensor) IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetAddrAsync (\n    std::string addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> sensor IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetdhcp","title":"function SetNetDhcp","text":"<p>This determines if the sensor is to rely on a DHCP server for its IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetDhcp (\n    bool use_dhcp\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>use_dhcp</code> DHCP on </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetdhcpasync","title":"function SetNetDhcpAsync","text":"<p>This determines if the sensor is to rely on a DHCP server for its IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetDhcpAsync (\n    bool use_dhcp\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>use_dhcp</code> DHCP on </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetgateway","title":"function SetNetGateway","text":"<p>Setting the gateway address of the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetGateway (\n    std::string gateway\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>gateway</code> Gateway address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetgatewayasync","title":"function SetNetGatewayAsync","text":"<p>Setting the gateway address of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetGatewayAsync (\n    std::string gateway\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>gateway</code> Gateway address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetmask","title":"function SetNetMask","text":"<p>Setting the network mask of the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetMask (\n    std::string mask\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> Network mask </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetmaskasync","title":"function SetNetMaskAsync","text":"<p>Setting the network mask of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetMaskAsync (\n    std::string mask\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> Network mask </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setreturntype","title":"function SetReturnType","text":"<p>Setting Return Type (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetReturnType (\n    ReturnMode return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> ReturnMode </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setreturntypeasync","title":"function SetReturnTypeAsync","text":"<p>Setting Return Type (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetReturnTypeAsync (\n    ReturnMode return_mode\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> ReturnMode </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setrpm","title":"function SetRpm","text":"<p>Setting Motor RPM (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetRpm (\n    uint16_t rpm\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> the RPM of the motor </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setrpmasync","title":"function SetRpmAsync","text":"<p>Setting Motor RPM (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetRpmAsync (\n    uint16_t rpm\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> the RPM of the motor </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Setting sensor configuration with InitializeSensorConfiguration &amp; CheckAndSetConfigBySnapshotAsync. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::SetSensorConfiguration (\n    std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-velodynehwinterface","title":"function VelodyneHwInterface","text":"<pre><code>nebula::drivers::VelodyneHwInterface::VelodyneHwInterface () \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/dir_cdea7329b6b65bb9fca0dec0063a1667/","title":"Dir nebula_hw_interfaces","text":"<p>FileList &gt; nebula_hw_interfaces</p>"},{"location":"nebula_hw_interfaces/dir_cdea7329b6b65bb9fca0dec0063a1667/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/</code></p>"},{"location":"nebula_hw_interfaces/dir_46bad66cb8ff2bf21ac1466c24078895/","title":"Dir nebula_hw_interfaces/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_hw_interfaces/dir_46bad66cb8ff2bf21ac1466c24078895/#directories","title":"Directories","text":"Type Name dir nebula_hw_interfaces <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/</code></p>"},{"location":"nebula_hw_interfaces/dir_753169d095bbb8c16a53041d0c804bb3/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces</p>"},{"location":"nebula_hw_interfaces/dir_753169d095bbb8c16a53041d0c804bb3/#directories","title":"Directories","text":"Type Name dir nebula_hw_interfaces_common dir nebula_hw_interfaces_hesai dir nebula_hw_interfaces_robosense dir nebula_hw_interfaces_velodyne <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/</code></p>"},{"location":"nebula_hw_interfaces/dir_7a9d3e2469d6635a12ef6571522c310a/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common</p>"},{"location":"nebula_hw_interfaces/dir_7a9d3e2469d6635a12ef6571522c310a/#files","title":"Files","text":"Type Name file nebula_hw_interface_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/</code></p>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/","title":"File nebula_hw_interface_base.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common &gt; nebula_hw_interface_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp_source/","title":"File nebula_hw_interface_base.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common &gt; nebula_hw_interface_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_INTERFACE_BASE_H\n#define NEBULA_HW_INTERFACE_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass NebulaHwInterfaceBase\n{\nprotected:\n  virtual void ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) = 0;\n  //  virtual Status RegisterScanCallback(\n  //    std::function&lt;void(std::unique_ptr&lt;std::vector&lt;std::vector&lt;uint8_t&gt;&gt;&gt;)&gt; scan_callback) = 0;\n\npublic:\n  NebulaHwInterfaceBase(NebulaHwInterfaceBase &amp;&amp; c) = delete;\n  NebulaHwInterfaceBase &amp; operator=(NebulaHwInterfaceBase &amp;&amp; c) = delete;\n  NebulaHwInterfaceBase(const NebulaHwInterfaceBase &amp; c) = delete;\n  NebulaHwInterfaceBase &amp; operator=(const NebulaHwInterfaceBase &amp; c) = delete;\n\n  NebulaHwInterfaceBase() = default;\n\n  virtual Status CloudInterfaceStart() = 0;\n\n  virtual Status CloudInterfaceStop() = 0;\n  // You may want to also implement GpsInterfaceStart() and ReceiveGpsCallback, but that is sensor\n  // specific.\n\n  virtual Status SetSensorConfiguration(\n    std::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) = 0;\n\n  virtual Status GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) = 0;\n\n  virtual Status GetCalibrationConfiguration(\n    CalibrationConfigurationBase &amp; calibration_configuration) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HW_INTERFACE_BASE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/dir_97916b007af0a552f010ef776d20ae4f/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai</p>"},{"location":"nebula_hw_interfaces/dir_97916b007af0a552f010ef776d20ae4f/#files","title":"Files","text":"Type Name file hesai_cmd_response.hpp file hesai_hw_interface.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/</code></p>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/","title":"File hesai_cmd_response.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_cmd_response.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;boost/format.hpp&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp_source/","title":"File hesai_cmd_response.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_cmd_response.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HESAI_CMD_RESPONSE_HPP\n#define HESAI_CMD_RESPONSE_HPP\n\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;boost/format.hpp&gt;\n\n#include &lt;ostream&gt;\n\nnamespace nebula\n{\nstruct HesaiPtpDiagStatus\n{\n  long long master_offset;\n  int ptp_state;\n  int elapsed_millisec;\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagStatus const &amp; arg)\n  {\n    os &lt;&lt; \"master_offset: \" &lt;&lt; arg.master_offset;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"ptp_state: \" &lt;&lt; arg.ptp_state;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"elapsed_millisec: \" &lt;&lt; arg.elapsed_millisec;\n\n    return os;\n  }\n};\n\nstruct HesaiPtpDiagPort\n{\n  std::vector&lt;char&gt; portIdentity = std::vector&lt;char&gt;(10);\n  int portState;\n  int logMinDelayReqInterval;\n  long long peerMeanPathDelay;\n  int logAnnounceInterval;\n  int announceReceiptTimeout;\n  int logSyncInterval;\n  int delayMechanism;\n  int logMinPdelayReqInterval;\n  int versionNumber;\n\n  HesaiPtpDiagPort() {}\n  HesaiPtpDiagPort(const HesaiPtpDiagPort &amp; arg)\n  {\n    std::copy(arg.portIdentity.begin(), arg.portIdentity.end(), portIdentity.begin());\n    portState = arg.portState;\n    logMinDelayReqInterval = arg.logMinDelayReqInterval;\n    peerMeanPathDelay = arg.peerMeanPathDelay;\n    logAnnounceInterval = arg.logAnnounceInterval;\n    announceReceiptTimeout = arg.announceReceiptTimeout;\n    logSyncInterval = arg.logSyncInterval;\n    delayMechanism = arg.delayMechanism;\n    logMinPdelayReqInterval = arg.logMinPdelayReqInterval;\n    versionNumber = arg.versionNumber;\n  }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagPort const &amp; arg)\n  {\n    os &lt;&lt; \"portIdentity: \" &lt;&lt; std::string(arg.portIdentity.begin(), arg.portIdentity.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"portState: \" &lt;&lt; arg.portState;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"logMinDelayReqInterval: \" &lt;&lt; arg.logMinDelayReqInterval;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"peerMeanPathDelay: \" &lt;&lt; arg.peerMeanPathDelay;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"logAnnounceInterval: \" &lt;&lt; arg.logAnnounceInterval;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"announceReceiptTimeout: \" &lt;&lt; arg.announceReceiptTimeout;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"logSyncInterval: \" &lt;&lt; arg.logSyncInterval;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"delayMechanism: \" &lt;&lt; arg.delayMechanism;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"logMinPdelayReqInterval: \" &lt;&lt; arg.logMinPdelayReqInterval;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"versionNumber: \" &lt;&lt; arg.versionNumber;\n\n    return os;\n  }\n};\n\nstruct HesaiPtpDiagTime\n{\n  long long master_offset;\n  long long ingress_time;\n  int cumulativeScaledRateOffset;\n  int scaledLastGmPhaseChange;\n  int gmTimeBaseIndicator;\n  std::vector&lt;char&gt; lastGmPhaseChange = std::vector&lt;char&gt;(12);\n  int gmPresent;\n  long long gmIdentity;\n\n  HesaiPtpDiagTime() {}\n  HesaiPtpDiagTime(const HesaiPtpDiagTime &amp; arg)\n  {\n    master_offset = arg.master_offset;\n    ingress_time = arg.ingress_time;\n    cumulativeScaledRateOffset = arg.cumulativeScaledRateOffset;\n    scaledLastGmPhaseChange = arg.scaledLastGmPhaseChange;\n    gmTimeBaseIndicator = arg.gmTimeBaseIndicator;\n    std::copy(\n      arg.lastGmPhaseChange.begin(), arg.lastGmPhaseChange.end(), lastGmPhaseChange.begin());\n    gmPresent = arg.gmPresent;\n    gmIdentity = arg.gmIdentity;\n  }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagTime const &amp; arg)\n  {\n    os &lt;&lt; \"master_offset: \" &lt;&lt; arg.master_offset;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"ingress_time: \" &lt;&lt; arg.ingress_time;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"cumulativeScaledRateOffset: \" &lt;&lt; arg.cumulativeScaledRateOffset;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"scaledLastGmPhaseChange: \" &lt;&lt; arg.scaledLastGmPhaseChange;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gmTimeBaseIndicator: \" &lt;&lt; arg.gmTimeBaseIndicator;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"lastGmPhaseChange: \"\n       &lt;&lt; std::string(arg.lastGmPhaseChange.begin(), arg.lastGmPhaseChange.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gmPresent: \" &lt;&lt; arg.gmPresent;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gmIdentity: \" &lt;&lt; arg.gmIdentity;\n\n    return os;\n  }\n};\n\nstruct HesaiPtpDiagGrandmaster\n{\n  int clockQuality;\n  int utc_offset;\n  int time_flags;\n  int time_source;\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagGrandmaster const &amp; arg)\n  {\n    os &lt;&lt; \"clockQuality: \" &lt;&lt; arg.clockQuality;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"utc_offset: \" &lt;&lt; arg.utc_offset;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"time_flags: \" &lt;&lt; arg.time_flags;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"time_source: \" &lt;&lt; arg.time_source;\n\n    return os;\n  }\n};\n\nstruct HesaiInventory\n{\n  std::vector&lt;char&gt; sn = std::vector&lt;char&gt;(18);\n  std::vector&lt;char&gt; date_of_manufacture = std::vector&lt;char&gt;(16);\n  std::vector&lt;char&gt; mac = std::vector&lt;char&gt;(6);\n  std::vector&lt;char&gt; sw_ver = std::vector&lt;char&gt;(16);\n  std::vector&lt;char&gt; hw_ver = std::vector&lt;char&gt;(16);\n  std::vector&lt;char&gt; control_fw_ver = std::vector&lt;char&gt;(16);\n  std::vector&lt;char&gt; sensor_fw_ver = std::vector&lt;char&gt;(16);\n  int angle_offset;\n  int model;\n  int motor_type;\n  int num_of_lines;\n  std::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(11);\n\n  HesaiInventory() {}\n  HesaiInventory(const HesaiInventory &amp; arg)\n  {\n    std::copy(arg.sn.begin(), arg.sn.end(), sn.begin());\n    std::copy(\n      arg.date_of_manufacture.begin(), arg.date_of_manufacture.end(), date_of_manufacture.begin());\n    std::copy(arg.mac.begin(), arg.mac.end(), mac.begin());\n    std::copy(arg.sw_ver.begin(), arg.sw_ver.end(), sw_ver.begin());\n    std::copy(arg.hw_ver.begin(), arg.hw_ver.end(), hw_ver.begin());\n    std::copy(arg.control_fw_ver.begin(), arg.control_fw_ver.end(), control_fw_ver.begin());\n    std::copy(arg.sensor_fw_ver.begin(), arg.sensor_fw_ver.end(), sensor_fw_ver.begin());\n    angle_offset = arg.angle_offset;\n    model = arg.model;\n    motor_type = arg.motor_type;\n    num_of_lines = arg.num_of_lines;\n    std::copy(arg.reserved.begin(), arg.reserved.end(), reserved.begin());\n  }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiInventory const &amp; arg)\n  {\n    os &lt;&lt; \"sn: \" &lt;&lt; std::string(arg.sn.begin(), arg.sn.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"date_of_manufacture: \"\n       &lt;&lt; std::string(arg.date_of_manufacture.begin(), arg.date_of_manufacture.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"mac: \";\n    std::stringstream ss;\n    for (long unsigned int i = 0; i &lt; arg.mac.size() - 1; i++) {\n      ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; (static_cast&lt;int&gt;(arg.mac[i]) &amp; 0xff)\n         &lt;&lt; \":\";\n    }\n    ss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2)\n       &lt;&lt; (static_cast&lt;int&gt;(arg.mac[arg.mac.size() - 1]) &amp; 0xff);\n    os &lt;&lt; ss.str();\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"sw_ver: \" &lt;&lt; std::string(arg.sw_ver.begin(), arg.sw_ver.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"hw_ver: \" &lt;&lt; std::string(arg.hw_ver.begin(), arg.hw_ver.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"control_fw_ver: \" &lt;&lt; std::string(arg.control_fw_ver.begin(), arg.control_fw_ver.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"sensor_fw_ver: \" &lt;&lt; std::string(arg.sensor_fw_ver.begin(), arg.sensor_fw_ver.end());\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"angle_offset: \" &lt;&lt; arg.angle_offset;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"model: \" &lt;&lt; arg.model;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"motor_type: \" &lt;&lt; arg.motor_type;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"num_of_lines: \" &lt;&lt; arg.num_of_lines;\n    os &lt;&lt; \", \";\n    //      os &lt;&lt; \"reserved: \" &lt;&lt; boost::algorithm::join(arg.reserved, \",\");\n    os &lt;&lt; \"reserved: \";\n    for (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\n      os &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n    }\n    os &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\n    return os;\n  }\n\n  std::string get_str_model()\n  {\n    switch (model) {\n      case 0:\n        return \"Pandar40P\";\n        break;\n      case 2:\n        return \"Pandar64\";\n        break;\n      case 3:\n        return \"Pandar128\";\n        break;\n      case 15:\n        return \"PandarQT\";\n        break;\n      case 17:\n        return \"Pandar40M\";\n        break;\n      case 20:\n        return \"PandarMind(PM64)\";\n        break;\n      case 25:\n        return \"PandarXT32\";\n        break;\n      case 26:\n        return \"PandarXT16\";\n        break;\n      case 32:\n        return \"QT128C2X\";\n        break;\n      case 38:\n        return \"PandarXT32M\";\n        break;\n      case 48:\n        return \"PandarAT128\";\n        break;\n      default:\n        return \"Unknown(\" + std::to_string(model) + \")\";\n        break;\n    }\n  }\n};\n\nstruct HesaiConfig\n{\n  int ipaddr[4];\n  int mask[4];\n  int gateway[4];\n  int dest_ipaddr[4];\n  int dest_LiDAR_udp_port;\n  int dest_gps_udp_port;\n  int spin_rate;\n  int sync;\n  int sync_angle;\n  int start_angle;\n  int stop_angle;\n  int clock_source;\n  int udp_seq;\n  int trigger_method;\n  int return_mode;\n  int standby_mode;\n  int motor_status;\n  int vlan_flag;\n  int vlan_id;\n  int clock_data_fmt;\n  int noise_filtering;\n  int reflectivity_mapping;\n  unsigned char reserved[6];\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiConfig const &amp; arg)\n  {\n    os &lt;&lt; \"ipaddr: \" &lt;&lt; arg.ipaddr[0] &lt;&lt; \".\" &lt;&lt; arg.ipaddr[1] &lt;&lt; \".\" &lt;&lt; arg.ipaddr[2] &lt;&lt; \".\"\n       &lt;&lt; arg.ipaddr[3];\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"mask: \" &lt;&lt; arg.mask[0] &lt;&lt; \".\" &lt;&lt; arg.mask[1] &lt;&lt; \".\" &lt;&lt; arg.mask[2] &lt;&lt; \".\" &lt;&lt; arg.mask[3];\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gateway: \" &lt;&lt; arg.gateway[0] &lt;&lt; \".\" &lt;&lt; arg.gateway[1] &lt;&lt; \".\" &lt;&lt; arg.gateway[2] &lt;&lt; \".\"\n       &lt;&lt; arg.gateway[3];\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"dest_ipaddr: \" &lt;&lt; arg.dest_ipaddr[0] &lt;&lt; \".\" &lt;&lt; arg.dest_ipaddr[1] &lt;&lt; \".\"\n       &lt;&lt; arg.dest_ipaddr[2] &lt;&lt; \".\" &lt;&lt; arg.dest_ipaddr[3];\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"dest_LiDAR_udp_port: \" &lt;&lt; arg.dest_LiDAR_udp_port;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"dest_gps_udp_port: \" &lt;&lt; arg.dest_gps_udp_port;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"spin_rate: \" &lt;&lt; arg.spin_rate;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"sync: \" &lt;&lt; arg.sync;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"sync_angle: \" &lt;&lt; arg.sync_angle;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"start_angle: \" &lt;&lt; arg.start_angle;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"stop_angle: \" &lt;&lt; arg.stop_angle;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"clock_source: \" &lt;&lt; arg.clock_source;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"udp_seq: \" &lt;&lt; arg.udp_seq;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"trigger_method: \" &lt;&lt; arg.trigger_method;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"return_mode: \" &lt;&lt; arg.return_mode;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"standby_mode: \" &lt;&lt; arg.standby_mode;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"motor_status: \" &lt;&lt; arg.motor_status;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"vlan_flag: \" &lt;&lt; arg.vlan_flag;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"vlan_id: \" &lt;&lt; arg.vlan_id;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"clock_data_fmt: \" &lt;&lt; arg.clock_data_fmt;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"noise_filtering: \" &lt;&lt; arg.noise_filtering;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"reflectivity_mapping: \" &lt;&lt; arg.reflectivity_mapping;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"reserved: \" &lt;&lt; arg.reserved[0] &lt;&lt; \",\" &lt;&lt; arg.reserved[1] &lt;&lt; \",\" &lt;&lt; arg.reserved[2] &lt;&lt; \",\"\n       &lt;&lt; arg.reserved[3] &lt;&lt; \",\" &lt;&lt; arg.reserved[4] &lt;&lt; \",\" &lt;&lt; arg.reserved[5];\n\n    return os;\n  }\n};\n\nstruct HesaiLidarStatus\n{\n  int system_uptime;\n  int motor_speed;\n  //    int temperature[8];\n  std::vector&lt;int&gt; temperature = std::vector&lt;int&gt;(8);\n  int gps_pps_lock;\n  int gps_gprmc_status;\n  int startup_times;\n  int total_operation_time;\n  int ptp_clock_status;\n  std::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(5);\n\n  HesaiLidarStatus() {}\n  HesaiLidarStatus(const HesaiLidarStatus &amp; arg)\n  {\n    system_uptime = arg.system_uptime;\n    motor_speed = arg.motor_speed;\n    std::copy(arg.temperature.begin(), arg.temperature.end(), temperature.begin());\n    gps_pps_lock = arg.gps_pps_lock;\n    gps_gprmc_status = arg.gps_gprmc_status;\n    startup_times = arg.startup_times;\n    total_operation_time = arg.total_operation_time;\n    ptp_clock_status = arg.ptp_clock_status;\n    std::copy(arg.reserved.begin(), arg.reserved.end(), reserved.begin());\n  }\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarStatus const &amp; arg)\n  {\n    os &lt;&lt; \"system_uptime: \" &lt;&lt; arg.system_uptime;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"motor_speed: \" &lt;&lt; arg.motor_speed;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"temperature: \";\n    for (long unsigned int i = 0; i &lt; arg.temperature.size() - 1; i++) {\n      os &lt;&lt; arg.temperature[i] &lt;&lt; \",\";\n    }\n    os &lt;&lt; arg.temperature[arg.temperature.size() - 1];\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gps_pps_lock: \" &lt;&lt; arg.gps_pps_lock;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"gps_gprmc_status: \" &lt;&lt; arg.gps_gprmc_status;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"startup_times: \" &lt;&lt; arg.startup_times;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"total_operation_time: \" &lt;&lt; arg.total_operation_time;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"ptp_clock_status: \" &lt;&lt; arg.ptp_clock_status;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"reserved: \";\n    for (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\n      os &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n    }\n    os &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\n    return os;\n  }\n\n  std::string get_str_gps_pps_lock()\n  {\n    switch (gps_pps_lock) {\n      case 1:\n        return \"Lock\";\n        break;\n      case 0:\n        return \"Unlock\";\n        break;\n      default:\n        return \"Unknown\";\n        break;\n    }\n  }\n  std::string get_str_gps_gprmc_status()\n  {\n    switch (gps_gprmc_status) {\n      case 1:\n        return \"Lock\";\n        break;\n      case 0:\n        return \"Unlock\";\n        break;\n      default:\n        return \"Unknown\";\n        break;\n    }\n  }\n  std::string get_str_ptp_clock_status()\n  {\n    switch (ptp_clock_status) {\n      case 0:\n        return \"free run\";\n        break;\n      case 1:\n        return \"tracking\";\n        break;\n      case 2:\n        return \"locked\";\n        break;\n      case 3:\n        return \"frozen\";\n        break;\n      default:\n        return \"Unknown\";\n        break;\n    }\n  }\n};\n\nstruct HesaiLidarRangeAll\n{\n  int method;\n  int start;\n  int end;\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarRangeAll const &amp; arg)\n  {\n    os &lt;&lt; \"method: \" &lt;&lt; arg.method;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"start: \" &lt;&lt; arg.start;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"end: \" &lt;&lt; arg.end;\n\n    return os;\n  }\n};\n\nstruct HesaiPtpConfig\n{\n  int status;\n  int profile;\n  int domain;\n  int network;\n  int logAnnounceInterval;\n  int logSyncInterval;\n  int logMinDelayReqInterval;\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpConfig const &amp; arg)\n  {\n    os &lt;&lt; \"status: \" &lt;&lt; arg.status;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"profile: \" &lt;&lt; arg.profile;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"domain: \" &lt;&lt; arg.domain;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"network: \" &lt;&lt; arg.network;\n    if (arg.status == 0) {\n      os &lt;&lt; \", \";\n      os &lt;&lt; \"logAnnounceInterval: \" &lt;&lt; arg.logAnnounceInterval;\n      os &lt;&lt; \", \";\n      os &lt;&lt; \"logSyncInterval: \" &lt;&lt; arg.logSyncInterval;\n      os &lt;&lt; \", \";\n      os &lt;&lt; \"logMinDelayReqInterval: \" &lt;&lt; arg.logMinDelayReqInterval;\n    }\n    return os;\n  }\n};\n\nstruct HesaiLidarMonitor\n{\n  int input_voltage;\n  int input_current;\n  int input_power;\n  std::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(52);\n\n  friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarMonitor const &amp; arg)\n  {\n    os &lt;&lt; \"input_voltage: \" &lt;&lt; arg.input_voltage;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"input_current: \" &lt;&lt; arg.input_current;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"input_power: \" &lt;&lt; arg.input_power;\n    os &lt;&lt; \", \";\n    os &lt;&lt; \"reserved: \";\n    for (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\n      os &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n    }\n    os &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\n    return os;\n  }\n};\n\n}  // namespace nebula\n#endif  // HESAI_CMD_RESPONSE_HPP\n</code></pre>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/","title":"File hesai_hw_interface.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_hw_interface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/version.hpp&gt;</code></li> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/hesai/hesai_status.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/http_client_driver.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;boost/algorithm/string.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/json_parser.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/ptree.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwInterface Hardware interface of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp_source/","title":"File hesai_hw_interface.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_hw_interface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_HW_INTERFACE_H\n#define NEBULA_HESAI_HW_INTERFACE_H\n// Have to define macros to silence warnings about deprecated headers being used by\n// boost/property_tree/ in some versions of boost.\n// See: https://github.com/boostorg/property_tree/issues/51\n#include &lt;boost/version.hpp&gt;\n#if (BOOST_VERSION / 100 &gt;= 1073 &amp;&amp; BOOST_VERSION / 100 &lt;= 1076)  // Boost 1.73 - 1.76\n#define BOOST_BIND_GLOBAL_PLACEHOLDERS\n#endif\n#if (BOOST_VERSION / 100 == 1074)  // Boost 1.74\n#define BOOST_ALLOW_DEPRECATED_HEADERS\n#endif\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/hesai/hesai_status.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp\"\n#include \"boost_tcp_driver/http_client_driver.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;boost/algorithm/string.hpp&gt;\n#include &lt;boost/property_tree/json_parser.hpp&gt;\n#include &lt;boost/property_tree/ptree.hpp&gt;\n\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nconst int PandarTcpCommandPort = 9347;\nconst uint8_t PTC_COMMAND_DUMMY_BYTE = 0x00;\nconst uint8_t PTC_COMMAND_HEADER_HIGH = 0x47;\nconst uint8_t PTC_COMMAND_HEADER_LOW = 0x74;\nconst uint8_t PTC_COMMAND_GET_LIDAR_CALIBRATION = 0x05;\nconst uint8_t PTC_COMMAND_PTP_DIAGNOSTICS = 0x06;\nconst uint8_t PTC_COMMAND_PTP_STATUS = 0x01;\nconst uint8_t PTC_COMMAND_PTP_PORT_DATA_SET = 0x02;\nconst uint8_t PTC_COMMAND_PTP_TIME_STATUS_NP = 0x03;\nconst uint8_t PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP = 0x04;\nconst uint8_t PTC_COMMAND_GET_INVENTORY_INFO = 0x07;\nconst uint8_t PTC_COMMAND_GET_CONFIG_INFO = 0x08;\nconst uint8_t PTC_COMMAND_GET_LIDAR_STATUS = 0x09;\nconst uint8_t PTC_COMMAND_SET_SPIN_RATE = 0x17;\nconst uint8_t PTC_COMMAND_SET_SYNC_ANGLE = 0x18;\nconst uint8_t PTC_COMMAND_SET_TRIGGER_METHOD = 0x1b;\nconst uint8_t PTC_COMMAND_SET_STANDBY_MODE = 0x1c;\nconst uint8_t PTC_COMMAND_SET_RETURN_MODE = 0x1e;\nconst uint8_t PTC_COMMAND_SET_CLOCK_SOURCE = 0x1f;\nconst uint8_t PTC_COMMAND_SET_DESTINATION_IP = 0x20;\nconst uint8_t PTC_COMMAND_SET_CONTROL_PORT = 0x21;\nconst uint8_t PTC_COMMAND_SET_LIDAR_RANGE = 0x22;\nconst uint8_t PTC_COMMAND_GET_LIDAR_RANGE = 0x23;\nconst uint8_t PTC_COMMAND_SET_PTP_CONFIG = 0x24;\nconst uint8_t PTC_COMMAND_GET_PTP_CONFIG = 0x26;\nconst uint8_t PTC_COMMAND_RESET = 0x25;\nconst uint8_t PTC_COMMAND_SET_ROTATE_DIRECTION = 0x2a;\nconst uint8_t PTC_COMMAND_LIDAR_MONITOR = 0x27;\n\nconst uint16_t PANDARQT64_PACKET_SIZE = 1072;\nconst uint16_t PANDARQT128_PACKET_SIZE = 1127;\nconst uint16_t PANDARXT32_PACKET_SIZE = 1080;\nconst uint16_t PANDARXT32M_PACKET_SIZE = 820;\nconst uint16_t PANDARAT128_PACKET_SIZE = 1118;\nconst uint16_t PANDAR64_PACKET_SIZE = 1194;\nconst uint16_t PANDAR64_EXTENDED_PACKET_SIZE = 1198;\nconst uint16_t PANDAR40_PACKET_SIZE = 1262;\nconst uint16_t PANDAR40P_EXTENDED_PACKET_SIZE = 1266;\nconst uint16_t PANDAR128_E4X_PACKET_SIZE = 861;\nconst uint16_t PANDAR128_E4X_EXTENDED_PACKET_SIZE = 1117;\n\nconst uint16_t MTU_SIZE = 1500;\n\nconst int PTP_LOG_ANNOUNCE_INTERVAL = 1; // Time interval between Announce messages, in units of log seconds (default: 1)\nconst int PTP_SYNC_INTERVAL = 1; //Time interval between Sync messages, in units of log seconds (default: 1)\nconst int PTP_LOG_MIN_DELAY_INTERVAL = 0; //Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0)\n\nconst int HESAI_LIDAR_GPS_CLOCK_SOURCE = 0;\nconst int HESAI_LIDAR_PTP_CLOCK_SOURCE = 1;\n\nclass HesaiHwInterface : NebulaHwInterfaceBase\n{\nprivate:\n  std::unique_ptr&lt;::drivers::common::IoContext&gt; cloud_io_context_;\n  std::shared_ptr&lt;boost::asio::io_context&gt; m_owned_ctx;\n  std::shared_ptr&lt;boost::asio::io_context&gt; m_owned_ctx_s;\n  std::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; cloud_udp_driver_;\n  std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; tcp_driver_;\n  std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; tcp_driver_s_;\n  std::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration_;\n  std::shared_ptr&lt;HesaiCalibrationConfiguration&gt; calibration_configuration_;\n  size_t azimuth_index_{};\n  size_t mtu_size_{};\n  std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; scan_cloud_ptr_;\n  std::function&lt;bool(size_t)&gt;\n    is_valid_packet_; /*Lambda Function Array to verify proper packet size*/\n  std::function&lt;void(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; buffer)&gt;\n    scan_reception_callback_; \n  int prev_phase_{};\n\n  int timeout_ = 2000;\n  std::timed_mutex tm_;\n  int tm_fail_cnt = 0;\n  int tm_fail_cnt_max = 0;\n  std::timed_mutex tms_;\n  int tms_fail_cnt = 0;\n  int tms_fail_cnt_max = 3;\n  bool wl = false;\n  bool is_solid_state = false;\n  int target_model_no;\n\n  HesaiStatus GetHttpClientDriverOnce(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\n  HesaiStatus GetHttpClientDriverOnce(\n    std::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\n  void str_cb(const std::string &amp; str);\n\n  bool CheckLock(std::timed_mutex &amp; tm, int &amp; fail_cnt, const int &amp; fail_cnt_max, std::string name);\n  void CheckUnlock(std::timed_mutex &amp; tm, std::string name);\n\n  std::shared_ptr&lt;rclcpp::Logger&gt; parent_node_logger;\n  void PrintInfo(std::string info);\n  void PrintError(std::string error);\n  void PrintDebug(std::string debug);\n  void PrintDebug(const std::vector&lt;uint8_t&gt; &amp; bytes);\n\npublic:\n  HesaiHwInterface();\n  ~HesaiHwInterface();\n  Status InitializeTcpDriver(bool setup_sensor = true);\n  Status FinalizeTcpDriver();\n  boost::property_tree::ptree ParseJson(const std::string &amp; str);\n\n  void ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) final;\n  Status CloudInterfaceStart() final;\n  Status CloudInterfaceStop() final;\n  Status GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) final;\n  Status GetCalibrationConfiguration(CalibrationConfigurationBase &amp; calibration_configuration);\n  Status SetSensorConfiguration(\n    std::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) final;\n  Status RegisterScanCallback(\n    std::function&lt;void(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt;)&gt; scan_callback);\n  Status syncGetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback);\n  Status syncGetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  Status syncGetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver);\n  Status syncGetLidarCalibration(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  Status syncGetLidarCalibration(std::shared_ptr&lt;boost::asio::io_context&gt; ctx);\n  Status syncGetLidarCalibrationFromSensor(\n    std::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback);\n  Status syncGetLidarCalibrationFromSensor(\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  Status syncGetLidarCalibrationFromSensor();\n  Status GetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback,\n    bool with_run = true);\n  Status GetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\n  Status GetLidarCalibration(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetLidarCalibration(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\n  Status GetLidarCalibration(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetLidarCalibrationFromSensor(\n    std::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback,\n    bool with_run = true);\n  Status GetLidarCalibrationFromSensor(\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\n  Status GetLidarCalibrationFromSensor(bool with_run = true);\n  Status GetPtpDiagStatus(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetPtpDiagStatus(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetPtpDiagStatus(bool with_run = true);\n  Status GetPtpDiagPort(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetPtpDiagPort(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetPtpDiagPort(bool with_run = true);\n  Status GetPtpDiagTime(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetPtpDiagTime(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetPtpDiagTime(bool with_run = true);\n  Status GetPtpDiagGrandmaster(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetPtpDiagGrandmaster(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetPtpDiagGrandmaster(bool with_run = true);\n\n  Status syncGetInventory(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiInventory &amp; result)&gt; callback);\n  Status syncGetInventory(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver);\n  Status syncGetInventory(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiInventory &amp; result)&gt; callback);\n  Status syncGetInventory(std::shared_ptr&lt;boost::asio::io_context&gt; ctx);\n  Status syncGetInventory(std::function&lt;void(HesaiInventory &amp; result)&gt; callback);\n\n  Status GetInventory(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\n  Status GetInventory(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\n  Status GetInventory(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetInventory(std::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\n  Status GetInventory(bool with_run = true);\n  Status GetConfig(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\n  Status GetConfig(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\n  Status GetConfig(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetConfig(std::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\n  Status GetConfig(bool with_run = true);\n  Status GetLidarStatus(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarStatus(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarStatus(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetLidarStatus(\n    std::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarStatus(bool with_run = true);\n  Status SetSpinRate(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, uint16_t rpm,\n    bool with_run = true);\n  Status SetSpinRate(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, uint16_t rpm, bool with_run = true);\n  Status SetSpinRate(uint16_t rpm, bool with_run = true);\n  Status SetSyncAngle(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int sync_angle, int angle,\n    bool with_run = true);\n  Status SetSyncAngle(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int sync_angle, int angle, bool with_run = true);\n  Status SetSyncAngle(int sync_angle, int angle, bool with_run = true);\n  Status SetTriggerMethod(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int trigger_method,\n    bool with_run = true);\n  Status SetTriggerMethod(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int trigger_method, bool with_run = true);\n  Status SetTriggerMethod(int trigger_method, bool with_run = true);\n  Status SetStandbyMode(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int standby_mode,\n    bool with_run = true);\n  Status SetStandbyMode(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int standby_mode, bool with_run = true);\n  Status SetStandbyMode(int standby_mode, bool with_run = true);\n  Status SetReturnMode(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int return_mode,\n    bool with_run = true);\n  Status SetReturnMode(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int return_mode, bool with_run = true);\n  Status SetReturnMode(int return_mode, bool with_run = true);\n  Status SetDestinationIp(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int dest_ip_1,\n    int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run = true);\n  Status SetDestinationIp(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int dest_ip_1, int dest_ip_2, int dest_ip_3,\n    int dest_ip_4, int port, int gps_port, bool with_run = true);\n  Status SetDestinationIp(\n    int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port,\n    bool with_run = true);\n  Status SetControlPort(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int ip_1, int ip_2,\n    int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1,\n    int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run = true);\n  Status SetControlPort(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int ip_1, int ip_2, int ip_3, int ip_4,\n    int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3,\n    int gateway_4, int vlan_flg, int vlan_id, bool with_run = true);\n  Status SetControlPort(\n    int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4,\n    int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id,\n    bool with_run = true);\n  Status SetLidarRange(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int method,\n    std::vector&lt;unsigned char&gt; data, bool with_run = true);\n  Status SetLidarRange(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int method, std::vector&lt;unsigned char&gt; data,\n    bool with_run = true);\n  Status SetLidarRange(int method, std::vector&lt;unsigned char&gt; data, bool with_run = true);\n  Status SetLidarRange(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int start, int end,\n    bool with_run = true);\n  Status SetLidarRange(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int start, int end, bool with_run = true);\n  Status SetLidarRange(int start, int end, bool with_run = true);\n  Status GetLidarRange(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarRange(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarRange(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetLidarRange(\n    std::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarRange(bool with_run = true);\n\n  Status SetClockSource(std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int clock_source, bool with_run);\n  Status SetClockSource(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int clock_source, bool with_run);\n  Status SetClockSource(int clock_source, bool with_run = true);\n\n  Status SetPtpConfig(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int profile, int domain,\n    int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval,\n    bool with_run = true);\n  Status SetPtpConfig(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int profile, int domain, int network,\n    int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run = true);\n  Status SetPtpConfig(\n    int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval,\n    int logMinDelayReqInterval, bool with_run = true);\n  Status GetPtpConfig(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status GetPtpConfig(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetPtpConfig(bool with_run = true);\n  Status SendReset(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\n  Status SendReset(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status SendReset(bool with_run = true);\n  Status SetRotDir(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int mode,\n    bool with_run = true);\n  Status SetRotDir(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int mode, bool with_run = true);\n  Status SetRotDir(int mode, bool with_run = true);\n  Status GetLidarMonitor(\n    std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\n    std::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarMonitor(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarMonitor(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\n  Status GetLidarMonitor(\n    std::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\n  Status GetLidarMonitor(bool with_run = true);\n\n  void IOContextRun();\n  std::shared_ptr&lt;boost::asio::io_context&gt; GetIOContext();\n\n  HesaiStatus SetSpinSpeedAsyncHttp(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, uint16_t rpm);\n  HesaiStatus SetSpinSpeedAsyncHttp(uint16_t rpm);\n\n  HesaiStatus SetPtpConfigSyncHttp(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    int profile,\n    int domain,\n    int network,\n    int logAnnounceInterval,\n    int logSyncInterval,\n    int logMinDelayReqInterval);\n  HesaiStatus SetPtpConfigSyncHttp(int profile,\n                                   int domain,\n                                   int network,\n                                   int logAnnounceInterval,\n                                   int logSyncInterval,\n                                   int logMinDelayReqInterval);\n  HesaiStatus SetSyncAngleSyncHttp(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    int enable,\n    int angle);\n  HesaiStatus SetSyncAngleSyncHttp(int enable, int angle);\n\n\n\n  HesaiStatus GetLidarMonitorAsyncHttp(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  HesaiStatus GetLidarMonitorAsyncHttp(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n\n  HesaiStatus CheckAndSetConfig(\n    std::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration, HesaiConfig hesai_config);\n  HesaiStatus CheckAndSetConfig(\n    std::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration,\n    HesaiLidarRangeAll hesai_lidar_range_all);\n  HesaiStatus CheckAndSetConfig();\n\n  int NebulaModelToHesaiModelNo(nebula::drivers::SensorModel model);\n\n  void SetTargetModel(int model);\n\n  void SetTargetModel(nebula::drivers::SensorModel model);\n\n  bool UseHttpSetSpinRate(int model);\n  bool UseHttpSetSpinRate();\n  bool UseHttpGetLidarMonitor(int model);\n  bool UseHttpGetLidarMonitor();\n\n  void SetLogger(std::shared_ptr&lt;rclcpp::Logger&gt; node);\n};\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_HW_INTERFACE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/dir_a9a0cb367b5480698fb99498d17f5797/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_robosense","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_robosense</p>"},{"location":"nebula_hw_interfaces/dir_a9a0cb367b5480698fb99498d17f5797/#files","title":"Files","text":"Type Name file robosense_hw_interface.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_robosense/</code></p>"},{"location":"nebula_hw_interfaces/robosense__hw__interface_8hpp/","title":"File robosense_hw_interface.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_robosense &gt; robosense_hw_interface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/version.hpp&gt;</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"robosense_msgs/msg/robosense_info_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> </ul>"},{"location":"nebula_hw_interfaces/robosense__hw__interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/robosense__hw__interface_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseHwInterface Hardware interface of Robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/robosense__hw__interface_8hpp_source/","title":"File robosense_hw_interface.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_robosense &gt; robosense_hw_interface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// Have to define macros to silence warnings about deprecated headers being used by\n// boost/property_tree/ in some versions of boost.\n// See: https://github.com/boostorg/property_tree/issues/51\n#include &lt;boost/version.hpp&gt;\n#if (BOOST_VERSION / 100 &gt;= 1073 &amp;&amp; BOOST_VERSION / 100 &lt;= 1076)  // Boost 1.73 - 1.76\n#define BOOST_BIND_GLOBAL_PLACEHOLDERS\n#endif\n#if (BOOST_VERSION / 100 == 1074)  // Boost 1.74\n#define BOOST_ALLOW_DEPRECATED_HEADERS\n#endif\n\n#include \"boost_udp_driver/udp_driver.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"robosense_msgs/msg/robosense_info_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\nnamespace nebula\n{\nnamespace drivers\n{\nconstexpr uint16_t MTU_SIZE = 1248;\nconstexpr uint16_t HELIOS_PACKET_SIZE = 1248;\nconstexpr uint16_t HELIOS_INFO_PACKET_SIZE = 1248;\nconstexpr uint16_t BPEARL_PACKET_SIZE = 1248;\nconstexpr uint16_t BPEARL_INFO_PACKET_SIZE = 1248;\n\nclass RobosenseHwInterface : NebulaHwInterfaceBase\n{\nprivate:\n  std::unique_ptr&lt;::drivers::common::IoContext&gt; cloud_io_context_;\n  std::unique_ptr&lt;::drivers::common::IoContext&gt; info_io_context_;\n  std::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; cloud_udp_driver_;\n  std::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; info_udp_driver_;\n  std::shared_ptr&lt;RobosenseSensorConfiguration&gt; sensor_configuration_;\n  std::unique_ptr&lt;robosense_msgs::msg::RobosenseScan&gt; scan_cloud_ptr_;\n  size_t azimuth_index_{44};  // For Helios and Bpearl 42 byte header + 2 byte flag\n  int prev_phase_{};\n  std::atomic&lt;bool&gt; is_info_received{false};         // To check if DIFOP is received\n  std::optional&lt;std::vector&lt;uint8_t&gt;&gt; info_buffer_;  // To hold DIFOP data\n  std::optional&lt;SensorModel&gt; sensor_model_;          // To hold sensor model\n  std::function&lt;bool(size_t)&gt;\n    is_valid_packet_; /*Lambda Function Array to verify proper packet size for data*/\n  std::function&lt;bool(size_t)&gt;\n    is_valid_info_packet_; /*Lambda Function Array to verify proper packet size for info*/\n  std::function&lt;void(std::unique_ptr&lt;robosense_msgs::msg::RobosenseScan&gt; buffer)&gt;\n    scan_reception_callback_; \n  std::function&lt;void(std::unique_ptr&lt;robosense_msgs::msg::RobosenseInfoPacket&gt; buffer)&gt;\n    info_reception_callback_; \n  std::shared_ptr&lt;rclcpp::Logger&gt; parent_node_logger_;\n\n  void PrintInfo(std::string info);\n\n  void PrintDebug(std::string debug);\n\npublic:\n  RobosenseHwInterface();\n\n  void ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) final;\n\n  void ReceiveInfoPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer);\n\n  Status CloudInterfaceStart() final;\n\n  Status InfoInterfaceStart();\n\n  Status CloudInterfaceStop() final;\n\n  Status SetSensorConfiguration(\n    std::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) final;\n\n  Status GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) final;\n\n  Status GetCalibrationConfiguration(\n    CalibrationConfigurationBase &amp; calibration_configuration) override;\n\n  Status RegisterScanCallback(\n    std::function&lt;void(std::unique_ptr&lt;robosense_msgs::msg::RobosenseScan&gt;)&gt; scan_callback);\n\n  Status RegisterInfoCallback(\n    std::function&lt;void(std::unique_ptr&lt;robosense_msgs::msg::RobosenseInfoPacket&gt;)&gt; info_callback);\n\n  void SetLogger(std::shared_ptr&lt;rclcpp::Logger&gt; logger);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_hw_interfaces/dir_dfdaa22cf10ea0df1458ba0ebc4d9e9c/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne</p>"},{"location":"nebula_hw_interfaces/dir_dfdaa22cf10ea0df1458ba0ebc4d9e9c/#files","title":"Files","text":"Type Name file velodyne_hw_interface.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/</code></p>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/","title":"File velodyne_hw_interface.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne &gt; velodyne_hw_interface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/version.hpp&gt;</code></li> <li><code>#include \"boost_tcp_driver/http_client_driver.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_status.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/json_parser.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/ptree.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwInterface Hardware interface of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp_source/","title":"File velodyne_hw_interface.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne &gt; velodyne_hw_interface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_HW_INTERFACE_H\n#define NEBULA_VELODYNE_HW_INTERFACE_H\n\n// Have to define macros to silence warnings about deprecated headers being used by\n// boost/property_tree/ in some versions of boost.\n// See: https://github.com/boostorg/property_tree/issues/51\n#include &lt;boost/version.hpp&gt;\n#if (BOOST_VERSION / 100 &gt;= 1073 &amp;&amp; BOOST_VERSION / 100 &lt;= 1076)  // Boost 1.73 - 1.76\n#define BOOST_BIND_GLOBAL_PLACEHOLDERS\n#endif\n#if (BOOST_VERSION / 100 == 1074)  // Boost 1.74\n#define BOOST_ALLOW_DEPRECATED_HEADERS\n#endif\n#include \"boost_tcp_driver/http_client_driver.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_status.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;boost/property_tree/json_parser.hpp&gt;\n#include &lt;boost/property_tree/ptree.hpp&gt;\n\n#include &lt;memory&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass VelodyneHwInterface : NebulaHwInterfaceBase\n{\nprivate:\n  std::unique_ptr&lt;::drivers::common::IoContext&gt; cloud_io_context_;\n  std::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; cloud_udp_driver_;\n  std::shared_ptr&lt;VelodyneSensorConfiguration&gt; sensor_configuration_;\n  std::shared_ptr&lt;VelodyneCalibrationConfiguration&gt; calibration_configuration_;\n  std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; scan_cloud_ptr_;\n  std::function&lt;bool(size_t)&gt;\n    is_valid_packet_; /*Lambda Function Array to verify proper packet size*/\n  std::function&lt;void(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; buffer)&gt;\n    scan_reception_callback_; \n  uint16_t packet_first_azm_ = 0;\n  uint16_t packet_first_azm_phased_ = 0;\n  uint16_t packet_last_azm_ = 0;\n  uint16_t packet_last_azm_phased_ = 0;\n  uint16_t prev_packet_first_azm_phased_ = 0;\n  uint16_t phase_ = 0;\n  uint processed_packets_ = 0;\n\n  std::shared_ptr&lt;boost::asio::io_context&gt; boost_ctx_;\n  std::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; http_client_driver_;\n\n  std::string TARGET_STATUS{\"/cgi/status.json\"};\n  std::string TARGET_DIAG{\"/cgi/diag.json\"};\n  std::string TARGET_SNAPSHOT{\"/cgi/snapshot.hdl\"};\n  std::string TARGET_SETTING{\"/cgi/setting\"};\n  std::string TARGET_FOV{\"/cgi/setting/fov\"};\n  std::string TARGET_HOST{\"/cgi/setting/host\"};\n  std::string TARGET_NET{\"/cgi/setting/net\"};\n  std::string TARGET_SAVE{\"/cgi/save\"};\n  std::string TARGET_RESET{\"/cgi/reset\"};\n  void StringCallback(const std::string &amp; str);\n\n  VelodyneStatus GetHttpClientDriverOnce(\n    std::shared_ptr&lt;boost::asio::io_context&gt; ctx,\n    std::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\n  VelodyneStatus GetHttpClientDriverOnce(\n    std::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\n\n  VelodyneStatus CheckAndSetConfig(\n    std::shared_ptr&lt;VelodyneSensorConfiguration&gt; sensor_configuration,\n    boost::property_tree::ptree tree);\n\n  std::shared_ptr&lt;rclcpp::Logger&gt; parent_node_logger;\n  void PrintInfo(std::string info);\n  void PrintError(std::string error);\n  void PrintDebug(std::string debug);\n\npublic:\n  VelodyneHwInterface();\n\n  void ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) final;\n  Status CloudInterfaceStart() final;\n  Status CloudInterfaceStop() final;\n  Status GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) final;\n  Status GetCalibrationConfiguration(\n    CalibrationConfigurationBase &amp; calibration_configuration) final;\n  Status InitializeSensorConfiguration(\n    std::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration);\n  Status SetSensorConfiguration(\n    std::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) final;\n  Status RegisterScanCallback(\n    std::function&lt;void(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt;)&gt; scan_callback);\n\n  boost::property_tree::ptree ParseJson(const std::string &amp; str);\n\n  VelodyneStatus InitHttpClient();\n  std::string GetStatus();\n  std::string GetDiag();\n  std::string GetSnapshot();\n  VelodyneStatus SetRpm(uint16_t rpm);\n  VelodyneStatus SetFovStart(uint16_t fov_start);\n  VelodyneStatus SetFovEnd(uint16_t fov_end);\n  VelodyneStatus SetReturnType(ReturnMode return_mode);\n  VelodyneStatus SaveConfig();\n  VelodyneStatus ResetSystem();\n  VelodyneStatus LaserOn();\n  VelodyneStatus LaserOff();\n  VelodyneStatus LaserOnOff(bool on);\n  VelodyneStatus SetHostAddr(std::string addr);\n  VelodyneStatus SetHostDport(uint16_t dport);\n  VelodyneStatus SetHostTport(uint16_t tport);\n  VelodyneStatus SetNetAddr(std::string addr);\n  VelodyneStatus SetNetMask(std::string mask);\n  VelodyneStatus SetNetGateway(std::string gateway);\n  VelodyneStatus SetNetDhcp(bool use_dhcp);\n\n  VelodyneStatus InitHttpClientAsync();\n  VelodyneStatus GetStatusAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  VelodyneStatus GetStatusAsync();\n  VelodyneStatus GetDiagAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  VelodyneStatus GetDiagAsync();\n  VelodyneStatus GetSnapshotAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n  VelodyneStatus GetSnapshotAsync();\n  VelodyneStatus CheckAndSetConfigBySnapshotAsync(\n    std::shared_ptr&lt;VelodyneSensorConfiguration&gt; sensor_configuration);\n  VelodyneStatus SetRpmAsync(uint16_t rpm);\n  VelodyneStatus SetFovStartAsync(uint16_t fov_start);\n  VelodyneStatus SetFovEndAsync(uint16_t fov_end);\n  VelodyneStatus SetReturnTypeAsync(ReturnMode return_mode);\n  VelodyneStatus SaveConfigAsync();\n  VelodyneStatus ResetSystemAsync();\n  VelodyneStatus LaserOnAsync();\n  VelodyneStatus LaserOffAsync();\n  VelodyneStatus LaserOnOffAsync(bool on);\n  VelodyneStatus SetHostAddrAsync(std::string addr);\n  VelodyneStatus SetHostDportAsync(uint16_t dport);\n  VelodyneStatus SetHostTportAsync(uint16_t tport);\n  VelodyneStatus SetNetAddrAsync(std::string addr);\n  VelodyneStatus SetNetMaskAsync(std::string mask);\n  VelodyneStatus SetNetGatewayAsync(std::string gateway);\n  VelodyneStatus SetNetDhcpAsync(bool use_dhcp);\n\n  void SetLogger(std::shared_ptr&lt;rclcpp::Logger&gt; node);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_HW_INTERFACE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/classes/","title":"Class Index","text":""},{"location":"nebula_hw_interfaces/classes/#h","title":"h","text":"<ul> <li>HesaiConfig (nebula)</li> <li>HesaiHwInterface (nebula::drivers)</li> <li>HesaiInventory (nebula)</li> <li>HesaiLidarMonitor (nebula)</li> <li>HesaiLidarRangeAll (nebula)</li> <li>HesaiLidarStatus (nebula)</li> <li>HesaiPtpConfig (nebula)</li> <li>HesaiPtpDiagGrandmaster (nebula)</li> <li>HesaiPtpDiagPort (nebula)</li> <li>HesaiPtpDiagStatus (nebula)</li> <li>HesaiPtpDiagTime (nebula)</li> </ul>"},{"location":"nebula_hw_interfaces/classes/#n","title":"n","text":"<ul> <li>NebulaHwInterfaceBase (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/classes/#r","title":"r","text":"<ul> <li>RobosenseHwInterface (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/classes/#v","title":"v","text":"<ul> <li>VelodyneHwInterface (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. <ul> <li>class nebula::drivers::HesaiHwInterface Hardware interface of hesai driver. </li> <li>class nebula::drivers::RobosenseHwInterface Hardware interface of Robosense driver. </li> <li>class nebula::drivers::VelodyneHwInterface Hardware interface of velodyne driver. </li> </ul> </li> <li>struct nebula::HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO </li> <li>struct nebula::HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO </li> <li>struct nebula::HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR </li> <li>struct nebula::HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE </li> <li>struct nebula::HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS </li> <li>struct nebula::HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG </li> <li>struct nebula::HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> </ul>"},{"location":"nebula_hw_interfaces/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_hw_interfaces/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_hw_interfaces/class_members/","title":"Class Members","text":""},{"location":"nebula_hw_interfaces/class_members/#a","title":"a","text":"<ul> <li>angle_offset (nebula::HesaiInventory)</li> <li>announceReceiptTimeout (nebula::HesaiPtpDiagPort)</li> <li>azimuth_index_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#b","title":"b","text":"<ul> <li>boost_ctx_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#c","title":"c","text":"<ul> <li>clock_data_fmt (nebula::HesaiConfig)</li> <li>clock_source (nebula::HesaiConfig)</li> <li>control_fw_ver (nebula::HesaiInventory)</li> <li>clockQuality (nebula::HesaiPtpDiagGrandmaster)</li> <li>cumulativeScaledRateOffset (nebula::HesaiPtpDiagTime)</li> <li>CheckAndSetConfig (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckLock (nebula::drivers::HesaiHwInterface)</li> <li>CheckUnlock (nebula::drivers::HesaiHwInterface)</li> <li>CloudInterfaceStart (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CloudInterfaceStop (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>calibration_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_io_context_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_udp_driver_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckAndSetConfigBySnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#d","title":"d","text":"<ul> <li>dest_LiDAR_udp_port (nebula::HesaiConfig)</li> <li>dest_gps_udp_port (nebula::HesaiConfig)</li> <li>dest_ipaddr (nebula::HesaiConfig)</li> <li>date_of_manufacture (nebula::HesaiInventory)</li> <li>domain (nebula::HesaiPtpConfig)</li> <li>delayMechanism (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#e","title":"e","text":"<ul> <li>end (nebula::HesaiLidarRangeAll)</li> <li>elapsed_millisec (nebula::HesaiPtpDiagStatus)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#f","title":"f","text":"<ul> <li>FinalizeTcpDriver (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#g","title":"g","text":"<ul> <li>gateway (nebula::HesaiConfig)</li> <li>get_str_model (nebula::HesaiInventory)</li> <li>get_str_gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>get_str_gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>get_str_ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>gmIdentity (nebula::HesaiPtpDiagTime)</li> <li>gmPresent (nebula::HesaiPtpDiagTime)</li> <li>gmTimeBaseIndicator (nebula::HesaiPtpDiagTime)</li> <li>GetCalibrationConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetHttpClientDriverOnce (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetIOContext (nebula::drivers::HesaiHwInterface)</li> <li>GetInventory (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitorAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagGrandmaster (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagPort (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagTime (nebula::drivers::HesaiHwInterface)</li> <li>GetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetDiag (nebula::drivers::VelodyneHwInterface)</li> <li>GetDiagAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshot (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatus (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatusAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#h","title":"h","text":"<ul> <li>HesaiInventory (nebula::HesaiInventory)</li> <li>hw_ver (nebula::HesaiInventory)</li> <li>HesaiLidarStatus (nebula::HesaiLidarStatus)</li> <li>HesaiPtpDiagPort (nebula::HesaiPtpDiagPort)</li> <li>HesaiPtpDiagTime (nebula::HesaiPtpDiagTime)</li> <li>HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> <li>http_client_driver_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#i","title":"i","text":"<ul> <li>ipaddr (nebula::HesaiConfig)</li> <li>input_current (nebula::HesaiLidarMonitor)</li> <li>input_power (nebula::HesaiLidarMonitor)</li> <li>input_voltage (nebula::HesaiLidarMonitor)</li> <li>ingress_time (nebula::HesaiPtpDiagTime)</li> <li>IOContextRun (nebula::drivers::HesaiHwInterface)</li> <li>InitializeTcpDriver (nebula::drivers::HesaiHwInterface)</li> <li>is_solid_state (nebula::drivers::HesaiHwInterface)</li> <li>is_valid_packet_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>InfoInterfaceStart (nebula::drivers::RobosenseHwInterface)</li> <li>info_buffer_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_io_context_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_reception_callback_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_udp_driver_ (nebula::drivers::RobosenseHwInterface)</li> <li>is_info_received (nebula::drivers::RobosenseHwInterface)</li> <li>is_valid_info_packet_ (nebula::drivers::RobosenseHwInterface)</li> <li>InitHttpClient (nebula::drivers::VelodyneHwInterface)</li> <li>InitHttpClientAsync (nebula::drivers::VelodyneHwInterface)</li> <li>InitializeSensorConfiguration (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#l","title":"l","text":"<ul> <li>logAnnounceInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinDelayReqInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logSyncInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinPdelayReqInterval (nebula::HesaiPtpDiagPort)</li> <li>lastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>LaserOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOffAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOn (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOffAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#m","title":"m","text":"<ul> <li>mask (nebula::HesaiConfig)</li> <li>motor_status (nebula::HesaiConfig)</li> <li>mac (nebula::HesaiInventory)</li> <li>model (nebula::HesaiInventory)</li> <li>motor_type (nebula::HesaiInventory)</li> <li>method (nebula::HesaiLidarRangeAll)</li> <li>motor_speed (nebula::HesaiLidarStatus)</li> <li>master_offset (nebula::HesaiPtpDiagStatus, nebula::HesaiPtpDiagTime)</li> <li>m_owned_ctx (nebula::drivers::HesaiHwInterface)</li> <li>m_owned_ctx_s (nebula::drivers::HesaiHwInterface)</li> <li>mtu_size_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#n","title":"n","text":"<ul> <li>noise_filtering (nebula::HesaiConfig)</li> <li>num_of_lines (nebula::HesaiInventory)</li> <li>network (nebula::HesaiPtpConfig)</li> <li>NebulaModelToHesaiModelNo (nebula::drivers::HesaiHwInterface)</li> <li>NebulaHwInterfaceBase (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#p","title":"p","text":"<ul> <li>ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>profile (nebula::HesaiPtpConfig)</li> <li>peerMeanPathDelay (nebula::HesaiPtpDiagPort)</li> <li>portIdentity (nebula::HesaiPtpDiagPort)</li> <li>portState (nebula::HesaiPtpDiagPort)</li> <li>ptp_state (nebula::HesaiPtpDiagStatus)</li> <li>ParseJson (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintDebug (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintError (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintInfo (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>parent_node_logger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>prev_phase_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface)</li> <li>parent_node_logger_ (nebula::drivers::RobosenseHwInterface)</li> <li>packet_first_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>phase_ (nebula::drivers::VelodyneHwInterface)</li> <li>prev_packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>processed_packets_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#r","title":"r","text":"<ul> <li>reflectivity_mapping (nebula::HesaiConfig)</li> <li>reserved (nebula::HesaiConfig, nebula::HesaiInventory, nebula::HesaiLidarMonitor, nebula::HesaiLidarStatus)</li> <li>return_mode (nebula::HesaiConfig)</li> <li>ReceiveCloudPacketCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>RegisterScanCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>ReceiveInfoPacketCallback (nebula::drivers::RobosenseHwInterface)</li> <li>RegisterInfoCallback (nebula::drivers::RobosenseHwInterface)</li> <li>RobosenseHwInterface (nebula::drivers::RobosenseHwInterface)</li> <li>ResetSystem (nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystemAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#s","title":"s","text":"<ul> <li>spin_rate (nebula::HesaiConfig)</li> <li>standby_mode (nebula::HesaiConfig)</li> <li>start_angle (nebula::HesaiConfig)</li> <li>stop_angle (nebula::HesaiConfig)</li> <li>sync (nebula::HesaiConfig)</li> <li>sync_angle (nebula::HesaiConfig)</li> <li>sensor_fw_ver (nebula::HesaiInventory)</li> <li>sn (nebula::HesaiInventory)</li> <li>sw_ver (nebula::HesaiInventory)</li> <li>start (nebula::HesaiLidarRangeAll)</li> <li>startup_times (nebula::HesaiLidarStatus)</li> <li>system_uptime (nebula::HesaiLidarStatus)</li> <li>status (nebula::HesaiPtpConfig)</li> <li>scaledLastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>SendReset (nebula::drivers::HesaiHwInterface)</li> <li>SetClockSource (nebula::drivers::HesaiHwInterface)</li> <li>SetControlPort (nebula::drivers::HesaiHwInterface)</li> <li>SetDestinationIp (nebula::drivers::HesaiHwInterface)</li> <li>SetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>SetLogger (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>SetPtpConfigSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetReturnMode (nebula::drivers::HesaiHwInterface)</li> <li>SetRotDir (nebula::drivers::HesaiHwInterface)</li> <li>SetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetSpinRate (nebula::drivers::HesaiHwInterface)</li> <li>SetSpinSpeedAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetStandbyMode (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngle (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngleSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetTargetModel (nebula::drivers::HesaiHwInterface)</li> <li>SetTriggerMethod (nebula::drivers::HesaiHwInterface)</li> <li>scan_cloud_ptr_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>scan_reception_callback_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>sensor_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>str_cb (nebula::drivers::HesaiHwInterface)</li> <li>syncGetInventory (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>sensor_model_ (nebula::drivers::RobosenseHwInterface)</li> <li>SaveConfig (nebula::drivers::VelodyneHwInterface)</li> <li>SaveConfigAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEnd (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEndAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStart (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStartAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcp (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcpAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGateway (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGatewayAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMask (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMaskAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnType (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnTypeAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpm (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpmAsync (nebula::drivers::VelodyneHwInterface)</li> <li>StringCallback (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#t","title":"t","text":"<ul> <li>trigger_method (nebula::HesaiConfig)</li> <li>temperature (nebula::HesaiLidarStatus)</li> <li>total_operation_time (nebula::HesaiLidarStatus)</li> <li>time_flags (nebula::HesaiPtpDiagGrandmaster)</li> <li>time_source (nebula::HesaiPtpDiagGrandmaster)</li> <li>target_model_no (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_ (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_s_ (nebula::drivers::HesaiHwInterface)</li> <li>timeout_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>tms_ (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>TARGET_DIAG (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_FOV (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_HOST (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_NET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_RESET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SAVE (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SETTING (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SNAPSHOT (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_STATUS (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#u","title":"u","text":"<ul> <li>udp_seq (nebula::HesaiConfig)</li> <li>utc_offset (nebula::HesaiPtpDiagGrandmaster)</li> <li>UseHttpGetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>UseHttpSetSpinRate (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#v","title":"v","text":"<ul> <li>vlan_flag (nebula::HesaiConfig)</li> <li>vlan_id (nebula::HesaiConfig)</li> <li>versionNumber (nebula::HesaiPtpDiagPort)</li> <li>VelodyneHwInterface (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#w","title":"w","text":"<ul> <li>wl (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#_1","title":"~","text":"<ul> <li>~HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_hw_interfaces/class_member_functions/#c","title":"c","text":"<ul> <li>CheckAndSetConfig (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckLock (nebula::drivers::HesaiHwInterface)</li> <li>CheckUnlock (nebula::drivers::HesaiHwInterface)</li> <li>CloudInterfaceStart (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CloudInterfaceStop (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckAndSetConfigBySnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#f","title":"f","text":"<ul> <li>FinalizeTcpDriver (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#g","title":"g","text":"<ul> <li>get_str_model (nebula::HesaiInventory)</li> <li>get_str_gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>get_str_gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>get_str_ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>GetCalibrationConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetHttpClientDriverOnce (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetIOContext (nebula::drivers::HesaiHwInterface)</li> <li>GetInventory (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitorAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagGrandmaster (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagPort (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagTime (nebula::drivers::HesaiHwInterface)</li> <li>GetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetDiag (nebula::drivers::VelodyneHwInterface)</li> <li>GetDiagAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshot (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatus (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatusAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiInventory (nebula::HesaiInventory)</li> <li>HesaiLidarStatus (nebula::HesaiLidarStatus)</li> <li>HesaiPtpDiagPort (nebula::HesaiPtpDiagPort)</li> <li>HesaiPtpDiagTime (nebula::HesaiPtpDiagTime)</li> <li>HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#i","title":"i","text":"<ul> <li>IOContextRun (nebula::drivers::HesaiHwInterface)</li> <li>InitializeTcpDriver (nebula::drivers::HesaiHwInterface)</li> <li>InfoInterfaceStart (nebula::drivers::RobosenseHwInterface)</li> <li>InitHttpClient (nebula::drivers::VelodyneHwInterface)</li> <li>InitHttpClientAsync (nebula::drivers::VelodyneHwInterface)</li> <li>InitializeSensorConfiguration (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#l","title":"l","text":"<ul> <li>LaserOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOffAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOn (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOffAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaModelToHesaiModelNo (nebula::drivers::HesaiHwInterface)</li> <li>NebulaHwInterfaceBase (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#p","title":"p","text":"<ul> <li>ParseJson (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintDebug (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintError (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintInfo (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#r","title":"r","text":"<ul> <li>ReceiveCloudPacketCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>RegisterScanCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>ReceiveInfoPacketCallback (nebula::drivers::RobosenseHwInterface)</li> <li>RegisterInfoCallback (nebula::drivers::RobosenseHwInterface)</li> <li>RobosenseHwInterface (nebula::drivers::RobosenseHwInterface)</li> <li>ResetSystem (nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystemAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#s","title":"s","text":"<ul> <li>SendReset (nebula::drivers::HesaiHwInterface)</li> <li>SetClockSource (nebula::drivers::HesaiHwInterface)</li> <li>SetControlPort (nebula::drivers::HesaiHwInterface)</li> <li>SetDestinationIp (nebula::drivers::HesaiHwInterface)</li> <li>SetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>SetLogger (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>SetPtpConfigSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetReturnMode (nebula::drivers::HesaiHwInterface)</li> <li>SetRotDir (nebula::drivers::HesaiHwInterface)</li> <li>SetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetSpinRate (nebula::drivers::HesaiHwInterface)</li> <li>SetSpinSpeedAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetStandbyMode (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngle (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngleSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetTargetModel (nebula::drivers::HesaiHwInterface)</li> <li>SetTriggerMethod (nebula::drivers::HesaiHwInterface)</li> <li>str_cb (nebula::drivers::HesaiHwInterface)</li> <li>syncGetInventory (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>SaveConfig (nebula::drivers::VelodyneHwInterface)</li> <li>SaveConfigAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEnd (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEndAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStart (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStartAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcp (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcpAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGateway (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGatewayAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMask (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMaskAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnType (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnTypeAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpm (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpmAsync (nebula::drivers::VelodyneHwInterface)</li> <li>StringCallback (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#u","title":"u","text":"<ul> <li>UseHttpGetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>UseHttpSetSpinRate (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneHwInterface (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#_1","title":"~","text":"<ul> <li>~HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_hw_interfaces/class_member_variables/#a","title":"a","text":"<ul> <li>angle_offset (nebula::HesaiInventory)</li> <li>announceReceiptTimeout (nebula::HesaiPtpDiagPort)</li> <li>azimuth_index_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#b","title":"b","text":"<ul> <li>boost_ctx_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#c","title":"c","text":"<ul> <li>clock_data_fmt (nebula::HesaiConfig)</li> <li>clock_source (nebula::HesaiConfig)</li> <li>control_fw_ver (nebula::HesaiInventory)</li> <li>clockQuality (nebula::HesaiPtpDiagGrandmaster)</li> <li>cumulativeScaledRateOffset (nebula::HesaiPtpDiagTime)</li> <li>calibration_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_io_context_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_udp_driver_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#d","title":"d","text":"<ul> <li>dest_LiDAR_udp_port (nebula::HesaiConfig)</li> <li>dest_gps_udp_port (nebula::HesaiConfig)</li> <li>dest_ipaddr (nebula::HesaiConfig)</li> <li>date_of_manufacture (nebula::HesaiInventory)</li> <li>domain (nebula::HesaiPtpConfig)</li> <li>delayMechanism (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#e","title":"e","text":"<ul> <li>end (nebula::HesaiLidarRangeAll)</li> <li>elapsed_millisec (nebula::HesaiPtpDiagStatus)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#g","title":"g","text":"<ul> <li>gateway (nebula::HesaiConfig)</li> <li>gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>gmIdentity (nebula::HesaiPtpDiagTime)</li> <li>gmPresent (nebula::HesaiPtpDiagTime)</li> <li>gmTimeBaseIndicator (nebula::HesaiPtpDiagTime)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#h","title":"h","text":"<ul> <li>hw_ver (nebula::HesaiInventory)</li> <li>http_client_driver_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#i","title":"i","text":"<ul> <li>ipaddr (nebula::HesaiConfig)</li> <li>input_current (nebula::HesaiLidarMonitor)</li> <li>input_power (nebula::HesaiLidarMonitor)</li> <li>input_voltage (nebula::HesaiLidarMonitor)</li> <li>ingress_time (nebula::HesaiPtpDiagTime)</li> <li>is_solid_state (nebula::drivers::HesaiHwInterface)</li> <li>is_valid_packet_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>info_buffer_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_io_context_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_reception_callback_ (nebula::drivers::RobosenseHwInterface)</li> <li>info_udp_driver_ (nebula::drivers::RobosenseHwInterface)</li> <li>is_info_received (nebula::drivers::RobosenseHwInterface)</li> <li>is_valid_info_packet_ (nebula::drivers::RobosenseHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#l","title":"l","text":"<ul> <li>logAnnounceInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinDelayReqInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logSyncInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinPdelayReqInterval (nebula::HesaiPtpDiagPort)</li> <li>lastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#m","title":"m","text":"<ul> <li>mask (nebula::HesaiConfig)</li> <li>motor_status (nebula::HesaiConfig)</li> <li>mac (nebula::HesaiInventory)</li> <li>model (nebula::HesaiInventory)</li> <li>motor_type (nebula::HesaiInventory)</li> <li>method (nebula::HesaiLidarRangeAll)</li> <li>motor_speed (nebula::HesaiLidarStatus)</li> <li>master_offset (nebula::HesaiPtpDiagStatus, nebula::HesaiPtpDiagTime)</li> <li>m_owned_ctx (nebula::drivers::HesaiHwInterface)</li> <li>m_owned_ctx_s (nebula::drivers::HesaiHwInterface)</li> <li>mtu_size_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#n","title":"n","text":"<ul> <li>noise_filtering (nebula::HesaiConfig)</li> <li>num_of_lines (nebula::HesaiInventory)</li> <li>network (nebula::HesaiPtpConfig)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#p","title":"p","text":"<ul> <li>ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>profile (nebula::HesaiPtpConfig)</li> <li>peerMeanPathDelay (nebula::HesaiPtpDiagPort)</li> <li>portIdentity (nebula::HesaiPtpDiagPort)</li> <li>portState (nebula::HesaiPtpDiagPort)</li> <li>ptp_state (nebula::HesaiPtpDiagStatus)</li> <li>parent_node_logger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>prev_phase_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface)</li> <li>parent_node_logger_ (nebula::drivers::RobosenseHwInterface)</li> <li>packet_first_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>phase_ (nebula::drivers::VelodyneHwInterface)</li> <li>prev_packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>processed_packets_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#r","title":"r","text":"<ul> <li>reflectivity_mapping (nebula::HesaiConfig)</li> <li>reserved (nebula::HesaiConfig, nebula::HesaiInventory, nebula::HesaiLidarMonitor, nebula::HesaiLidarStatus)</li> <li>return_mode (nebula::HesaiConfig)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#s","title":"s","text":"<ul> <li>spin_rate (nebula::HesaiConfig)</li> <li>standby_mode (nebula::HesaiConfig)</li> <li>start_angle (nebula::HesaiConfig)</li> <li>stop_angle (nebula::HesaiConfig)</li> <li>sync (nebula::HesaiConfig)</li> <li>sync_angle (nebula::HesaiConfig)</li> <li>sensor_fw_ver (nebula::HesaiInventory)</li> <li>sn (nebula::HesaiInventory)</li> <li>sw_ver (nebula::HesaiInventory)</li> <li>start (nebula::HesaiLidarRangeAll)</li> <li>startup_times (nebula::HesaiLidarStatus)</li> <li>system_uptime (nebula::HesaiLidarStatus)</li> <li>status (nebula::HesaiPtpConfig)</li> <li>scaledLastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>scan_cloud_ptr_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>scan_reception_callback_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>sensor_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::RobosenseHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>sensor_model_ (nebula::drivers::RobosenseHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#t","title":"t","text":"<ul> <li>trigger_method (nebula::HesaiConfig)</li> <li>temperature (nebula::HesaiLidarStatus)</li> <li>total_operation_time (nebula::HesaiLidarStatus)</li> <li>time_flags (nebula::HesaiPtpDiagGrandmaster)</li> <li>time_source (nebula::HesaiPtpDiagGrandmaster)</li> <li>target_model_no (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_ (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_s_ (nebula::drivers::HesaiHwInterface)</li> <li>timeout_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>tms_ (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>TARGET_DIAG (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_FOV (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_HOST (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_NET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_RESET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SAVE (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SETTING (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SNAPSHOT (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_STATUS (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#u","title":"u","text":"<ul> <li>udp_seq (nebula::HesaiConfig)</li> <li>utc_offset (nebula::HesaiPtpDiagGrandmaster)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#v","title":"v","text":"<ul> <li>vlan_flag (nebula::HesaiConfig)</li> <li>vlan_id (nebula::HesaiConfig)</li> <li>versionNumber (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#w","title":"w","text":"<ul> <li>wl (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_hw_interfaces/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"nebula_hw_interfaces/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_hw_interfaces/namespace_members/#b","title":"b","text":"<ul> <li>BPEARL_INFO_PACKET_SIZE (nebula::drivers)</li> <li>BPEARL_PACKET_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_members/#h","title":"h","text":"<ul> <li>HELIOS_INFO_PACKET_SIZE (nebula::drivers)</li> <li>HELIOS_PACKET_SIZE (nebula::drivers)</li> <li>HESAI_LIDAR_GPS_CLOCK_SOURCE (nebula::drivers)</li> <li>HESAI_LIDAR_PTP_CLOCK_SOURCE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_members/#m","title":"m","text":"<ul> <li>MTU_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_members/#p","title":"p","text":"<ul> <li>PANDAR128_E4X_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR128_E4X_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40P_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARAT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32M_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32_PACKET_SIZE (nebula::drivers)</li> <li>PTC_COMMAND_DUMMY_BYTE (nebula::drivers)</li> <li>PTC_COMMAND_GET_CONFIG_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_INVENTORY_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_CALIBRATION (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_GET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_HIGH (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_LOW (nebula::drivers)</li> <li>PTC_COMMAND_LIDAR_MONITOR (nebula::drivers)</li> <li>PTC_COMMAND_PTP_DIAGNOSTICS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP (nebula::drivers)</li> <li>PTC_COMMAND_PTP_PORT_DATA_SET (nebula::drivers)</li> <li>PTC_COMMAND_PTP_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_TIME_STATUS_NP (nebula::drivers)</li> <li>PTC_COMMAND_RESET (nebula::drivers)</li> <li>PTC_COMMAND_SET_CLOCK_SOURCE (nebula::drivers)</li> <li>PTC_COMMAND_SET_CONTROL_PORT (nebula::drivers)</li> <li>PTC_COMMAND_SET_DESTINATION_IP (nebula::drivers)</li> <li>PTC_COMMAND_SET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_SET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_SET_RETURN_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_ROTATE_DIRECTION (nebula::drivers)</li> <li>PTC_COMMAND_SET_SPIN_RATE (nebula::drivers)</li> <li>PTC_COMMAND_SET_STANDBY_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_SYNC_ANGLE (nebula::drivers)</li> <li>PTC_COMMAND_SET_TRIGGER_METHOD (nebula::drivers)</li> <li>PTP_LOG_ANNOUNCE_INTERVAL (nebula::drivers)</li> <li>PTP_LOG_MIN_DELAY_INTERVAL (nebula::drivers)</li> <li>PTP_SYNC_INTERVAL (nebula::drivers)</li> <li>PandarTcpCommandPort (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"nebula_hw_interfaces/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_hw_interfaces/namespace_member_variables/#b","title":"b","text":"<ul> <li>BPEARL_INFO_PACKET_SIZE (nebula::drivers)</li> <li>BPEARL_PACKET_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_variables/#h","title":"h","text":"<ul> <li>HELIOS_INFO_PACKET_SIZE (nebula::drivers)</li> <li>HELIOS_PACKET_SIZE (nebula::drivers)</li> <li>HESAI_LIDAR_GPS_CLOCK_SOURCE (nebula::drivers)</li> <li>HESAI_LIDAR_PTP_CLOCK_SOURCE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_variables/#m","title":"m","text":"<ul> <li>MTU_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_variables/#p","title":"p","text":"<ul> <li>PANDAR128_E4X_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR128_E4X_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40P_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARAT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32M_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32_PACKET_SIZE (nebula::drivers)</li> <li>PTC_COMMAND_DUMMY_BYTE (nebula::drivers)</li> <li>PTC_COMMAND_GET_CONFIG_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_INVENTORY_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_CALIBRATION (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_GET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_HIGH (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_LOW (nebula::drivers)</li> <li>PTC_COMMAND_LIDAR_MONITOR (nebula::drivers)</li> <li>PTC_COMMAND_PTP_DIAGNOSTICS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP (nebula::drivers)</li> <li>PTC_COMMAND_PTP_PORT_DATA_SET (nebula::drivers)</li> <li>PTC_COMMAND_PTP_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_TIME_STATUS_NP (nebula::drivers)</li> <li>PTC_COMMAND_RESET (nebula::drivers)</li> <li>PTC_COMMAND_SET_CLOCK_SOURCE (nebula::drivers)</li> <li>PTC_COMMAND_SET_CONTROL_PORT (nebula::drivers)</li> <li>PTC_COMMAND_SET_DESTINATION_IP (nebula::drivers)</li> <li>PTC_COMMAND_SET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_SET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_SET_RETURN_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_ROTATE_DIRECTION (nebula::drivers)</li> <li>PTC_COMMAND_SET_SPIN_RATE (nebula::drivers)</li> <li>PTC_COMMAND_SET_STANDBY_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_SYNC_ANGLE (nebula::drivers)</li> <li>PTC_COMMAND_SET_TRIGGER_METHOD (nebula::drivers)</li> <li>PTP_LOG_ANNOUNCE_INTERVAL (nebula::drivers)</li> <li>PTP_LOG_MIN_DELAY_INTERVAL (nebula::drivers)</li> <li>PTP_SYNC_INTERVAL (nebula::drivers)</li> <li>PandarTcpCommandPort (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"nebula_hw_interfaces/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"nebula_hw_interfaces/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_hw_interfaces/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_hw_interfaces/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_hw_interfaces/links/","title":"Nebula HW Interfaces","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_ros/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace ros <ul> <li>class HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. </li> <li>class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. </li> <li>class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. </li> <li>class RobosenseDriverRosWrapper Ros wrapper of robosense driver. </li> <li>class RobosenseHwInterfaceRosWrapper Hardware interface ros wrapper of Robosense driver. </li> <li>class RobosenseHwMonitorRosWrapper Hardware monitor ros wrapper of robosense driver. </li> <li>class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> <li>class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> <li>class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> </ul> </li> <li>namespace rclcpp </li> </ul>"},{"location":"nebula_ros/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_ros <ul> <li>dir include <ul> <li>dir nebula_ros <ul> <li>dir common <ul> <li>file nebula_driver_ros_wrapper_base.hpp </li> <li>file nebula_hw_interface_ros_wrapper_base.hpp </li> <li>file nebula_hw_monitor_ros_wrapper_base.hpp </li> </ul> </li> <li>dir hesai <ul> <li>file hesai_decoder_ros_wrapper.hpp </li> <li>file hesai_hw_interface_ros_wrapper.hpp </li> <li>file hesai_hw_monitor_ros_wrapper.hpp </li> </ul> </li> <li>dir robosense <ul> <li>file robosense_decoder_ros_wrapper.hpp </li> <li>file robosense_hw_interface_ros_wrapper.hpp </li> <li>file robosense_hw_monitor_ros_wrapper.hpp </li> </ul> </li> <li>dir velodyne <ul> <li>file velodyne_decoder_ros_wrapper.hpp </li> <li>file velodyne_hw_interface_ros_wrapper.hpp </li> <li>file velodyne_hw_monitor_ros_wrapper.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_ros/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_ros/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace ros <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/namespacenebula_1_1ros/","title":"Namespace nebula::ros","text":"<p>Namespace List &gt; nebula &gt; ros</p>"},{"location":"nebula_ros/namespacenebula_1_1ros/#classes","title":"Classes","text":"Type Name class HesaiDriverRosWrapper Ros wrapper of hesai driver. class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. class RobosenseDriverRosWrapper Ros wrapper of robosense driver. class RobosenseHwInterfaceRosWrapper Hardware interface ros wrapper of Robosense driver. class RobosenseHwMonitorRosWrapper Hardware monitor ros wrapper of robosense driver. class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver."},{"location":"nebula_ros/namespacenebula_1_1ros/#public-functions","title":"Public Functions","text":"Type Name bool get_param (const std::vector&lt; rclcpp::Parameter &gt; &amp; p, const std::string &amp; name, T &amp; value) Get parameter from rclcpp::Parameter."},{"location":"nebula_ros/namespacenebula_1_1ros/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/namespacenebula_1_1ros/#function-get_param","title":"function get_param","text":"<p>Get parameter from rclcpp::Parameter. <pre><code>template&lt;typename T typename T&gt;\nbool nebula::ros::get_param (\n    const std::vector&lt; rclcpp::Parameter &gt; &amp; p,\n    const std::string &amp; name,\n    T &amp; value\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>p</code> Parameter from rclcpp parameter callback </li> <li><code>name</code> Target parameter name </li> <li><code>value</code> Corresponding value </li> </ul> <p>Returns:</p> <p>Whether the target name existed </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/","title":"Class nebula::ros::HesaiDriverRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiDriverRosWrapper</p> <p>Ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_decoder_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaDriverRosWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetStatus () Get current status of this driver. HesaiDriverRosWrapper (const rclcpp::NodeOptions &amp; options)  void ReceiveScanMsgCallback (const pandar_msgs::msg::PandarScan::SharedPtr scan_msg) Callback for PandarScan subscriber."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions-inherited-from-nebularosnebuladriverroswrapperbase","title":"Public Functions inherited from nebula::ros::NebulaDriverRosWrapperBase","text":"<p>See nebula::ros::NebulaDriverRosWrapperBase</p> Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::ros::HesaiDriverRosWrapper::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-hesaidriverroswrapper","title":"function HesaiDriverRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiDriverRosWrapper::HesaiDriverRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-receivescanmsgcallback","title":"function ReceiveScanMsgCallback","text":"<p>Callback for PandarScan subscriber. <pre><code>void nebula::ros::HesaiDriverRosWrapper::ReceiveScanMsgCallback (\n    const pandar_msgs::msg::PandarScan::SharedPtr scan_msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received PandarScan </li> </ul> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/","title":"Class nebula::ros::HesaiHwInterfaceRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiHwInterfaceRosWrapper</p> <p>Hardware interface ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_interface_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwInterfaceWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::HesaiSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. HesaiHwInterfaceRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status Shutdown () overrideShutdown (not used) virtual Status StreamStart () overrideStart point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () overrideStop point cloud streaming (not used) ~HesaiHwInterfaceRosWrapper () noexcept override"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#protected-attributes-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Attributes inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#protected-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::HesaiHwInterfaceRosWrapper::GetParameters (\n    drivers::HesaiSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-hesaihwinterfaceroswrapper","title":"function HesaiHwInterfaceRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiHwInterfaceRosWrapper::HesaiHwInterfaceRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::StreamStart () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::StreamStop () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-hesaihwinterfaceroswrapper_1","title":"function ~HesaiHwInterfaceRosWrapper","text":"<pre><code>nebula::ros::HesaiHwInterfaceRosWrapper::~HesaiHwInterfaceRosWrapper () noexcept override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/","title":"Class nebula::ros::HesaiHwMonitorRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiHwMonitorRosWrapper</p> <p>Hardware monitor ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_monitor_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwMonitorWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::HesaiSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. HesaiHwMonitorRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status MonitorStart () overrideNot used. virtual Status MonitorStop () overrideNot used. virtual Status Shutdown () overrideNot used. ~HesaiHwMonitorRosWrapper () noexcept override"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#protected-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::HesaiHwMonitorRosWrapper::GetParameters (\n    drivers::HesaiSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-hesaihwmonitorroswrapper","title":"function HesaiHwMonitorRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiHwMonitorRosWrapper::HesaiHwMonitorRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-monitorstart","title":"function MonitorStart","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::MonitorStart () override\n</code></pre></p> <p>Returns:</p> <p>Current status </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-monitorstop","title":"function MonitorStop","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::MonitorStop () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-hesaihwmonitorroswrapper_1","title":"function ~HesaiHwMonitorRosWrapper","text":"<pre><code>nebula::ros::HesaiHwMonitorRosWrapper::~HesaiHwMonitorRosWrapper () noexcept override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/","title":"Class nebula::ros::NebulaDriverRosWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaDriverRosWrapperBase</p> <p>Base class for ros wrapper of each sensor driver. </p> <ul> <li><code>#include &lt;nebula_driver_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiDriverRosWrapper,  nebula::ros::RobosenseDriverRosWrapper,  nebula::ros::VelodyneDriverRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#public-functions","title":"Public Functions","text":"Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-13","title":"function NebulaDriverRosWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-23","title":"function NebulaDriverRosWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase (\n    NebulaDriverRosWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-33","title":"function NebulaDriverRosWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase (\n    const NebulaDriverRosWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaDriverRosWrapperBase &amp; nebula::ros::NebulaDriverRosWrapperBase::operator= (\n    NebulaDriverRosWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaDriverRosWrapperBase &amp; nebula::ros::NebulaDriverRosWrapperBase::operator= (\n    const NebulaDriverRosWrapperBase &amp; c\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/","title":"Class nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaHwInterfaceWrapperBase</p> <p>Base class for hardware interface ros wrapper of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_interface_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiHwInterfaceRosWrapper,  nebula::ros::RobosenseHwInterfaceRosWrapper,  nebula::ros::VelodyneHwInterfaceRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#public-functions","title":"Public Functions","text":"Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-attributes","title":"Protected Attributes","text":"Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-13","title":"function NebulaHwInterfaceWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-23","title":"function NebulaHwInterfaceWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase (\n    NebulaHwInterfaceWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-33","title":"function NebulaHwInterfaceWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase (\n    const NebulaHwInterfaceWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwInterfaceWrapperBase &amp; nebula::ros::NebulaHwInterfaceWrapperBase::operator= (\n    NebulaHwInterfaceWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwInterfaceWrapperBase &amp; nebula::ros::NebulaHwInterfaceWrapperBase::operator= (\n    const NebulaHwInterfaceWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#variable-setup_sensor","title":"variable setup_sensor","text":"<pre><code>bool nebula::ros::NebulaHwInterfaceWrapperBase::setup_sensor;\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-initializehwinterface","title":"function InitializeHwInterface","text":"<p>Virtual function for initializing hardware interface ros wrapper. <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::InitializeHwInterface (\n    const drivers::SensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/","title":"Class nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaHwMonitorWrapperBase</p> <p>Base class for hardware monitor ros wrapper of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_monitor_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiHwMonitorRosWrapper,  nebula::ros::RobosenseHwMonitorRosWrapper,  nebula::ros::VelodyneHwMonitorRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#public-functions","title":"Public Functions","text":"Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-monitorstart","title":"function MonitorStart","text":"<p>Start monitoring (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-monitorstop","title":"function MonitorStop","text":"<p>Stop monitoring (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-13","title":"function NebulaHwMonitorWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-23","title":"function NebulaHwMonitorWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase (\n    NebulaHwMonitorWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-33","title":"function NebulaHwMonitorWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase (\n    const NebulaHwMonitorWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::Shutdown () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwMonitorWrapperBase &amp; nebula::ros::NebulaHwMonitorWrapperBase::operator= (\n    NebulaHwMonitorWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwMonitorWrapperBase &amp; nebula::ros::NebulaHwMonitorWrapperBase::operator= (\n    const NebulaHwMonitorWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-initializehwmonitor","title":"function InitializeHwMonitor","text":"<p>Virtual function for initializing hardware monitor ros wrapper. <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::InitializeHwMonitor (\n    const drivers::SensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/","title":"Class nebula::ros::RobosenseDriverRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; RobosenseDriverRosWrapper</p> <p>Ros wrapper of robosense driver. </p> <ul> <li><code>#include &lt;robosense_decoder_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaDriverRosWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetStatus () Get current status of this driver. void ReceiveInfoMsgCallback (const robosense_msgs::msg::RobosenseInfoPacket::SharedPtr info_msg) Callback for DIFOP packet subscriber. void ReceiveScanMsgCallback (const robosense_msgs::msg::RobosenseScan::SharedPtr scan_msg) Callback for RobosenseScan subscriber. RobosenseDriverRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#public-functions-inherited-from-nebularosnebuladriverroswrapperbase","title":"Public Functions inherited from nebula::ros::NebulaDriverRosWrapperBase","text":"<p>See nebula::ros::NebulaDriverRosWrapperBase</p> Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::ros::RobosenseDriverRosWrapper::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#function-receiveinfomsgcallback","title":"function ReceiveInfoMsgCallback","text":"<p>Callback for DIFOP packet subscriber. <pre><code>void nebula::ros::RobosenseDriverRosWrapper::ReceiveInfoMsgCallback (\n    const robosense_msgs::msg::RobosenseInfoPacket::SharedPtr info_msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received RobosensePacket </li> </ul>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#function-receivescanmsgcallback","title":"function ReceiveScanMsgCallback","text":"<p>Callback for RobosenseScan subscriber. <pre><code>void nebula::ros::RobosenseDriverRosWrapper::ReceiveScanMsgCallback (\n    const robosense_msgs::msg::RobosenseScan::SharedPtr scan_msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received RobosenseScan </li> </ul>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseDriverRosWrapper/#function-robosensedriverroswrapper","title":"function RobosenseDriverRosWrapper","text":"<pre><code>explicit nebula::ros::RobosenseDriverRosWrapper::RobosenseDriverRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/","title":"Class nebula::ros::RobosenseHwInterfaceRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; RobosenseHwInterfaceRosWrapper</p> <p>Hardware interface ros wrapper of Robosense driver. </p> <ul> <li><code>#include &lt;robosense_hw_interface_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwInterfaceWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::RobosenseSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. RobosenseHwInterfaceRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status Shutdown () overrideShutdown (not used) virtual Status StreamStart () overrideStart point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () overrideStop point cloud streaming (not used)"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#public-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#protected-attributes-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Attributes inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#protected-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::RobosenseHwInterfaceRosWrapper::GetParameters (\n    drivers::RobosenseSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#function-robosensehwinterfaceroswrapper","title":"function RobosenseHwInterfaceRosWrapper","text":"<pre><code>explicit nebula::ros::RobosenseHwInterfaceRosWrapper::RobosenseHwInterfaceRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::RobosenseHwInterfaceRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::RobosenseHwInterfaceRosWrapper::StreamStart () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwInterfaceRosWrapper/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::RobosenseHwInterfaceRosWrapper::StreamStop () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop</p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/","title":"Class nebula::ros::RobosenseHwMonitorRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; RobosenseHwMonitorRosWrapper</p> <p>Hardware monitor ros wrapper of robosense driver. </p> <ul> <li><code>#include &lt;robosense_hw_monitor_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwMonitorWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::RobosenseSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. virtual Status MonitorStart () overrideNot used. virtual Status MonitorStop () overrideNot used. RobosenseHwMonitorRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status Shutdown () overrideNot used."},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#public-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#protected-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::RobosenseHwMonitorRosWrapper::GetParameters (\n    drivers::RobosenseSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#function-monitorstart","title":"function MonitorStart","text":"<p>Not used. <pre><code>virtual Status nebula::ros::RobosenseHwMonitorRosWrapper::MonitorStart () override\n</code></pre></p> <p>Returns:</p> <p>Current status </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#function-monitorstop","title":"function MonitorStop","text":"<p>Not used. <pre><code>virtual Status nebula::ros::RobosenseHwMonitorRosWrapper::MonitorStop () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#function-robosensehwmonitorroswrapper","title":"function RobosenseHwMonitorRosWrapper","text":"<pre><code>explicit nebula::ros::RobosenseHwMonitorRosWrapper::RobosenseHwMonitorRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1RobosenseHwMonitorRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Not used. <pre><code>virtual Status nebula::ros::RobosenseHwMonitorRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::Shutdown</p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/","title":"Class nebula::ros::VelodyneDriverRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneDriverRosWrapper</p> <p>Ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_decoder_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaDriverRosWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetStatus () Get current status of this driver. void ReceiveScanMsgCallback (const velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg) Callback for VelodyneScan subscriber. VelodyneDriverRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions-inherited-from-nebularosnebuladriverroswrapperbase","title":"Public Functions inherited from nebula::ros::NebulaDriverRosWrapperBase","text":"<p>See nebula::ros::NebulaDriverRosWrapperBase</p> Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::ros::VelodyneDriverRosWrapper::GetStatus () \n</code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-receivescanmsgcallback","title":"function ReceiveScanMsgCallback","text":"<p>Callback for VelodyneScan subscriber. <pre><code>void nebula::ros::VelodyneDriverRosWrapper::ReceiveScanMsgCallback (\n    const velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received VelodyneScan </li> </ul>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-velodynedriverroswrapper","title":"function VelodyneDriverRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneDriverRosWrapper::VelodyneDriverRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/","title":"Class nebula::ros::VelodyneHwInterfaceRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneHwInterfaceRosWrapper</p> <p>Hardware interface ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_interface_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwInterfaceWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::VelodyneSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. virtual Status Shutdown () overrideShutdown (not used) virtual Status StreamStart () overrideStart point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () overrideStop point cloud streaming (not used) VelodyneHwInterfaceRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#protected-attributes-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Attributes inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#protected-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::VelodyneHwInterfaceRosWrapper::GetParameters (\n    drivers::VelodyneSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::StreamStart () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::StreamStop () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-velodynehwinterfaceroswrapper","title":"function VelodyneHwInterfaceRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneHwInterfaceRosWrapper::VelodyneHwInterfaceRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/","title":"Class nebula::ros::VelodyneHwMonitorRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneHwMonitorRosWrapper</p> <p>Hardware monitor ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_monitor_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwMonitorWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::VelodyneSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. virtual Status MonitorStart () overrideNot used. virtual Status MonitorStop () overrideNot used. virtual Status Shutdown () overrideNot used. VelodyneHwMonitorRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#protected-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::VelodyneHwMonitorRosWrapper::GetParameters (\n    drivers::VelodyneSensorConfiguration &amp; sensor_configuration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-monitorstart","title":"function MonitorStart","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::MonitorStart () override\n</code></pre></p> <p>Returns:</p> <p>Current status </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-monitorstop","title":"function MonitorStop","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::MonitorStop () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-velodynehwmonitorroswrapper","title":"function VelodyneHwMonitorRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneHwMonitorRosWrapper::VelodyneHwMonitorRosWrapper (\n    const rclcpp::NodeOptions &amp; options\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/namespacerclcpp/","title":"Namespace rclcpp","text":"<p>Namespace List &gt; rclcpp</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"nebula_ros/dir_6001ffc79e86749e3c101772145a53e6/","title":"Dir nebula_ros","text":"<p>FileList &gt; nebula_ros</p>"},{"location":"nebula_ros/dir_6001ffc79e86749e3c101772145a53e6/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_ros/</code></p>"},{"location":"nebula_ros/dir_dfff66b500be9c87186bdc0dd281c8b0/","title":"Dir nebula_ros/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_ros/dir_dfff66b500be9c87186bdc0dd281c8b0/#directories","title":"Directories","text":"Type Name dir nebula_ros <p>The documentation for this class was generated from the following file <code>nebula_ros/include/</code></p>"},{"location":"nebula_ros/dir_e6dd3370ff1af828926f1a1358835b64/","title":"Dir nebula_ros/include/nebula_ros","text":"<p>FileList &gt; include &gt; nebula_ros</p>"},{"location":"nebula_ros/dir_e6dd3370ff1af828926f1a1358835b64/#directories","title":"Directories","text":"Type Name dir common dir hesai dir robosense dir velodyne <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/</code></p>"},{"location":"nebula_ros/dir_09712351a52108b8301edc8a4528c3da/","title":"Dir nebula_ros/include/nebula_ros/common","text":"<p>FileList &gt; common</p>"},{"location":"nebula_ros/dir_09712351a52108b8301edc8a4528c3da/#files","title":"Files","text":"Type Name file nebula_driver_ros_wrapper_base.hpp file nebula_hw_interface_ros_wrapper_base.hpp file nebula_hw_monitor_ros_wrapper_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/</code></p>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/","title":"File nebula_driver_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_driver_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp_source/","title":"File nebula_driver_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_driver_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_DRIVER_WRAPPER_BASE_H\n#define NEBULA_DRIVER_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaDriverRosWrapperBase\n{\npublic:\n  NebulaDriverRosWrapperBase() = default;\n\n  NebulaDriverRosWrapperBase(NebulaDriverRosWrapperBase &amp;&amp; c) = delete;\n  NebulaDriverRosWrapperBase &amp; operator=(NebulaDriverRosWrapperBase &amp;&amp; c) = delete;\n  NebulaDriverRosWrapperBase(const NebulaDriverRosWrapperBase &amp; c) = delete;\n  NebulaDriverRosWrapperBase &amp; operator=(const NebulaDriverRosWrapperBase &amp; c) = delete;\n\nprivate:\n  virtual Status InitializeDriver(\n    std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\n    std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) = 0;\n\n  //  status ReceiveScanMsgCallback(void * ScanMsg);  // ROS message callback for individual packet\n  //  type\n\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr cloud_pub_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n#endif  // NEBULA_DRIVER_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/","title":"File nebula_hw_interface_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_hw_interface_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp_source/","title":"File nebula_hw_interface_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_hw_interface_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n#define NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaHwInterfaceWrapperBase\n{\npublic:\n  NebulaHwInterfaceWrapperBase() = default;\n\n  NebulaHwInterfaceWrapperBase(NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete;\n  NebulaHwInterfaceWrapperBase &amp; operator=(NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete;\n  NebulaHwInterfaceWrapperBase(const NebulaHwInterfaceWrapperBase &amp; c) = delete;\n  NebulaHwInterfaceWrapperBase &amp; operator=(const NebulaHwInterfaceWrapperBase &amp; c) = delete;\n\n  virtual Status StreamStart() = 0;\n\n  virtual Status StreamStop() = 0;\n\n  virtual Status Shutdown() = 0;\n\nprotected:\n  virtual Status InitializeHwInterface(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0;\n  //  void SendDataPacket(const std::vector&lt;uint8_t&gt; &amp;buffer);        // Ideally this will be\n  //  implemented as specific funtions, GetFanStatus, GetEchoMode\n\n  bool setup_sensor;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/","title":"File nebula_hw_monitor_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_hw_monitor_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp_source/","title":"File nebula_hw_monitor_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_hw_monitor_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_MONITOR_WRAPPER_BASE_H\n#define NEBULA_HW_MONITOR_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaHwMonitorWrapperBase\n{\npublic:\n  NebulaHwMonitorWrapperBase() = default;\n\n  NebulaHwMonitorWrapperBase(NebulaHwMonitorWrapperBase &amp;&amp; c) = delete;\n  NebulaHwMonitorWrapperBase &amp; operator=(NebulaHwMonitorWrapperBase &amp;&amp; c) = delete;\n  NebulaHwMonitorWrapperBase(const NebulaHwMonitorWrapperBase &amp; c) = delete;\n  NebulaHwMonitorWrapperBase &amp; operator=(const NebulaHwMonitorWrapperBase &amp; c) = delete;\n\n  virtual Status MonitorStart() = 0;\n\n  virtual Status MonitorStop() = 0;\n\n  virtual Status Shutdown() = 0;\n\nprotected:\n  virtual Status InitializeHwMonitor(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HW_MONITOR_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/dir_aa08891b43ae5d960958b3e9046224a5/","title":"Dir nebula_ros/include/nebula_ros/hesai","text":"<p>FileList &gt; hesai</p>"},{"location":"nebula_ros/dir_aa08891b43ae5d960958b3e9046224a5/#files","title":"Files","text":"Type Name file hesai_decoder_ros_wrapper.hpp file hesai_hw_interface_ros_wrapper.hpp file hesai_hw_monitor_ros_wrapper.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/</code></p>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/","title":"File hesai_decoder_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_decoder_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> </ul>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiDriverRosWrapper Ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp_source/","title":"File hesai_decoder_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_decoder_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiDriverRosWrapper_H\n#define NEBULA_HesaiDriverRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;chrono&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\nnamespace nebula\n{\nnamespace ros\n{\nclass HesaiDriverRosWrapper final : public rclcpp::Node, NebulaDriverRosWrapperBase\n{\n  std::shared_ptr&lt;drivers::HesaiDriver&gt; driver_ptr_;\n  Status wrapper_status_;\n  rclcpp::Subscription&lt;pandar_msgs::msg::PandarScan&gt;::SharedPtr pandar_scan_sub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr nebula_points_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_ex_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_base_pub_;\n\n  std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; calibration_cfg_ptr_;\n  std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_cfg_ptr_;\n  std::shared_ptr&lt;drivers::HesaiCorrection&gt; correction_cfg_ptr_;\n\n  drivers::HesaiHwInterface hw_interface_;\n\n  Status InitializeDriver(\n    std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\n    std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) override;\n\n  Status InitializeDriver(\n    const std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; &amp; sensor_configuration,\n    const std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; &amp; calibration_configuration,\n    const std::shared_ptr&lt;drivers::HesaiCorrection&gt; &amp; correction_configuration);\n\n  Status GetParameters(\n    drivers::HesaiSensorConfiguration &amp; sensor_configuration,\n    drivers::HesaiCalibrationConfiguration &amp; calibration_configuration,\n    drivers::HesaiCorrection &amp; correction_configuration);\n\n  static inline std::chrono::nanoseconds SecondsToChronoNanoSeconds(const double seconds)\n  {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n      std::chrono::duration&lt;double&gt;(seconds));\n  }\n\n  /***\n   * Publishes a sensor_msgs::msg::PointCloud2 to the specified publisher\n   * @param pointcloud unique pointer containing the point cloud to publish\n   * @param publisher\n   */\n  void PublishCloud(\n    std::unique_ptr&lt;sensor_msgs::msg::PointCloud2&gt; pointcloud,\n    const rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr &amp; publisher);\n\npublic:\n  explicit HesaiDriverRosWrapper(const rclcpp::NodeOptions &amp; options);\n\n  void ReceiveScanMsgCallback(const pandar_msgs::msg::PandarScan::SharedPtr scan_msg);\n\n  Status GetStatus();\n\nprivate:\n  std::string correction_file_path;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiDriverRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/","title":"File hesai_hw_interface_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_hw_interface_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp_source/","title":"File hesai_hw_interface_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_hw_interface_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiHwInterfaceRosWrapper_H\n#define NEBULA_HesaiHwInterfaceRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;boost/asio.hpp&gt;\n\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass HesaiHwInterfaceRosWrapper final : public rclcpp::Node, NebulaHwInterfaceWrapperBase\n{\n  drivers::HesaiHwInterface hw_interface_;\n  Status interface_status_;\n\n  drivers::HesaiSensorConfiguration sensor_configuration_;\n\n  rclcpp::Publisher&lt;pandar_msgs::msg::PandarScan&gt;::SharedPtr pandar_scan_pub_;\n\n  Status InitializeHwInterface(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n  void ReceiveScanDataCallback(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; scan_buffer);\n\npublic:\n  explicit HesaiHwInterfaceRosWrapper(const rclcpp::NodeOptions &amp; options);\n  ~HesaiHwInterfaceRosWrapper() noexcept override;\n  Status StreamStart() override;\n  Status StreamStop() override;\n  Status Shutdown() override;\n  Status GetParameters(drivers::HesaiSensorConfiguration &amp; sensor_configuration);\n\nprivate:\n  uint16_t delay_hw_ms_;\n  bool retry_hw_;\n  std::mutex mtx_config_;\n  OnSetParametersCallbackHandle::SharedPtr set_param_res_;\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n  std::vector&lt;rcl_interfaces::msg::SetParametersResult&gt; updateParameters();\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiHwInterfaceRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/","title":"File hesai_hw_monitor_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_hw_monitor_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;boost/lexical_cast.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp_source/","title":"File hesai_hw_monitor_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_hw_monitor_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiHwMonitorRosWrapper_H\n#define NEBULA_HesaiHwMonitorRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;boost/asio.hpp&gt;\n\n#include &lt;mutex&gt;\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\n#include &lt;thread&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass HesaiHwMonitorRosWrapper final : public rclcpp::Node, NebulaHwMonitorWrapperBase\n{\n  drivers::HesaiHwInterface hw_interface_;\n  Status interface_status_;\n\n  drivers::HesaiSensorConfiguration sensor_configuration_;\n\n  Status InitializeHwMonitor(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\npublic:\n  explicit HesaiHwMonitorRosWrapper(const rclcpp::NodeOptions &amp; options);\n  ~HesaiHwMonitorRosWrapper() noexcept override;\n  Status MonitorStart() override;\n  Status MonitorStop() override;\n  Status Shutdown() override;\n  Status GetParameters(drivers::HesaiSensorConfiguration &amp; sensor_configuration);\n\nprivate:\n  diagnostic_updater::Updater diagnostics_updater_;\n  void InitializeHesaiDiagnostics();\n  void OnHesaiStatusTimer();\n  void OnHesaiLidarMonitorTimerHttp();\n  void OnHesaiLidarMonitorTimer();\n  //  void OnHesaiDiagnosticsTimer();\n  //  void OnHesaiStatusTimer();\n\n  void HesaiCheckStatus(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void HesaiCheckPtp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void HesaiCheckTemperature(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void HesaiCheckRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void HesaiCheckVoltageHttp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void HesaiCheckVoltage(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  rclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_update_monitor_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_lidar_monitor_timer_;\n  std::unique_ptr&lt;HesaiLidarStatus&gt; current_status;\n  std::unique_ptr&lt;HesaiLidarMonitor&gt; current_monitor;\n  std::unique_ptr&lt;HesaiConfig&gt; current_config;\n  std::unique_ptr&lt;HesaiInventory&gt; current_inventory;\n  std::unique_ptr&lt;boost::property_tree::ptree&gt; current_lidar_monitor_tree;\n  std::unique_ptr&lt;rclcpp::Time&gt; current_status_time;\n  std::unique_ptr&lt;rclcpp::Time&gt; current_config_time;\n  std::unique_ptr&lt;rclcpp::Time&gt; current_inventory_time;\n  std::unique_ptr&lt;rclcpp::Time&gt; current_lidar_monitor_time;\n  uint8_t current_diag_status;\n  uint8_t current_monitor_status;\n\n  uint16_t diag_span_;\n  uint16_t delay_monitor_ms_;\n  std::mutex mtx_diag;\n  std::mutex mtx_status;\n  std::mutex mtx_lidar_monitor;\n  //  std::timed_mutex mtx_lidar_monitor;\n  std::mutex mtx_config_;\n  OnSetParametersCallbackHandle::SharedPtr set_param_res_;\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n  std::string GetPtreeValue(boost::property_tree::ptree * pt, const std::string &amp; key);\n  std::string GetFixedPrecisionString(double val, int pre = 2);\n\n  std::string info_model;\n  std::string info_serial;\n  rclcpp::CallbackGroup::SharedPtr cbg_r_;\n  rclcpp::CallbackGroup::SharedPtr cbg_m_;\n  rclcpp::CallbackGroup::SharedPtr cbg_m2_;\n\n  const char * not_supported_message;\n  const char * error_message;\n  std::string message_sep;\n\n  std::vector&lt;std::string&gt; temperature_names;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiHwMonitorRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/dir_49fcbba22d8ef6edcb98aed7f00683db/","title":"Dir nebula_ros/include/nebula_ros/robosense","text":"<p>FileList &gt; include &gt; nebula_ros &gt; robosense</p>"},{"location":"nebula_ros/dir_49fcbba22d8ef6edcb98aed7f00683db/#files","title":"Files","text":"Type Name file robosense_decoder_ros_wrapper.hpp file robosense_hw_interface_ros_wrapper.hpp file robosense_hw_monitor_ros_wrapper.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/</code></p>"},{"location":"nebula_ros/robosense__decoder__ros__wrapper_8hpp/","title":"File robosense_decoder_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_decoder_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/robosense_driver.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"robosense_msgs/msg/robosense_info_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"nebula_ros/robosense__decoder__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/robosense__decoder__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseDriverRosWrapper Ros wrapper of robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/robosense__decoder__ros__wrapper_8hpp_source/","title":"File robosense_decoder_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_decoder_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/robosense_driver.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"robosense_msgs/msg/robosense_info_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\n#include &lt;chrono&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass RobosenseDriverRosWrapper final : public rclcpp::Node, NebulaDriverRosWrapperBase\n{\n  std::shared_ptr&lt;drivers::RobosenseDriver&gt; driver_ptr_;\n  std::shared_ptr&lt;drivers::RobosenseInfoDriver&gt; info_driver_ptr_;\n  Status wrapper_status_;\n  bool is_received_info{false};\n  rclcpp::Subscription&lt;robosense_msgs::msg::RobosenseScan&gt;::SharedPtr robosense_scan_sub_;\n  rclcpp::Subscription&lt;robosense_msgs::msg::RobosenseInfoPacket&gt;::SharedPtr robosense_info_sub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr nebula_points_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_ex_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_base_pub_;\n\n  std::shared_ptr&lt;drivers::RobosenseCalibrationConfiguration&gt; calibration_cfg_ptr_;\n  std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_cfg_ptr_;\n\n  Status InitializeDriver(\n    std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\n    std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) override;\n\n  Status InitializeInfoDriver(\n    std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration);\n\n  Status GetParameters(\n    drivers::RobosenseSensorConfiguration &amp; sensor_configuration,\n    drivers::RobosenseCalibrationConfiguration &amp; calibration_configuration);\n\n  static inline std::chrono::nanoseconds SecondsToChronoNanoSeconds(const double seconds)\n  {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n      std::chrono::duration&lt;double&gt;(seconds));\n  }\n\n  /***\n   * Publishes a sensor_msgs::msg::PointCloud2 to the specified publisher\n   * @param pointcloud unique pointer containing the point cloud to publish\n   * @param publisher\n   */\n  void PublishCloud(\n    std::unique_ptr&lt;sensor_msgs::msg::PointCloud2&gt; pointcloud,\n    const rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr &amp; publisher);\n\npublic:\n  explicit RobosenseDriverRosWrapper(const rclcpp::NodeOptions &amp; options);\n\n  void ReceiveScanMsgCallback(const robosense_msgs::msg::RobosenseScan::SharedPtr scan_msg);\n\n  void ReceiveInfoMsgCallback(const robosense_msgs::msg::RobosenseInfoPacket::SharedPtr info_msg);\n\n  Status GetStatus();\n};\n\n}  // namespace ros\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_ros/robosense__hw__interface__ros__wrapper_8hpp/","title":"File robosense_hw_interface_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_hw_interface_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"robosense_msgs/msg/robosense_info_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_packet.hpp\"</code></li> <li><code>#include \"robosense_msgs/msg/robosense_scan.hpp\"</code></li> </ul>"},{"location":"nebula_ros/robosense__hw__interface__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/robosense__hw__interface__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseHwInterfaceRosWrapper Hardware interface ros wrapper of Robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/robosense__hw__interface__ros__wrapper_8hpp_source/","title":"File robosense_hw_interface_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_hw_interface_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"robosense_msgs/msg/robosense_info_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_packet.hpp\"\n#include \"robosense_msgs/msg/robosense_scan.hpp\"\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass RobosenseHwInterfaceRosWrapper final : public rclcpp::Node, NebulaHwInterfaceWrapperBase\n{\npublic:\n  explicit RobosenseHwInterfaceRosWrapper(const rclcpp::NodeOptions &amp; options);\n\n  Status StreamStart() override;\n\n  Status StreamStop() override;\n\n  Status Shutdown() override;\n\n  Status GetParameters(drivers::RobosenseSensorConfiguration &amp; sensor_configuration);\n\nprivate:\n  drivers::RobosenseHwInterface hw_interface_;\n  drivers::RobosenseSensorConfiguration sensor_configuration_;\n  Status interface_status_;\n\n  rclcpp::Publisher&lt;robosense_msgs::msg::RobosenseScan&gt;::SharedPtr robosense_scan_pub_;\n\n  rclcpp::Publisher&lt;robosense_msgs::msg::RobosenseInfoPacket&gt;::SharedPtr robosense_difop_pub_;\n\n  Status InitializeHwInterface(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\n  void ReceiveScanDataCallback(std::unique_ptr&lt;robosense_msgs::msg::RobosenseScan&gt; scan_buffer);\n\n  void ReceiveInfoDataCallback(std::unique_ptr&lt;robosense_msgs::msg::RobosenseInfoPacket&gt; difop_buffer);\n};\n\n}  // namespace ros\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_ros/robosense__hw__monitor__ros__wrapper_8hpp/","title":"File robosense_hw_monitor_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_hw_monitor_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/robosense/robosense_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"robosense_msgs/msg/robosense_info_packet.hpp\"</code></li> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;boost/lexical_cast.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"nebula_ros/robosense__hw__monitor__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/robosense__hw__monitor__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class RobosenseHwMonitorRosWrapper Hardware monitor ros wrapper of robosense driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/robosense/robosense_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/robosense__hw__monitor__ros__wrapper_8hpp_source/","title":"File robosense_hw_monitor_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; robosense &gt; robosense_hw_monitor_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/robosense/robosense_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_robosense/robosense_info_driver.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_robosense/robosense_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"robosense_msgs/msg/robosense_info_packet.hpp\"\n\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass RobosenseHwMonitorRosWrapper final : public rclcpp::Node, NebulaHwMonitorWrapperBase\n{\n  drivers::RobosenseHwInterface hw_interface_;\n  Status interface_status_;\n  std::unique_ptr&lt;drivers::RobosenseInfoDriver&gt; info_driver_;\n  std::vector&lt;uint8_t&gt; info_packet_buffer_;\n\n  drivers::RobosenseSensorConfiguration sensor_configuration_;\n  std::shared_ptr&lt;nebula::drivers::RobosenseCalibrationConfiguration&gt; calibration_configuration_;\n\n  rclcpp::Subscription&lt;robosense_msgs::msg::RobosenseInfoPacket&gt;::SharedPtr robosense_info_sub_;\n\n  Status InitializeHwMonitor(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\npublic:\n  explicit RobosenseHwMonitorRosWrapper(const rclcpp::NodeOptions &amp; options);\n  Status MonitorStart() override;\n  Status MonitorStop() override;\n  Status Shutdown() override;\n  Status GetParameters(drivers::RobosenseSensorConfiguration &amp; sensor_configuration);\n\nprivate:\n  diagnostic_updater::Updater diagnostics_updater_;\n  void InitializeRobosenseDiagnostics();\n  void OnRobosenseStatusTimer();\n\n  void RobosenseCheckStatus(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void ReceiveInfoMsgCallback(const robosense_msgs::msg::RobosenseInfoPacket::SharedPtr info_msg);\n\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n\n  OnSetParametersCallbackHandle::SharedPtr set_param_res_;\n\n  rclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\n  std::map&lt;std::string, std::string&gt; current_sensor_info_;\n\n  std::unique_ptr&lt;rclcpp::Time&gt; current_info_time_;\n  uint16_t diag_span_{1000};\n  std::optional&lt;std::string&gt; hardware_id_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_ros/dir_924f2fee37cae1e3bab1779917111cb0/","title":"Dir nebula_ros/include/nebula_ros/velodyne","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne</p>"},{"location":"nebula_ros/dir_924f2fee37cae1e3bab1779917111cb0/#files","title":"Files","text":"Type Name file velodyne_decoder_ros_wrapper.hpp file velodyne_hw_interface_ros_wrapper.hpp file velodyne_hw_monitor_ros_wrapper.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/</code></p>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/","title":"File velodyne_decoder_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_decoder_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> </ul>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp_source/","title":"File velodyne_decoder_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_decoder_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneDriverRosWrapper_H\n#define NEBULA_VelodyneDriverRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp\"\n#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass VelodyneDriverRosWrapper final : public rclcpp::Node, NebulaDriverRosWrapperBase\n{\n  std::shared_ptr&lt;drivers::VelodyneDriver&gt; driver_ptr_;\n  Status wrapper_status_;\n  rclcpp::Subscription&lt;velodyne_msgs::msg::VelodyneScan&gt;::SharedPtr velodyne_scan_sub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr nebula_points_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_ex_pub_;\n  rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_base_pub_;\n\n  std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_cfg_ptr_;\n  std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_cfg_ptr_;\n\n  Status InitializeDriver(\n    std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\n    std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) override;\n\n  Status GetParameters(\n    drivers::VelodyneSensorConfiguration &amp; sensor_configuration,\n    drivers::VelodyneCalibrationConfiguration &amp; calibration_configuration);\n\n  static inline std::chrono::nanoseconds SecondsToChronoNanoSeconds(const double seconds)\n  {\n    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\n      std::chrono::duration&lt;double&gt;(seconds));\n  }\n\n  /***\n   * Publishes a sensor_msgs::msg::PointCloud2 to the specified publisher\n   * @param pointcloud unique pointer containing the point cloud to publish\n   * @param publisher\n   */\n  void PublishCloud(\n    std::unique_ptr&lt;sensor_msgs::msg::PointCloud2&gt; pointcloud,\n    const rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr &amp; publisher);\n\npublic:\n  explicit VelodyneDriverRosWrapper(const rclcpp::NodeOptions &amp; options);\n\n  void ReceiveScanMsgCallback(const velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg);\n  Status GetStatus();\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneDriverRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/","title":"File velodyne_hw_interface_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_interface_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;</code></li> <li><code>#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;</code></li> <li><code>#include &lt;curl/curl.h&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp_source/","title":"File velodyne_hw_interface_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_interface_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneHwInterfaceRosWrapper_H\n#define NEBULA_VelodyneHwInterfaceRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;velodyne_msgs/msg/velodyne_packet.hpp&gt;\n#include &lt;velodyne_msgs/msg/velodyne_scan.hpp&gt;\n\n#include &lt;curl/curl.h&gt;\n\n#include &lt;future&gt;\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass VelodyneHwInterfaceRosWrapper final : public rclcpp::Node, NebulaHwInterfaceWrapperBase\n{\n  drivers::VelodyneHwInterface hw_interface_;\n  Status interface_status_;\n\n  drivers::VelodyneSensorConfiguration sensor_configuration_;\n  drivers::VelodyneCalibrationConfiguration calibration_configuration_;\n\n  rclcpp::Publisher&lt;velodyne_msgs::msg::VelodyneScan&gt;::SharedPtr velodyne_scan_pub_;\n\n  Status InitializeHwInterface(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n  void ReceiveScanDataCallback(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; scan_buffer);\n\npublic:\n  explicit VelodyneHwInterfaceRosWrapper(const rclcpp::NodeOptions &amp; options);\n  Status StreamStart() override;\n  Status StreamStop() override;\n  Status Shutdown() override;\n  Status GetParameters(drivers::VelodyneSensorConfiguration &amp; sensor_configuration);\n\nprivate:  // ROS Diagnostics\n  /*\ndiagnostic_updater::Updater diagnostics_updater_;\nvoid InitializeVelodyneDiagnostics();\n*/\n\n  std::string GetPtreeValue(\n    std::shared_ptr&lt;boost::property_tree::ptree&gt; pt, const std::string &amp; key);\n  /*\n  rclcpp::TimerBase::SharedPtr diagnostics_diag_timer_;\n*/\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_diag_tree;\n  /*\n  void OnVelodyneDiagnosticsTimer();\n  void VelodyneCheckTopHv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopAdTemp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrRaw(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrVccint(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotIOut(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr12v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwrVIn(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr125v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckVhv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcNf(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcStats(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckIxe(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdctpStat(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  rclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\n*/\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_status_tree;\n  /*\n  void OnVelodyneStatusTimer();\n  void VelodyneCheckGpsPpsState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckGpsPosition(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorLock(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorPhase(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckLaserState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void VelodyneCheckSnapshot(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void OnVelodyneSnapshotTimer();\n  rclcpp::TimerBase::SharedPtr diagnostics_snapshot_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\n*/\n  std::shared_ptr&lt;std::string&gt; current_snapshot;\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_snapshot_tree;\n  std::shared_ptr&lt;rclcpp::Time&gt; current_snapshot_time;\n  //  rclcpp::Time current_snapshot_time;\n  //  std::shared_ptr&lt;uint8_t&gt; current_diag_status;\n  uint8_t current_diag_status;\n\n  uint16_t diag_span_;\n  std::mutex mtx_diag;\n  std::mutex mtx_status;\n  std::mutex mtx_config_;\n\n  void curl_callback(std::string err, std::string body);\n  /*\n  const char* key_volt_temp_top_hv;\n  const char* key_volt_temp_top_ad_temp;\n  const char* key_volt_temp_top_lm20_temp;\n  const char* key_volt_temp_top_pwr_5v;\n  const char* key_volt_temp_top_pwr_2_5v;\n  const char* key_volt_temp_top_pwr_3_3v;\n  const char* key_volt_temp_top_pwr_raw;\n  const char* key_volt_temp_top_pwr_vccint;\n  const char* key_volt_temp_bot_i_out;\n  const char* key_volt_temp_bot_pwr_1_2v;\n  const char* key_volt_temp_bot_lm20_temp;\n  const char* key_volt_temp_bot_pwr_5v;\n  const char* key_volt_temp_bot_pwr_2_5v;\n  const char* key_volt_temp_bot_pwr_3_3v;\n  const char* key_volt_temp_bot_pwr_v_in;\n  const char* key_volt_temp_bot_pwr_1_25v;\n  const char* key_vhv;\n  const char* key_adc_nf;\n  const char* key_adc_stats;\n  const char* key_ixe;\n  const char* key_adctp_stat;\n  const char* key_status_gps_pps_state;\n  const char* key_status_gps_pps_position;\n  const char* key_status_motor_state;\n  const char* key_status_motor_rpm;\n  const char* key_status_motor_lock;\n  const char* key_status_motor_phase;\n  const char* key_status_laser_state;\n*/\n  const char * not_supported_message;\n\n  OnSetParametersCallbackHandle::SharedPtr set_param_res_;\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n  std::vector&lt;rcl_interfaces::msg::SetParametersResult&gt; updateParameters();\n\n  //  rclcpp::callback_group::CallbackGroup::SharedPtr cbg_;\n  rclcpp::CallbackGroup::SharedPtr cbg_r_;\n  rclcpp::CallbackGroup::SharedPtr cbg_m_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneHwInterfaceRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/","title":"File velodyne_hw_monitor_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_monitor_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp_source/","title":"File velodyne_hw_monitor_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_monitor_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneHwMonitorRosWrapper_H\n#define NEBULA_VelodyneHwMonitorRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\n  auto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\n    return parameter.get_name() == name;\n  });\n  if (it != p.cend()) {\n    value = it-&gt;template get_value&lt;T&gt;();\n    return true;\n  }\n  return false;\n}\n\nclass VelodyneHwMonitorRosWrapper final : public rclcpp::Node, NebulaHwMonitorWrapperBase\n{\n  drivers::VelodyneHwInterface hw_interface_;\n  Status interface_status_;\n\n  drivers::VelodyneSensorConfiguration sensor_configuration_;\n  drivers::VelodyneCalibrationConfiguration calibration_configuration_;\n\n  Status InitializeHwMonitor(\n    const drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\npublic:\n  explicit VelodyneHwMonitorRosWrapper(const rclcpp::NodeOptions &amp; options);\n\n  Status MonitorStart() override;\n  Status MonitorStop() override;\n  Status Shutdown() override;\n  Status GetParameters(drivers::VelodyneSensorConfiguration &amp; sensor_configuration);\n\nprivate:  // ROS Diagnostics\n  diagnostic_updater::Updater diagnostics_updater_;\n  void InitializeVelodyneDiagnostics();\n  std::string GetPtreeValue(\n    std::shared_ptr&lt;boost::property_tree::ptree&gt; pt, const std::string &amp; key);\n  std::string GetFixedPrecisionString(double val, int pre = 2);\n  rclcpp::TimerBase::SharedPtr diagnostics_diag_timer_;\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_diag_tree;\n  void OnVelodyneDiagnosticsTimer();\n\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopHv();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopAdTemp();  // only32\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopLm20Temp();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr5v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr25v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr33v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr5vRaw();  // only16\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwrRaw();  // only32\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwrVccint();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotIOut();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr12v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotLm20Temp();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr5v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr25v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr33v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwrVIn();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr125v();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetVhv();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdcNf();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdcStats();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetIxe();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdctpStat();\n\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetGpsPpsState();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetGpsPosition();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorState();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorRpm();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorLock();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorPhase();\n  std::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetLaserState();\n\n  void VelodyneCheckTopHv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopAdTemp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrRaw(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrVccint(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotIOut(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr12v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwrVIn(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr125v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckVhv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcNf(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcStats(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckIxe(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdctpStat(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  rclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_status_tree;\n  void OnVelodyneStatusTimer();\n  void VelodyneCheckGpsPpsState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckGpsPosition(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorLock(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorPhase(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckLaserState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void VelodyneCheckSnapshot(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void VelodyneCheckStatus(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckPps(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTemperature(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckVoltage(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void OnVelodyneSnapshotTimer();\n  rclcpp::TimerBase::SharedPtr diagnostics_snapshot_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\n  std::shared_ptr&lt;std::string&gt; current_snapshot;\n  std::shared_ptr&lt;boost::property_tree::ptree&gt; current_snapshot_tree;\n  std::shared_ptr&lt;rclcpp::Time&gt; current_snapshot_time;\n  //  rclcpp::Time current_snapshot_time;\n  //  std::shared_ptr&lt;uint8_t&gt; current_diag_status;\n  uint8_t current_diag_status;\n\n  uint16_t diag_span_;\n  std::mutex mtx_diag;\n  std::mutex mtx_status;\n  std::mutex mtx_config_;\n\n  void curl_callback(std::string err, std::string body);\n\n  const char * key_volt_temp_top_hv;\n  const char * key_volt_temp_top_ad_temp;\n  const char * key_volt_temp_top_lm20_temp;\n  const char * key_volt_temp_top_pwr_5v;\n  const char * key_volt_temp_top_pwr_2_5v;\n  const char * key_volt_temp_top_pwr_3_3v;\n  const char * key_volt_temp_top_pwr_5v_raw;\n  const char * key_volt_temp_top_pwr_raw;\n  const char * key_volt_temp_top_pwr_vccint;\n  const char * key_volt_temp_bot_i_out;\n  const char * key_volt_temp_bot_pwr_1_2v;\n  const char * key_volt_temp_bot_lm20_temp;\n  const char * key_volt_temp_bot_pwr_5v;\n  const char * key_volt_temp_bot_pwr_2_5v;\n  const char * key_volt_temp_bot_pwr_3_3v;\n  const char * key_volt_temp_bot_pwr_v_in;\n  const char * key_volt_temp_bot_pwr_1_25v;\n  const char * key_vhv;\n  const char * key_adc_nf;\n  const char * key_adc_stats;\n  const char * key_ixe;\n  const char * key_adctp_stat;\n  const char * key_status_gps_pps_state;\n  const char * key_status_gps_pps_position;\n  const char * key_status_motor_state;\n  const char * key_status_motor_rpm;\n  const char * key_status_motor_lock;\n  const char * key_status_motor_phase;\n  const char * key_status_laser_state;\n\n  /*\n  const char* name_volt_temp_top_hv;\n  const char* name_volt_temp_top_ad_temp;\n  const char* name_volt_temp_top_lm20_temp;\n  const char* name_volt_temp_top_pwr_5v;\n  const char* name_volt_temp_top_pwr_2_5v;\n  const char* name_volt_temp_top_pwr_3_3v;\n  const char* name_volt_temp_top_pwr_raw;\n  const char* name_volt_temp_top_pwr_vccint;\n  const char* name_volt_temp_bot_i_out;\n  const char* name_volt_temp_bot_pwr_1_2v;\n  const char* name_volt_temp_bot_lm20_temp;\n  const char* name_volt_temp_bot_pwr_5v;\n  const char* name_volt_temp_bot_pwr_2_5v;\n  const char* name_volt_temp_bot_pwr_3_3v;\n  const char* name_volt_temp_bot_pwr_v_in;\n  const char* name_volt_temp_bot_pwr_1_25v;\n  const char* name_vhv;\n  const char* name_adc_nf;\n  const char* name_adc_stats;\n  const char* name_ixe;\n  const char* name_adctp_stat;\n  const char* name_status_gps_pps_state;\n  const char* name_status_gps_pps_position;\n  const char* name_status_motor_state;\n  const char* name_status_motor_rpm;\n  const char* name_status_motor_lock;\n  const char* name_status_motor_phase;\n  const char* name_status_laser_state;\n  */\n\n  std::string name_volt_temp_top_hv;\n  std::string name_volt_temp_top_ad_temp;\n  std::string name_volt_temp_top_lm20_temp;\n  std::string name_volt_temp_top_pwr_5v;\n  std::string name_volt_temp_top_pwr_2_5v;\n  std::string name_volt_temp_top_pwr_3_3v;\n  std::string name_volt_temp_top_pwr_5v_raw;\n  std::string name_volt_temp_top_pwr_raw;\n  std::string name_volt_temp_top_pwr_vccint;\n  std::string name_volt_temp_bot_i_out;\n  std::string name_volt_temp_bot_pwr_1_2v;\n  std::string name_volt_temp_bot_lm20_temp;\n  std::string name_volt_temp_bot_pwr_5v;\n  std::string name_volt_temp_bot_pwr_2_5v;\n  std::string name_volt_temp_bot_pwr_3_3v;\n  std::string name_volt_temp_bot_pwr_v_in;\n  std::string name_volt_temp_bot_pwr_1_25v;\n  std::string name_vhv;\n  std::string name_adc_nf;\n  std::string name_adc_stats;\n  std::string name_ixe;\n  std::string name_adctp_stat;\n  std::string name_status_gps_pps_state;\n  std::string name_status_gps_pps_position;\n  std::string name_status_motor_state;\n  std::string name_status_motor_rpm;\n  std::string name_status_motor_lock;\n  std::string name_status_motor_phase;\n  std::string name_status_laser_state;\n\n  const char * not_supported_message;\n  const char * error_message;\n  std::string message_sep;\n\n  const char * key_info_model;\n  const char * key_info_serial;\n\n  std::string temperature_cold_message;\n  std::string temperature_hot_message;\n  std::string voltage_low_message;\n  std::string voltage_high_message;\n  std::string ampere_low_message;\n  std::string ampere_high_message;\n\n  std::string info_model;\n  std::string info_serial;\n\n  bool use_advanced_diagnostics;\n\n  OnSetParametersCallbackHandle::SharedPtr set_param_res_;\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n\n  //  rclcpp::callback_group::CallbackGroup::SharedPtr cbg_;\n  rclcpp::CallbackGroup::SharedPtr cbg_r_;\n  rclcpp::CallbackGroup::SharedPtr cbg_m_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneHwMonitorRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace ros </li> </ul> </li> <li>namespace rclcpp </li> </ul>"},{"location":"nebula_ros/classes/","title":"Class Index","text":""},{"location":"nebula_ros/classes/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros)</li> </ul>"},{"location":"nebula_ros/classes/#n","title":"n","text":"<ul> <li>NebulaDriverRosWrapperBase (nebula::ros)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros)</li> </ul>"},{"location":"nebula_ros/classes/#r","title":"r","text":"<ul> <li>RobosenseDriverRosWrapper (nebula::ros)</li> <li>RobosenseHwInterfaceRosWrapper (nebula::ros)</li> <li>RobosenseHwMonitorRosWrapper (nebula::ros)</li> </ul>"},{"location":"nebula_ros/classes/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros)</li> </ul>"},{"location":"nebula_ros/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::ros::NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. <ul> <li>class nebula::ros::HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class nebula::ros::RobosenseDriverRosWrapper Ros wrapper of robosense driver. </li> <li>class nebula::ros::VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> </ul> </li> <li>class nebula::ros::NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. <ul> <li>class nebula::ros::HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class nebula::ros::RobosenseHwInterfaceRosWrapper Hardware interface ros wrapper of Robosense driver. </li> <li>class nebula::ros::VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> </ul> </li> <li>class nebula::ros::NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. <ul> <li>class nebula::ros::HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class nebula::ros::RobosenseHwMonitorRosWrapper Hardware monitor ros wrapper of robosense driver. </li> <li>class nebula::ros::VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> <li>class rclcpp::Node <ul> <li>class nebula::ros::HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class nebula::ros::HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class nebula::ros::HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class nebula::ros::RobosenseDriverRosWrapper Ros wrapper of robosense driver. </li> <li>class nebula::ros::RobosenseHwInterfaceRosWrapper Hardware interface ros wrapper of Robosense driver. </li> <li>class nebula::ros::RobosenseHwMonitorRosWrapper Hardware monitor ros wrapper of robosense driver. </li> <li>class nebula::ros::VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> <li>class nebula::ros::VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> <li>class nebula::ros::VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> </ul>"},{"location":"nebula_ros/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_ros/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_ros/class_members/","title":"Class Members","text":""},{"location":"nebula_ros/class_members/#a","title":"a","text":"<ul> <li>aw_points_base_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>aw_points_ex_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ampere_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>ampere_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#c","title":"c","text":"<ul> <li>calibration_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>correction_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>correction_file_path (nebula::ros::HesaiDriverRosWrapper)</li> <li>cbg_m2_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cbg_m_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>cbg_r_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_config (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_config_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_diag_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_inventory (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_inventory_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_tree (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cloud_pub_ (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>calibration_configuration_ (nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_info_time_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>current_sensor_info_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>curl_callback (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_diag_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_time (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_status_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#d","title":"d","text":"<ul> <li>driver_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>delay_hw_ms_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>delay_monitor_ms_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diag_span_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_lidar_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_status_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_update_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_update_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_updater_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_diag_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_snapshot_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#e","title":"e","text":"<ul> <li>error_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#g","title":"g","text":"<ul> <li>GetParameters (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneDriverRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetStatus (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>GetFixedPrecisionString (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetPtreeValue (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros::HesaiDriverRosWrapper)</li> <li>hw_interface_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>HesaiCheckPtp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckRpm (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckStatus (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckTemperature (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltage (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltageHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>hardware_id_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#i","title":"i","text":"<ul> <li>InitializeDriver (nebula::ros::HesaiDriverRosWrapper, nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>InitializeHwInterface (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>interface_status_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeHesaiDiagnostics (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>InitializeHwMonitor (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_model (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_serial (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeInfoDriver (nebula::ros::RobosenseDriverRosWrapper)</li> <li>info_driver_ptr_ (nebula::ros::RobosenseDriverRosWrapper)</li> <li>is_received_info (nebula::ros::RobosenseDriverRosWrapper)</li> <li>InitializeRobosenseDiagnostics (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>info_driver_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>info_packet_buffer_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>InitializeVelodyneDiagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#k","title":"k","text":"<ul> <li>key_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_model (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_serial (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#m","title":"m","text":"<ul> <li>mtx_config_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStart (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStop (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>message_sep (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_diag (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_lidar_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>mtx_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#n","title":"n","text":"<ul> <li>nebula_points_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>not_supported_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>NebulaDriverRosWrapperBase (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros::NebulaHwInterfaceWrapperBase)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>name_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#o","title":"o","text":"<ul> <li>OnHesaiLidarMonitorTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiLidarMonitorTimerHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiStatusTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>operator= (nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>OnRobosenseStatusTimer (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>OnVelodyneDiagnosticsTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneSnapshotTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneStatusTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#p","title":"p","text":"<ul> <li>PublishCloud (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>pandar_scan_sub_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>pandar_scan_pub_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>paramCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#r","title":"r","text":"<ul> <li>ReceiveScanMsgCallback (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ReceiveScanDataCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>retry_hw_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>ReceiveInfoMsgCallback (nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>RobosenseDriverRosWrapper (nebula::ros::RobosenseDriverRosWrapper)</li> <li>robosense_info_sub_ (nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>robosense_scan_sub_ (nebula::ros::RobosenseDriverRosWrapper)</li> <li>ReceiveInfoDataCallback (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>RobosenseHwInterfaceRosWrapper (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>robosense_difop_pub_ (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>robosense_scan_pub_ (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>RobosenseCheckStatus (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>RobosenseHwMonitorRosWrapper (nebula::ros::RobosenseHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#s","title":"s","text":"<ul> <li>SecondsToChronoNanoSeconds (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>sensor_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>Shutdown (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>StreamStart (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>StreamStop (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>sensor_configuration_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>set_param_res_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>setup_sensor (nebula::ros::NebulaHwInterfaceWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_members/#t","title":"t","text":"<ul> <li>temperature_names (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>temperature_cold_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>temperature_hot_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#u","title":"u","text":"<ul> <li>updateParameters (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>use_advanced_diagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros::VelodyneDriverRosWrapper)</li> <li>velodyne_scan_sub_ (nebula::ros::VelodyneDriverRosWrapper)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>velodyne_scan_pub_ (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>VelodyneCheckAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckPps (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckSnapshot (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckStatus (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTemperature (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVoltage (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5vRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#w","title":"w","text":"<ul> <li>wrapper_status_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#_1","title":"~","text":"<ul> <li>~HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>~HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_ros/class_member_functions/#c","title":"c","text":"<ul> <li>curl_callback (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#g","title":"g","text":"<ul> <li>GetParameters (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneDriverRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetStatus (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>GetFixedPrecisionString (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetPtreeValue (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros::HesaiDriverRosWrapper)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>HesaiCheckPtp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckRpm (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckStatus (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckTemperature (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltage (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltageHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#i","title":"i","text":"<ul> <li>InitializeDriver (nebula::ros::HesaiDriverRosWrapper, nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>InitializeHwInterface (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>InitializeHesaiDiagnostics (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>InitializeHwMonitor (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeInfoDriver (nebula::ros::RobosenseDriverRosWrapper)</li> <li>InitializeRobosenseDiagnostics (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>InitializeVelodyneDiagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#m","title":"m","text":"<ul> <li>MonitorStart (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStop (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaDriverRosWrapperBase (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros::NebulaHwInterfaceWrapperBase)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros::NebulaHwMonitorWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#o","title":"o","text":"<ul> <li>OnHesaiLidarMonitorTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiLidarMonitorTimerHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiStatusTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>operator= (nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>OnRobosenseStatusTimer (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>OnVelodyneDiagnosticsTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneSnapshotTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneStatusTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#p","title":"p","text":"<ul> <li>PublishCloud (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>paramCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#r","title":"r","text":"<ul> <li>ReceiveScanMsgCallback (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ReceiveScanDataCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>ReceiveInfoMsgCallback (nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>RobosenseDriverRosWrapper (nebula::ros::RobosenseDriverRosWrapper)</li> <li>ReceiveInfoDataCallback (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>RobosenseHwInterfaceRosWrapper (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>RobosenseCheckStatus (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>RobosenseHwMonitorRosWrapper (nebula::ros::RobosenseHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#s","title":"s","text":"<ul> <li>SecondsToChronoNanoSeconds (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>Shutdown (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>StreamStart (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>StreamStop (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#u","title":"u","text":"<ul> <li>updateParameters (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros::VelodyneDriverRosWrapper)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>VelodyneCheckAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckPps (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckSnapshot (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckStatus (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTemperature (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVoltage (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5vRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#_1","title":"~","text":"<ul> <li>~HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>~HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_ros/class_member_variables/#a","title":"a","text":"<ul> <li>aw_points_base_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>aw_points_ex_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ampere_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>ampere_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#c","title":"c","text":"<ul> <li>calibration_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>correction_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>correction_file_path (nebula::ros::HesaiDriverRosWrapper)</li> <li>cbg_m2_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cbg_m_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>cbg_r_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_config (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_config_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_diag_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_inventory (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_inventory_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_tree (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cloud_pub_ (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>calibration_configuration_ (nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_info_time_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>current_sensor_info_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>current_diag_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_time (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_status_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#d","title":"d","text":"<ul> <li>driver_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>delay_hw_ms_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>delay_monitor_ms_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diag_span_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_lidar_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_status_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_update_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_update_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_updater_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_diag_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_snapshot_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#e","title":"e","text":"<ul> <li>error_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#h","title":"h","text":"<ul> <li>hw_interface_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>hardware_id_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#i","title":"i","text":"<ul> <li>interface_status_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_model (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_serial (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_driver_ptr_ (nebula::ros::RobosenseDriverRosWrapper)</li> <li>is_received_info (nebula::ros::RobosenseDriverRosWrapper)</li> <li>info_driver_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>info_packet_buffer_ (nebula::ros::RobosenseHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#k","title":"k","text":"<ul> <li>key_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_model (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_serial (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#m","title":"m","text":"<ul> <li>mtx_config_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>message_sep (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_diag (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_lidar_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>mtx_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#n","title":"n","text":"<ul> <li>nebula_points_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>not_supported_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#p","title":"p","text":"<ul> <li>pandar_scan_sub_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>pandar_scan_pub_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#r","title":"r","text":"<ul> <li>retry_hw_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>robosense_info_sub_ (nebula::ros::RobosenseDriverRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper)</li> <li>robosense_scan_sub_ (nebula::ros::RobosenseDriverRosWrapper)</li> <li>robosense_difop_pub_ (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> <li>robosense_scan_pub_ (nebula::ros::RobosenseHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#s","title":"s","text":"<ul> <li>sensor_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>sensor_configuration_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwInterfaceRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>set_param_res_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::RobosenseHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>setup_sensor (nebula::ros::NebulaHwInterfaceWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#t","title":"t","text":"<ul> <li>temperature_names (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>temperature_cold_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>temperature_hot_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#u","title":"u","text":"<ul> <li>use_advanced_diagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#v","title":"v","text":"<ul> <li>velodyne_scan_sub_ (nebula::ros::VelodyneDriverRosWrapper)</li> <li>velodyne_scan_pub_ (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>voltage_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#w","title":"w","text":"<ul> <li>wrapper_status_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::RobosenseDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_ros/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"nebula_ros/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_ros/namespace_members/#g","title":"g","text":"<ul> <li>get_param (nebula::ros)</li> </ul>"},{"location":"nebula_ros/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"nebula_ros/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_param (nebula::ros)</li> </ul>"},{"location":"nebula_ros/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"nebula_ros/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"nebula_ros/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"nebula_ros/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_ros/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_ros/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_ros/links/","title":"Nebula ROS","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}